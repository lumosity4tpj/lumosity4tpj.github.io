<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文阅读-超分-Unpaired Image Super-Resolution using Pseudo-Supervision</title>
    <url>/2020/09/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%B6%85%E5%88%86-Unpaired-Image-Super-Resolution-using-Pseudo-Supervision/</url>
    <content><![CDATA[<p><img src="/2020/09/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%B6%85%E5%88%86-Unpaired-Image-Super-Resolution-using-Pseudo-Supervision/1599704646816.png" alt="1599704646816"></p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li>现有的图像超分，一般使用确定的操作对高分辨率图像进行降采样得到配对的数据，但这样的方法使得得到的低分辨率图像跟真实世界的低分辨率图像差异很大；</li>
<li>对于非配对的方法则存在不同程度的缺点。</li>
</ul>
<h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><ul>
<li>本文提出一种使用GAN网络进行非配对训练的超分方法，网络由一个非配对的噪声校正网络和一个伪配对SR网络组成。</li>
<li>校正网络去除噪声，调整输入LR图像的核；然后，通过SR网络对校正后的clean LR图像进行上采样。在训练阶段，校正网络也从输入的HR图像中生成一个伪clean LR图像，然后由SR网络配对学习伪clean LR图像到输入HR图像的映射。由于本文的SR网络是独立于校正网络的，现有网络架构和像素级损失函数可以与提出的框架集成。</li>
<li>在不同数据集上的实验表明，该方法优于现有的解决方法。</li>
</ul>
<h3 id="以前的不使用成对图像的方法"><a href="#以前的不使用成对图像的方法" class="headerlink" title="以前的不使用成对图像的方法"></a>以前的不使用成对图像的方法</h3><ul>
<li>第一种是直接方法：由生成器学习LR到HR的图像，然后跟真实的HR图像送入判别器判别，缺点是不能使用像素级的loss来训练生成器，导致生成的HR图像效果不佳；</li>
<li>第二种是非直接方法：由真实的HR图像通过生成器生成LR图像，再通过与真实的LR图像进行判别，同时另一个生成器学习从逼近的真实的LR图像到HR图像的生成，缺点是如果生成器生成的LR图像与真实世界的LR图像差别较大，则会导致测试时生成的HR图像效果不佳</li>
</ul>
<p><img src="/2020/09/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%B6%85%E5%88%86-Unpaired-Image-Super-Resolution-using-Pseudo-Supervision/1599699070996.png" alt="1599699070996"></p>
<h3 id="本文的方法"><a href="#本文的方法" class="headerlink" title="本文的方法"></a>本文的方法</h3><p><img src="/2020/09/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%B6%85%E5%88%86-Unpaired-Image-Super-Resolution-using-Pseudo-Supervision/1599699544705.png" alt="1599699544705"></p>
<p>同时克服了上述两种方法的缺点，将整个网络分离为一个未配对的核/噪声校正网络和一个伪配对的SR网络(图3)。</p>
<ul>
<li><p><strong>校正网络</strong>(基于cyclegan)</p>
<p>真实的HR的图像经过下采样和添加高斯模糊核等生成一个clean LR，然后通过Gyx与真实的LR图像对抗训练(相当于Gyx在进行内核校正和添加噪声，使得生成的LR图像和真实的LR图像在各个位置上的模糊程度和噪声基本相同)；</p>
<p>然后利用Gxy生成伪clean LR图像并与clean LR图像对抗训练(相当于Gxy学习去噪和去模糊的过程)</p>
</li>
<li><p><strong>超分网络</strong></p>
<p>将生成的伪clean LR图像输入一个上采样网络去生成SR图像，同时利用了真实的HR图像退化后的LR图像生成伪clean LR图像再上采样得到HR图像，可以引入像素的损失，同时做对抗训练，希望生成的SR图像跟真实世界的SR图像相似</p>
</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li>两个经典GAN的损失</li>
</ul>
<p>$$<br>\begin{array}{c}<br>\mathcal{L}<em>{a d v}\left(G</em>{X Y_{\downarrow}}, D_{Y_{\downarrow}}, X, Y_{\downarrow}\right)=\mathbb{E}<em>{y</em>{\downarrow} \sim P_{Y_{\downarrow}}}\left[\log D_{Y_{\downarrow}}\left(y_{\downarrow}\right)\right] \<br>+\mathbb{E}<em>{x \sim P</em>{X}}\left[\log \left(1-D_{Y_{\downarrow}}\left(G_{X Y_{\downarrow}}(x)\right)\right)\right]<br>\end{array}<br>$$</p>
<p>$$<br>\begin{aligned}<br>&amp; \mathcal{L}<em>{a d v}\left(\left(G</em>{X Y_{\downarrow}}, G_{Y_{\downarrow} X}\right), D_{X_{\uparrow}}, Y_{\downarrow}, X_{\uparrow}\right) \<br>=&amp; \mathbb{E}<em>{x \sim \mathrm{P}</em>{X}}\left[\log D_{X_{\uparrow}}\left(U_{Y_{\downarrow} Y} \circ G_{X Y_{\downarrow}}(x)\right)\right] \<br>+&amp; \mathbb{E}<em>{y</em>{\downarrow} \sim \mathrm{P}<em>{Y</em>{\downarrow}}}\left[\log \left(1-D_{X_{\uparrow}}\left(U_{Y_{\downarrow} Y}\left(\stackrel{\circ}{y_{\downarrow}}\right)\right)\right)\right]<br>\end{aligned}<br>$$</p>
<ul>
<li>cyclegan的循环一致性损失</li>
</ul>
<p>$$<br>\mathcal{L}<em>{c y c}\left(G</em>{Y_{\downarrow} X}, G_{X Y_{\downarrow}}\right)=\left|G_{X Y_{\downarrow}} \circ G_{Y_{\downarrow} X}\left(y_{\downarrow}\right)-y_{\downarrow}\right|_{1}<br>$$</p>
<ul>
<li>身份匹配损失：(避免色差等，其实就是为了避免经过去噪网络后像素差异过大)</li>
</ul>
<p>$$<br>\mathcal{L}<em>{i d t}\left(G</em>{X Y_{\downarrow}}\right)=\left|G_{X Y_{\downarrow}}\left(y_{\downarrow}\right)-y_{\downarrow}\right|_{1}<br>$$</p>
<ul>
<li>几何损失：为了保证旋转和翻转后的图片不会改变结果，其实就是约束去噪过程的一致性，可以理解为一张图片，经过八组不同的改变，经过Gxy，最后结果是一致的</li>
</ul>
<p>$$<br>\mathcal{L}<em>{g e o}\left(G</em>{X Y_{\downarrow}}\right)=\left|G_{X Y_{\downarrow}}(x)-\sum_{i=1}^{8} T_{i}^{-1}\left(G_{X Y_{\downarrow}}\left(T_{i}(x)\right)\right) / 8\right|_{1}<br>$$</p>
<ul>
<li>总的损失：</li>
</ul>
<p>$$<br>\begin{aligned}<br>\mathcal{L}<em>{\text {trans}} &amp;=\mathcal{L}</em>{\text {adv}}\left(G_{X Y_{\downarrow}}, D_{Y_{\downarrow}}, X, Y_{\downarrow}\right) \<br>&amp;+\mathcal{L}<em>{\text {adv}}\left(G</em>{Y_{\downarrow} X}, D_{X}, Y_{\downarrow}, X\right) \<br>&amp;+\gamma \mathcal{L}<em>{\text {adv}}\left(\left(G</em>{X Y_{\downarrow}}, G_{Y_{\downarrow} X}\right), D_{X_{\uparrow}}, Y_{\downarrow}, X_{\uparrow}\right) \<br>&amp;+\lambda_{\text {cyc}} \mathcal{L}<em>{\text {cyc}}\left(G</em>{Y_{\downarrow} X}, G_{X Y_{\downarrow}}\right) \<br>&amp;+\lambda_{\text {idt}} \mathcal{L}<em>{\text {idt}}\left(G</em>{X Y_{\downarrow}}\right) \<br>&amp;+\lambda_{g e o} \mathcal{L}<em>{g e o}\left(G</em>{X Y_{\downarrow}}\right)<br>\end{aligned}<br>$$</p>
<ul>
<li>L1损失：</li>
</ul>
<p>$$<br>\mathcal{L}<em>{r e c}=\left|U</em>{Y_{\downarrow} Y}\left(\stackrel{\circ}{y_{\downarrow}}\right)-y\right|_{1}<br>$$</p>
<h3 id="部分实验结果"><a href="#部分实验结果" class="headerlink" title="部分实验结果"></a>部分实验结果</h3><p><img src="/2020/09/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%B6%85%E5%88%86-Unpaired-Image-Super-Resolution-using-Pseudo-Supervision/1599702852283.png" alt="1599702852283"></p>
<p>通过对比其它的方法，在DIV2K数据集上可以看出，在峰值信噪比和结构化相似度上均具有最好的值(值越大说明失真度越小)，同时在图片质量上可以看出去噪能力更强</p>
<p><img src="/2020/09/10/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E8%B6%85%E5%88%86-Unpaired-Image-Super-Resolution-using-Pseudo-Supervision/1599704534305.png" alt="1599704534305"></p>
<p>对比其它的基于GAN的非配对超分方法，可以看出在FID上的实验效果也是最好的</p>
]]></content>
      <categories>
        <category>超分</category>
      </categories>
      <tags>
        <tag>论文阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>编程-数据结构与算法-树</title>
    <url>/2020/09/09/%E7%BC%96%E7%A8%8B-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/09/09/w8UKTU.jpg" alt></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由层序遍历构建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtree</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    root = TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> nums[i]!=<span class="literal">None</span>:</span><br><span class="line">            node.left = TreeNode(nums[i])</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==len(nums):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]!=<span class="literal">None</span>:</span><br><span class="line">            node.right = TreeNode(nums[i])</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==len(nums):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">7</span>]</span><br><span class="line">root = createtree(nums)</span><br><span class="line">print(root)</span><br></pre></td></tr></table></figure>



<h3 id="遍历-迭代-递归-Morris"><a href="#遍历-迭代-递归-Morris" class="headerlink" title="遍历(迭代/递归/Morris)"></a>遍历(迭代/递归/Morris)</h3><ul>
<li><p>层次遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((root,<span class="number">0</span>))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            lens = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(lens):</span><br><span class="line">                node,level = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> len(res)==level:</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    queue.append((root.left,level+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    queue.append((root.right,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(node,level)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(res)==level:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                bfs(node.left,level+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                bfs(node.right,level+<span class="number">1</span>)</span><br><span class="line">        bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>前序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                stack.extend(node.right,node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Morris非破坏版</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right!=cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="comment"># 当没有相连时，则相连</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    res.append(cur.val) <span class="comment">##########</span></span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 已经相连时,则断开</span></span><br><span class="line">                <span class="keyword">if</span> pre.right==cur:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Morris破坏版(最后变成了一个单链表)</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 找到左结点的右子树的最右结点与当前根结点相连，当前根结点与左子结点则断开</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = cur</span><br><span class="line">                tmp = cur</span><br><span class="line">                cur = cur.left</span><br><span class="line">                tmp.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Morris非破坏版</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right!=cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="comment"># 当没有相连时，则相连</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 已经相连时,则断开</span></span><br><span class="line">                <span class="keyword">if</span> pre.right==cur:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    res.append(cur.val) <span class="comment">##########</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node = node.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.right</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].right!=node:</span><br><span class="line">                node = stack[<span class="number">-1</span>].right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><ul>
<li><p>由前序，中序构建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(preorder,inorder)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            loc = inorder.index(root.val)</span><br><span class="line">            root.left = helper(preorder,inorder[:loc])</span><br><span class="line">            root.right = helper(preorder,inorder[loc+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,inorder)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># hashmap会快很多</span></span><br><span class="line">        hashmap = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            curval = preorder.pop(<span class="number">0</span>) <span class="comment">##############</span></span><br><span class="line">            cur = TreeNode(curval)</span><br><span class="line">            idx = hashmap[curval]</span><br><span class="line">            cur.left = helper(left,idx<span class="number">-1</span>) <span class="comment">#############</span></span><br><span class="line">            cur.right = helper(idx+<span class="number">1</span>,right) <span class="comment">###########</span></span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>由中，后序构建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        hashmap = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            curval = postorder.pop() <span class="comment">############</span></span><br><span class="line">            cur = TreeNode(curval)</span><br><span class="line">            idx = hashmap[curval]</span><br><span class="line">            cur.right = helper(idx+<span class="number">1</span>,right) <span class="comment">###########</span></span><br><span class="line">            cur.left = helper(left,idx<span class="number">-1</span>) <span class="comment">###############</span></span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLXBvc3RvcmRlci10cmF2ZXJzYWwv" title="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">根据前序和后序遍历构造二叉树<i class="fa fa-external-link"></i></span>不唯一</p>
<p>考虑：前序树的第一个结点和后序树的最后一个结点是根结点，所以前序树的第二个结点是左子树的根结点(若有左子树)，则找到与它相同的后序树的结点，以其为分界点，则可以将其分为左子树和右子树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span><span class="params">(self, pre, post)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        i = post.index(pre[<span class="number">1</span>])</span><br><span class="line">        node.left = self.constructFromPrePost(pre[<span class="number">1</span>:i+<span class="number">2</span>], post[:i+<span class="number">1</span>])</span><br><span class="line">        node.right = self.constructFromPrePost(pre[i+<span class="number">2</span>:], post[i+<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="常见题"><a href="#常见题" class="headerlink" title="常见题"></a>常见题</h3><hr>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLXp1aS1qaW4tZ29uZy1nb25nLXp1LXhpYW4tbGNvZi8=" title="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">面试题68 - I. 二叉搜索树的最近公共祖先<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     if p.val&lt;root.val and q.val&lt;root.val:</span></span><br><span class="line">        <span class="comment">#         return helper(root.left)</span></span><br><span class="line">        <span class="comment">#     elif p.val&gt;root.val and q.val&gt;root.val:</span></span><br><span class="line">        <span class="comment">#         return helper(root.right)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return root</span></span><br><span class="line">        <span class="comment"># return helper(root)</span></span><br><span class="line"></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> p.val&lt;node.val <span class="keyword">and</span> q.val&lt;node.val:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> p.val&gt;node.val <span class="keyword">and</span> q.val&gt;node.val:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWxjb2Yv" title="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">面试题68 - II. 二叉树的最近公共祖先<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># # 找到p或q的位置，若不在同一子树，则返回该根结点，否则返回第一个</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     if not root or root==p or root==q:</span></span><br><span class="line">        <span class="comment">#         return root</span></span><br><span class="line">        <span class="comment">#     left = helper(root.left)</span></span><br><span class="line">        <span class="comment">#     right = helper(root.right)</span></span><br><span class="line">        <span class="comment">#     if not left:</span></span><br><span class="line">        <span class="comment">#         return right</span></span><br><span class="line">        <span class="comment">#     if not right:</span></span><br><span class="line">        <span class="comment">#         return left</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        <span class="comment"># return helper(root)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     nonlocal res</span></span><br><span class="line">        <span class="comment">#     if not root:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment">#     left = helper(root.left)</span></span><br><span class="line">        <span class="comment">#     right = helper(root.right)</span></span><br><span class="line">        <span class="comment">#     mid = p==root or q==root</span></span><br><span class="line">        <span class="comment">#     if mid+left+right&gt;=2:</span></span><br><span class="line">        <span class="comment">#         res = root</span></span><br><span class="line">        <span class="comment">#     return mid or left or right</span></span><br><span class="line">        <span class="comment"># res = TreeNode(None)</span></span><br><span class="line">        <span class="comment"># helper(root)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWRhdGUtYmluYXJ5LXNlYXJjaC10cmVlLw==" title="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># # 递归</span></span><br><span class="line">        <span class="comment"># def helper(root,minval,maxval):</span></span><br><span class="line">        <span class="comment">#     if not root:</span></span><br><span class="line">        <span class="comment">#         return True</span></span><br><span class="line">        <span class="comment">#     if root.val&lt;=minval or root.val&gt;=maxval:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment">#     return helper(root.left,minval,root.val) and helper(root.right,root.val,maxval)</span></span><br><span class="line">        <span class="comment"># return helper(root,float('-inf'),float('inf'))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中序迭代 有序</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        lower = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.val&lt;=lower:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            lower = node.val</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LWRlLXppLWppZS1nb3UtbGNvZi8=" title="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构<i class="fa fa-external-link"></i></span>题目说可能有空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(A,B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> A.val==B.val <span class="keyword">and</span> helper(A.left,B.left) <span class="keyword">and</span> helper(A.right,B.right)</span><br><span class="line">        <span class="keyword">return</span> helper(A,B) <span class="keyword">or</span> self.isSubStructure(A.left,B) <span class="keyword">or</span> self.isSubStructure(A.right,B)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VidHJlZS1vZi1hbm90aGVyLXRyZWUv" title="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树<i class="fa fa-external-link"></i></span>注意子树跟子结构的区别，且题目说非空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span><span class="params">(self, s: TreeNode, t: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s,t)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t <span class="keyword">and</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> s.val==t.val <span class="keyword">and</span> helper(s.left,t.left) <span class="keyword">and</span> helper(s.right,t.right)</span><br><span class="line">        <span class="keyword">return</span> helper(s,t) <span class="keyword">or</span> self.isSubtree(s.left,t) <span class="keyword">or</span> self.isSubtree(s.right,t)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS1qaW5nLXhpYW5nLWxjb2Yv" title="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.mirrorTree(root.right)</span><br><span class="line">        right = self.mirrorTree(root.left)</span><br><span class="line">        root.left,root.right = left,right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZHVpLWNoZW5nLWRlLWVyLWNoYS1zaHUtbGNvZi8=" title="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> left.val==right.val <span class="keyword">and</span> helper(left.left,right.right) <span class="keyword">and</span> helper(left.right,right.left)</span><br><span class="line">        <span class="keyword">return</span> helper(root,root)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 迭代，类似层序遍历</span></span><br><span class="line">        stack = [(root,root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            left,right = stack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> left.val!=right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((left.left,right.right))</span><br><span class="line">            stack.append((left.right,right.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLWhvdS14dS1iaWFuLWxpLXh1LWxpZS1sY29mLw==" title="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            l = i</span><br><span class="line">            <span class="comment"># 找到第一个大于j的元素的位置，即左右子树的分隔点</span></span><br><span class="line">            <span class="keyword">while</span> postorder[l]&lt;postorder[j]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            m = l <span class="comment"># 找到第一个大于j位置的元素位置</span></span><br><span class="line">            <span class="keyword">while</span> postorder[l]&gt;postorder[j]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 判断l==j，表明m之后的元素确实都大于j的元素，即满足二叉搜索树特性，左|右|根，再循环判断左子树及右子树</span></span><br><span class="line">            <span class="keyword">return</span> l==j <span class="keyword">and</span> helper(i,m<span class="number">-1</span>) <span class="keyword">and</span> helper(m,j<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(postorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS16aG9uZy1oZS13ZWktbW91LXlpLXpoaS1kZS1sdS1qaW5nLWxjb2Yv" title="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"> 二叉树中和为某一值的路径<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,target,ans)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">if</span> target==root.val:</span><br><span class="line">                    res.append(ans+[root.val])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                helper(root.left,target-root.val,ans+[root.val])</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                helper(root.right,target-root.val,ans+[root.val])</span><br><span class="line">        res = []</span><br><span class="line">        helper(root,sum,ans=[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZQ==" title="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">111.二叉树的最小深度<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # dfs</span></span><br><span class="line">        <span class="comment"># if not root:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># # 确保是到叶子结点</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     if not root.left and not root.right:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment">#     if root.left and root.right:</span></span><br><span class="line">        <span class="comment">#         return 1+min(helper(root.left),helper(root.right))</span></span><br><span class="line">        <span class="comment">#     if root.left:</span></span><br><span class="line">        <span class="comment">#         return 1+helper(root.left)</span></span><br><span class="line">        <span class="comment">#     if root.right:</span></span><br><span class="line">        <span class="comment">#         return 1+helper(root.right)</span></span><br><span class="line">        <span class="comment"># return helper(root)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([(root,<span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node,depth = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append((node.right,depth+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append((node.left,depth+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=" title="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.right),self.maxDepth(root.left))</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLWJpbmFyeS1zZWFyY2gtdHJlZXMtaWkv" title="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            tree = []</span><br><span class="line">            <span class="comment"># i为根结点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                lefttree = helper(left,i<span class="number">-1</span>)</span><br><span class="line">                righttree = helper(i+<span class="number">1</span>,right)</span><br><span class="line">                <span class="comment"># 从可能的子树中进行排列组合</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> lefttree:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> righttree:</span><br><span class="line">                        cur = TreeNode(i)</span><br><span class="line">                        cur.left = l</span><br><span class="line">                        cur.right = r</span><br><span class="line">                        tree.append(cur)</span><br><span class="line">            <span class="keyword">return</span> tree</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>,n) <span class="keyword">if</span> n&gt;=<span class="number">1</span> <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==" title="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            left = helper(root.right)</span><br><span class="line">            right = helper(root.left)</span><br><span class="line">            root.left,root.right = left,right</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1zb3J0ZWQtYXJyYXktdG8tYmluYXJ5LXNlYXJjaC10cmVlLw==" title="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left+right+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            cur = TreeNode(nums[mid])</span><br><span class="line">            cur.left = helper(left,mid<span class="number">-1</span>)</span><br><span class="line">            cur.right = helper(mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv" title="https://leetcode-cn.com/problems/diameter-of-binary-tree/">二叉树的直径<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftlen = helper(root.left)</span><br><span class="line">            rightlen = helper(root.right)</span><br><span class="line">            res = max(res,<span class="number">1</span>+leftlen+rightlen)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(leftlen,rightlen)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC11bml2YWx1ZS1wYXRoLw==" title="https://leetcode-cn.com/problems/longest-univalue-path/">最长同值路径<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            leftlen,rightlen = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                leftlen = helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                rightlen = helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right <span class="keyword">and</span> root.val==root.left.val <span class="keyword">and</span> root.val==root.right.val:</span><br><span class="line">                res = max(res,<span class="number">1</span>+leftlen+rightlen)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+max(leftlen,rightlen)</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.val==root.left.val:</span><br><span class="line">                res = max(res,<span class="number">1</span>+leftlen)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+leftlen</span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">and</span> root.val==root.right.val:</span><br><span class="line">                res = max(res,<span class="number">1</span>+rightlen)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+rightlen</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbWF4aW11bS1wYXRoLXN1bS8=" title="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 如果是负的，宁愿不加</span></span><br><span class="line">            left = max(helper(root.left),<span class="number">0</span>)</span><br><span class="line">            right = max(helper(root.right),<span class="number">0</span>)</span><br><span class="line">            res = max(res,left+right+root.val)</span><br><span class="line">            <span class="keyword">return</span> max(left,right) + root.val</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1iaW5hcnktdHJlZS10by1saW5rZWQtbGlzdC8=" title="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># morris的变体</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = cur.right</span><br><span class="line">                cur.right = cur.left</span><br><span class="line">                cur.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 类似后序跟morris的结合</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                pre = root.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = root.right</span><br><span class="line">                root.right = root.left</span><br><span class="line">                root.left = <span class="literal">None</span></span><br><span class="line">        helper(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcmlnaHQtc2lkZS12aWV3Lw==" title="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,level)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(res)==level:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">            res[level] = root.val</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>)</span><br><span class="line">        helper(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJpbS1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=" title="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span><span class="params">(self, root: TreeNode, L: int, R: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> root.val&gt;R:</span><br><span class="line">                <span class="keyword">return</span> helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.val&lt;L:</span><br><span class="line">                <span class="keyword">return</span> helper(root.right)</span><br><span class="line">            root.left = helper(root.left)</span><br><span class="line">            root.right = helper(root.right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1ic3QtdG8tZ3JlYXRlci10cmVlLw==" title="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 反序中序遍历</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> total</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.right)</span><br><span class="line">            total += root.val</span><br><span class="line">            root.val = total</span><br><span class="line">            helper(root.left)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                total += node.val</span><br><span class="line">                node.val = total</span><br><span class="line">                node = node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGluZy1oZW5nLWVyLWNoYS1zaHUtbGNvZi8=" title="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">面试题55 - II. 平衡二叉树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> left==<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            right = helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> right==<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> abs(left-right)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(left,right)</span><br><span class="line">        <span class="keyword">return</span> helper(root)!=<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2stY29tcGxldGVuZXNzLW9mLWEtYmluYXJ5LXRyZWUv" title="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([(root,<span class="number">1</span>)])</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node,i = queue.popleft()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&lt;i:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    queue.append((node.left,<span class="number">2</span>*i))</span><br><span class="line">                    queue.append((node.right,<span class="number">2</span>*i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>*<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ3JhcGgtdmFsaWQtdHJlZS8=" title="https://leetcode-cn.com/problems/graph-valid-tree/">261. 以图判树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># class UF:</span></span><br><span class="line">        <span class="comment">#     def __init__(self,n):</span></span><br><span class="line">        <span class="comment">#         self.parents = [i for i in range(n)]</span></span><br><span class="line">        <span class="comment">#         self.rank = [0 for _ in range(n)]</span></span><br><span class="line">        <span class="comment">#         self.size = [1 for _ in range(n)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     def find(self,p):</span></span><br><span class="line">        <span class="comment">#         if self.parents[p]!=p:</span></span><br><span class="line">        <span class="comment">#             self.parents[p] = self.find(self.parents[p])</span></span><br><span class="line">        <span class="comment">#         return self.parents[p]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     def union(self,p,q):</span></span><br><span class="line">        <span class="comment">#         pr,qr = self.find(p),self.find(q)</span></span><br><span class="line">        <span class="comment">#         if pr==qr:</span></span><br><span class="line">        <span class="comment">#             return</span></span><br><span class="line">        <span class="comment">#         if self.rank[pr]&gt;self.rank[qr]:</span></span><br><span class="line">        <span class="comment">#             pr,qr = qr,pr</span></span><br><span class="line">        <span class="comment">#         self.parents[qr] = pr</span></span><br><span class="line">        <span class="comment">#         if self.rank[pr]==self.rank[qr]:</span></span><br><span class="line">        <span class="comment">#             self.rank[pr] += 1</span></span><br><span class="line">        <span class="comment">#         self.size[pr] += self.size[qr]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if len(edges)!=n-1:</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># uf = UF(n)</span></span><br><span class="line">        <span class="comment"># for i,j in edges:</span></span><br><span class="line">        <span class="comment">#     uf.union(i,j)</span></span><br><span class="line">        <span class="comment"># # 如果能构成一个团</span></span><br><span class="line">        <span class="comment"># for i in uf.size:</span></span><br><span class="line">        <span class="comment">#     if i==n:</span></span><br><span class="line">        <span class="comment">#         return True</span></span><br><span class="line">        <span class="comment"># return False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(edges)!=n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> edges:</span><br><span class="line">            adj[i].append(j)</span><br><span class="line">            adj[j].append(i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adj[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(i)</span><br><span class="line">                    dfs(i)</span><br><span class="line">        visited = set()</span><br><span class="line">        visited.add(<span class="number">0</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(visited)==n</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
