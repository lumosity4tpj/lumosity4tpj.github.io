<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编程-其它</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E5%85%B6%E5%AE%83/</url>
    <content><![CDATA[<h5 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=" title="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        l,r = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            temp = min(height[l],height[r])</span><br><span class="line">            res = max(res,temp*(r-l))</span><br><span class="line">            <span class="keyword">if</span> temp==height[l]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="子矩阵和相关"><a href="#子矩阵和相关" class="headerlink" title="*子矩阵和相关"></a>*子矩阵和相关</h3><p>最后子矩阵一定是在某两行之间的，假设子矩阵在第 i 行和第 j 行之间，那么我们可以枚举所有1&lt;=i&lt;=j&lt;=m,表示最终子矩阵选取的行范围。将每一列第 i 行到第 j 行之间的和求出来，形成一个数组 c，于是一个第 i 行到第 j 行之间的最大子矩阵和对应于这个和数组 c 的最大子段和。</p>
<a id="more"></a>

<h5 id="363-矩形区域不超过-K-的最大数值和"><a href="#363-矩形区域不超过-K-的最大数值和" class="headerlink" title="363. 矩形区域不超过 K 的最大数值和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LXN1bS1vZi1yZWN0YW5nbGUtbm8tbGFyZ2VyLXRoYW4tay8=" title="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumSubmatrix</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># import bisect</span></span><br><span class="line">        <span class="comment"># m,n = len(matrix),len(matrix[0])</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># # 固定左右边界</span></span><br><span class="line">        <span class="comment"># for l in range(n):</span></span><br><span class="line">        <span class="comment">#     sums = [0]*m</span></span><br><span class="line">        <span class="comment">#     for r in range(l,n):</span></span><br><span class="line">        <span class="comment">#         # 每次更新该行到right边界的前缀和</span></span><br><span class="line">        <span class="comment">#         for j in range(m):</span></span><br><span class="line">        <span class="comment">#             sums[j] += matrix[j][r]</span></span><br><span class="line">        <span class="comment">#         cur = 0</span></span><br><span class="line">        <span class="comment">#         arr = [0]</span></span><br><span class="line">        <span class="comment">#         # 固定了左右边界，此时判上下边界</span></span><br><span class="line">        <span class="comment">#         for i in sums:</span></span><br><span class="line">        <span class="comment">#             cur += i</span></span><br><span class="line">        <span class="comment">#             # 每次加入小的面积，再通过大的面积查找小的面积的位置</span></span><br><span class="line">        <span class="comment">#             # 大-小&lt;=k ==&gt; 小&gt;=大-k 所以loc需要&gt;=len(arr)</span></span><br><span class="line">        <span class="comment">#             loc = bisect.bisect_left(arr,cur-k)</span></span><br><span class="line">        <span class="comment">#             if loc&lt;len(arr):</span></span><br><span class="line">        <span class="comment">#                 res = max(res,cur-arr[loc])</span></span><br><span class="line">        <span class="comment">#             bisect.insort(arr,cur)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 暴力超时</span></span><br><span class="line">        <span class="comment"># m,n = len(matrix),len(matrix[0])</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># # 固定左右边界</span></span><br><span class="line">        <span class="comment"># for l in range(n):</span></span><br><span class="line">        <span class="comment">#     sums = [0]*m</span></span><br><span class="line">        <span class="comment">#     for r in range(l,n):</span></span><br><span class="line">        <span class="comment">#         # 每次更新该行到right边界的前缀和</span></span><br><span class="line">        <span class="comment">#         for j in range(m):</span></span><br><span class="line">        <span class="comment">#             sums[j] += matrix[j][r]</span></span><br><span class="line">        <span class="comment">#         # 固定了左右边界，此时判上下边界</span></span><br><span class="line">        <span class="comment">#         maxsum = float('-inf')</span></span><br><span class="line">        <span class="comment">#         for i in range(m):</span></span><br><span class="line">        <span class="comment">#             cur = 0</span></span><br><span class="line">        <span class="comment">#             for j in range(i,m):</span></span><br><span class="line">        <span class="comment">#                 cur += sums[j]</span></span><br><span class="line">        <span class="comment">#                 if cur&lt;=k:</span></span><br><span class="line">        <span class="comment">#                     maxsum = max(maxsum,cur)</span></span><br><span class="line">        <span class="comment">#         res = max(res,maxsum)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 暴力优化</span></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="comment"># 固定左右边界</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(n):</span><br><span class="line">            sums = [<span class="number">0</span>]*m</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(l,n):</span><br><span class="line">                <span class="comment"># 每次更新该行到right边界的前缀和</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                    sums[j] += matrix[j][r]</span><br><span class="line">                <span class="comment"># 固定了左右边界，此时判上下边界</span></span><br><span class="line">                <span class="comment"># 用53.的优化</span></span><br><span class="line">                maxsum = sums[<span class="number">0</span>]</span><br><span class="line">                cur = sums[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">                    <span class="keyword">if</span> cur&lt;<span class="number">0</span>:</span><br><span class="line">                        cur = sums[i]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur += sums[i]</span><br><span class="line">                    maxsum = max(maxsum,cur)</span><br><span class="line">                <span class="comment"># 如果计算出来超过了k再暴力求解</span></span><br><span class="line">                <span class="keyword">if</span> maxsum&gt;k:</span><br><span class="line">                    maxsum = float(<span class="string">'-inf'</span>)</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                        cur = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> range(i,m):</span><br><span class="line">                            cur += sums[j]</span><br><span class="line">                            <span class="keyword">if</span> cur&lt;=k:</span><br><span class="line">                                maxsum = max(maxsum,cur)</span><br><span class="line">                res = max(res,maxsum)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="面试题-17-24-最大子矩阵"><a href="#面试题-17-24-最大子矩阵" class="headerlink" title="面试题 17.24. 最大子矩阵"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LXN1Ym1hdHJpeC1sY2NpLw==" title="https://leetcode-cn.com/problems/max-submatrix-lcci/">面试题 17.24. 最大子矩阵<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxMatrix</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># m,n = len(matrix),len(matrix[0])</span></span><br><span class="line">        <span class="comment"># ans = []</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># for t in range(m):</span></span><br><span class="line">        <span class="comment">#     sums = [0]*n</span></span><br><span class="line">        <span class="comment">#     for b in range(t,m):</span></span><br><span class="line">        <span class="comment">#         for k in range(n):</span></span><br><span class="line">        <span class="comment">#             sums[k] += matrix[b][k]</span></span><br><span class="line">        <span class="comment">#         for i in range(n):</span></span><br><span class="line">        <span class="comment">#             cur = 0</span></span><br><span class="line">        <span class="comment">#             for j in range(i,n):</span></span><br><span class="line">        <span class="comment">#                 cur += sums[j]</span></span><br><span class="line">        <span class="comment">#                 if cur&gt;res:</span></span><br><span class="line">        <span class="comment">#                     res = cur</span></span><br><span class="line">        <span class="comment">#                     ans = [t,i,b,j]</span></span><br><span class="line">        <span class="comment"># return ans</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(m):</span><br><span class="line">            sums = [<span class="number">0</span>]*n</span><br><span class="line">            <span class="keyword">for</span> b <span class="keyword">in</span> range(t,m):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">                    sums[k] += matrix[b][k]</span><br><span class="line">                cur = sums[<span class="number">0</span>]</span><br><span class="line">                temp = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">                maxsum = sums[<span class="number">0</span>]</span><br><span class="line">                l = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                    <span class="keyword">if</span> cur&lt;<span class="number">0</span>:</span><br><span class="line">                        l = i</span><br><span class="line">                        cur = sums[i]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        cur += sums[i]</span><br><span class="line">                    <span class="keyword">if</span> cur&gt;maxsum:</span><br><span class="line">                        maxsum = cur</span><br><span class="line">                        temp = [t,l,b,i]</span><br><span class="line">                <span class="keyword">if</span> maxsum&gt;res:</span><br><span class="line">                    res = maxsum</span><br><span class="line">                    ans = temp</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<h5 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="**440. 字典序的第K小数字"></a>**<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvay10aC1zbWFsbGVzdC1pbi1sZXhpY29ncmFwaGljYWwtb3JkZXIv" title="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/">440. 字典序的第K小数字<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNumber</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 在小于n的情况下计算a,b之间的步数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getcount</span><span class="params">(n,a,b)</span>:</span></span><br><span class="line">            step = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 一直往下计算每一层的步数</span></span><br><span class="line">            <span class="keyword">while</span> a&lt;=n:</span><br><span class="line">                step += min(b,n+<span class="number">1</span>)-a</span><br><span class="line">                a *= <span class="number">10</span></span><br><span class="line">                b *= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> step</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k&gt;<span class="number">0</span>:</span><br><span class="line">            step = getcount(n,i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 在以i开头的区间，向下缩小范围，并减去i这一步</span></span><br><span class="line">            <span class="keyword">if</span> k&lt;step:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">                i *= <span class="number">10</span></span><br><span class="line">            <span class="comment">#  否则在后面的区间，向右搜索，并减去区间的步数</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k -= step</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<h5 id="编程题-多多的电子字典"><a href="#编程题-多多的电子字典" class="headerlink" title="[编程题]多多的电子字典"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvMDYxZDQxOWM3Y2VhNGM2NThlZTA0ODQ2NTRiMTFjM2U=" title="https://www.nowcoder.com/questionTerminal/061d419c7cea4c658ee0484654b11c3e">[编程题]多多的电子字典<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">@lru_cache(None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getcount</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> n </span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    <span class="keyword">return</span> getcount(m<span class="number">-1</span>,n) + getcount(m,n<span class="number">-1</span>) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">n,m,k = map(int,input().split())</span><br><span class="line">cur = <span class="string">'a'</span></span><br><span class="line">k -= <span class="number">1</span></span><br><span class="line">n -= <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> k <span class="keyword">and</span> (n <span class="keyword">or</span> m):</span><br><span class="line">    step = getcount(m,n) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k&lt;step:</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n:</span><br><span class="line">            cur += <span class="string">'a'</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur += <span class="string">'b'</span></span><br><span class="line">            m -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k -= step</span><br><span class="line">        cur = cur[:<span class="number">-1</span>]+<span class="string">'b'</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">print(cur)</span><br></pre></td></tr></table></figure>

<h5 id="编程题-骰子期望"><a href="#编程题-骰子期望" class="headerlink" title="[编程题]骰子期望"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvODZlZjBkNTA0MjkzNGVmNzgxOTAzNTc5NDM3N2E1MDc=" title="https://www.nowcoder.com/questionTerminal/86ef0d5042934ef7819035794377a507">[编程题]骰子期望<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">X = [<span class="number">0</span>]+list(map(int,input().split()))</span><br><span class="line">MAX = max(X)</span><br><span class="line">pre = <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="comment"># 可能的取值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,MAX+<span class="number">1</span>):</span><br><span class="line">    cur = <span class="number">1.</span></span><br><span class="line">    <span class="comment"># 枚举色子</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 每个色子可能&lt;=i的概率</span></span><br><span class="line">        cur *= min(i,X[j])/X[j] </span><br><span class="line">    <span class="comment"># 由所有&lt;=i的情况 - 所有&lt;=i-1的情况 得到=i的所有情况</span></span><br><span class="line">    res += (cur-pre)*i </span><br><span class="line">    pre = cur</span><br><span class="line">print(<span class="string">"%.2f"</span>%res)</span><br></pre></td></tr></table></figure>

<h5 id="378-有序矩阵中第K小的元素"><a href="#378-有序矩阵中第K小的元素" class="headerlink" title="**378. 有序矩阵中第K小的元素"></a>**<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLXNtYWxsZXN0LWVsZW1lbnQtaW4tYS1zb3J0ZWQtbWF0cml4Lw==" title="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix: List[List[int]], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getnums</span><span class="params">(mid,i,j)</span>:</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]&gt;mid:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 列的个数</span></span><br><span class="line">                    count += (i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">        l,r = matrix[<span class="number">0</span>][<span class="number">0</span>],matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="comment"># 从右下角</span></span><br><span class="line">            count = getnums(mid,m<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> count&lt;k:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<h5 id="编程题-二维表第k大数"><a href="#编程题-二维表第k大数" class="headerlink" title="[编程题]二维表第k大数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvOTg5MjliZmU4ZjZiNGJlYmE1ODM4Mjg1YWU5OWFhNmY=" title="https://www.nowcoder.com/questionTerminal/98929bfe8f6b4beba5838285ae99aa6f">[编程题]二维表第k大数<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m,k = map(int,input().split())</span><br><span class="line">l,r,k = <span class="number">1</span>,n*m,n*m-k+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nums</span><span class="params">(mid,i,j)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> j&lt;=n:</span><br><span class="line">        <span class="keyword">if</span> i*j&gt;mid:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count += i</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"><span class="keyword">while</span> l&lt;r:</span><br><span class="line">    mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">    count = get_nums(mid,m,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> count&lt;k:</span><br><span class="line">        l = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = mid</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<h5 id="编程题-推荐结果打散"><a href="#编程题-推荐结果打散" class="headerlink" title="[编程题]推荐结果打散"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvMjM2YzIwYmRjYzcwNDVmNjllZTVmMWQwNmU2NzJhMTY/YW5zd2VyVHlwZT0xJmY9ZGlzY3Vzc2lvbg==" title="https://www.nowcoder.com/questionTerminal/236c20bdcc7045f69ee5f1d06e672a16?answerType=1&f=discussion">[编程题]推荐结果打散<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N = int(input())</span><br><span class="line">M = int(input())</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">if</span> N==<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        res.append(input())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    photo = []</span><br><span class="line">    count = N <span class="comment">##</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        s = input()</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>]==<span class="string">'P'</span>:</span><br><span class="line">            photo.append(s)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 当可以加入P时</span></span><br><span class="line">        <span class="keyword">if</span> count&gt;=N <span class="keyword">and</span> photo:</span><br><span class="line">            res.append(photo.pop(<span class="number">0</span>))</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 对于V，直接加入或者提前加入</span></span><br><span class="line">        res.append(s)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 剩余的P</span></span><br><span class="line">    <span class="keyword">if</span> count&gt;=N <span class="keyword">and</span> photo:</span><br><span class="line">        res.append(photo.pop(<span class="number">0</span>))</span><br><span class="line">print(len(res))</span><br><span class="line">print(<span class="string">"\n"</span>.join(res))</span><br></pre></td></tr></table></figure>

<h5 id="546-移除盒子"><a href="#546-移除盒子" class="headerlink" title="**546. 移除盒子"></a>**<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWJveGVzLw==" title="https://leetcode-cn.com/problems/remove-boxes/">546. 移除盒子<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeBoxes</span><span class="params">(self, boxes: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 超时</span></span><br><span class="line">        <span class="comment"># from functools import lru_cache</span></span><br><span class="line">        <span class="comment"># @lru_cache(None)</span></span><br><span class="line">        <span class="comment"># def helper(boxes):</span></span><br><span class="line">        <span class="comment">#     if not boxes:</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     i = 0</span></span><br><span class="line">        <span class="comment">#     ans = 0</span></span><br><span class="line">        <span class="comment">#     while i&lt;len(boxes):</span></span><br><span class="line">        <span class="comment">#         j = i+1</span></span><br><span class="line">        <span class="comment">#         while j&lt;len(boxes) and boxes[i]==boxes[j]:</span></span><br><span class="line">        <span class="comment">#             j += 1</span></span><br><span class="line">        <span class="comment">#         ans = max(ans,(j-i)**2+helper(boxes[:i]+boxes[j:]))</span></span><br><span class="line">        <span class="comment">#         i = j</span></span><br><span class="line">        <span class="comment">#     return ans</span></span><br><span class="line">        <span class="comment"># return helper(tuple(boxes))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        n = len(boxes)</span><br><span class="line">        <span class="comment"># dp[i][j][k]表示在区间[i,j]之中选取最右点 最右边有k个相同的相连</span></span><br><span class="line">        dp = [[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(l,r,k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> l&gt;r: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> dp[l][r][k]!=<span class="number">0</span>: </span><br><span class="line">                <span class="keyword">return</span> dp[l][r][k]</span><br><span class="line">            <span class="comment"># 找到右边的最长相同情况m,为了跳过更多的步骤 eg: dp[1][5][2]==dp[1][4][3]</span></span><br><span class="line">            <span class="keyword">while</span> r&gt;l <span class="keyword">and</span> boxes[r<span class="number">-1</span>]==boxes[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            dp[l][r][k] = (k+<span class="number">1</span>)**<span class="number">2</span> + helper(l,r<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 找到中间可能的跟r相同的情况,即取max(右边k种时,先删除中间不同部分，再取右边k种+中间相同的)</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(l,r):</span><br><span class="line">                <span class="keyword">if</span> boxes[i]==boxes[r]:</span><br><span class="line">                    dp[l][r][k] = max(dp[l][r][k],helper(l,i,k+<span class="number">1</span>)+helper(i+<span class="number">1</span>,r<span class="number">-1</span>,<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> dp[l][r][k]</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="编程题-报数"><a href="#编程题-报数" class="headerlink" title="[编程题]报数"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvZGRmYzBmNjlkNDJlNDQ2ZTkzM2M3ZjYzOTExMWEwZjU/YW5zd2VyVHlwZT0xJmY9ZGlzY3Vzc2lvbg==" title="https://www.nowcoder.com/questionTerminal/ddfc0f69d42e446e933c7f639111a0f5?answerType=1&f=discussion">[编程题]报数<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(N,M)</span>:</span></span><br><span class="line">    nums = list(range(<span class="number">1</span>,N+<span class="number">1</span>))</span><br><span class="line">    res = []</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> nums:</span><br><span class="line">        idx = idx%len(nums)</span><br><span class="line">        <span class="keyword">if</span> count%M==<span class="number">0</span>:</span><br><span class="line">            res.append(nums.pop(idx))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 只在没到M时才加1，当为M时,idx不变，但相当于在原来的list中加1了</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    print(<span class="string">" "</span>.join(map(str,res)))</span><br><span class="line"></span><br><span class="line">N,M = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> input().split()]</span><br><span class="line">solution(N,M)</span><br></pre></td></tr></table></figure>







<h5 id="剑指-Offer-09-用两个栈实现队列"><a href="#剑指-Offer-09-用两个栈实现队列" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMveW9uZy1saWFuZy1nZS16aGFuLXNoaS14aWFuLWR1aS1saWUtbGNvZi8=" title="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A,self.B = [],[]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure>

<h5 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXN0YWNrLXVzaW5nLXF1ZXVlcy8=" title="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        self.stack = deque()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Push element x onto stack.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(self.stack)<span class="number">-1</span>):</span><br><span class="line">            self.stack.append(self.stack.popleft())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes the element on top of the stack and returns that element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.stack.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the top element.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns whether the stack is empty.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>









<h1 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h1><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># KMP</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(needle)&gt;len(haystack):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getnext</span><span class="params">(needle)</span>:</span></span><br><span class="line">            next = [<span class="number">-1</span>]</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            k = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j&lt;len(needle)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> k==<span class="number">-1</span> <span class="keyword">or</span> needle[j]==needle[k]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># next.append(k)</span></span><br><span class="line">                    <span class="keyword">if</span> needle[j]!=needle[k]:</span><br><span class="line">                        next.append(k)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        next.append(next[k])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = next[k]</span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">KMP</span><span class="params">(haystack,needle)</span>:</span></span><br><span class="line">            next = getnext(needle)</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;len(haystack) <span class="keyword">and</span> j&lt;len(needle):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">-1</span> <span class="keyword">or</span> haystack[i]==needle[j]:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j = next[j]</span><br><span class="line">            <span class="keyword">if</span> j==len(needle):</span><br><span class="line">                <span class="keyword">return</span> i-j</span><br><span class="line">            <span class="keyword">if</span> i==len(haystack):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> KMP(haystack,needle)</span><br></pre></td></tr></table></figure>



<h3 id="Sunday"><a href="#Sunday" class="headerlink" title="Sunday"></a>Sunday</h3><hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># Sunday</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(needle)&gt;len(haystack):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># 偏移表应该从右到左找第一个</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(needle):</span><br><span class="line">            dic[v] = i</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=len(haystack)-len(needle):</span><br><span class="line">            found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(needle)):</span><br><span class="line">                <span class="keyword">if</span> haystack[i+j]!=needle[j]:</span><br><span class="line">                    found = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">if</span> i+len(needle)&lt;len(haystack):</span><br><span class="line">                        <span class="keyword">if</span> haystack[i+len(needle)] <span class="keyword">not</span> <span class="keyword">in</span> needle:</span><br><span class="line">                            i += len(needle)+<span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            i += (len(needle)-dic[haystack[i+len(needle)]])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>



<h1 id="归并-分治思想"><a href="#归并-分治思想" class="headerlink" title="归并/分治思想"></a>归并/分治思想</h1><p><strong>逆序对计算的时候常考虑归并排序 或者连续序列</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LXp1LXpob25nLWRlLW5pLXh1LWR1aS1sY29mLw==" title="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">面试题51. 数组中的逆序对<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePairs</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 暴力法O(N^2)超时</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,n):</span></span><br><span class="line">        <span class="comment">#         if nums[j]&lt;nums[i]:</span></span><br><span class="line">        <span class="comment">#             res += 1</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分治思想:一个数组的逆序对数=左边数组的+右边数组的+跨数组的</span></span><br><span class="line">        <span class="comment"># 在归的时候统计两个数组内部的，合并的时候统计跨数组的</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums,left,right,temp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;=right: <span class="comment">#&gt;是为了防止nums为[]</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            leftcount = MergeSort(nums,left,mid,temp)</span><br><span class="line">            rightcount = MergeSort(nums,mid+<span class="number">1</span>,right,temp)</span><br><span class="line">            <span class="comment"># 经过上面步骤，nums[left..mid]和nums[mid+1..right]已经有序</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;=nums[mid+<span class="number">1</span>]: <span class="comment">#如果已经有序了，则不存在跨数组的倒序对</span></span><br><span class="line">                <span class="keyword">return</span> leftcount+rightcount</span><br><span class="line">            crosscount = merge(nums,left,mid,right,temp)</span><br><span class="line">            <span class="keyword">return</span> leftcount+rightcount+crosscount</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums,left,mid,right,temp)</span>:</span></span><br><span class="line">            <span class="comment"># 临时数组保存左右两边的元素,nums类似保留归并的数组结果</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                temp[i] = nums[i]</span><br><span class="line">            i,j = left,mid+<span class="number">1</span> <span class="comment">#分别指向左右两个数组的前端</span></span><br><span class="line">            k = left <span class="comment">#指向nums</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=right:</span><br><span class="line">                <span class="keyword">if</span> temp[i]&lt;=temp[j]:</span><br><span class="line">                    nums[k] = temp[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[k] = temp[j]</span><br><span class="line">                    count += mid-i+<span class="number">1</span> <span class="comment">#为左边数组中大于j位置元素的个数</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;=mid: <span class="comment">#左边数组剩mid-i+1个元素</span></span><br><span class="line">                nums[k:k+mid-i+<span class="number">1</span>] = temp[i:mid+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> j&lt;=right: <span class="comment">#右边数组剩right-j+1</span></span><br><span class="line">                nums[k:k+right-j+<span class="number">1</span>] = temp[j:right+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        </span><br><span class="line">        temp = [<span class="number">0</span>]*(len(nums))</span><br><span class="line">        <span class="keyword">return</span> MergeSort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>,temp)</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtb2Ytc21hbGxlci1udW1iZXJzLWFmdGVyLXNlbGYv" title="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSmaller</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(nums,left,right,temp,res,idx)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;=right:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            MergeSort(nums,left,mid,temp,res,idx)</span><br><span class="line">            MergeSort(nums,mid+<span class="number">1</span>,right,temp,res,idx)</span><br><span class="line">            <span class="keyword">if</span> nums[idx[mid]]&lt;=nums[idx[mid+<span class="number">1</span>]]:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            merge(nums,left,mid,right,temp,res,idx)</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums,left,mid,right,temp,res,idx)</span>:</span></span><br><span class="line">            <span class="comment"># 每次更新下标值</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                temp[i] = idx[i] <span class="comment">#保存的是下标，因为可能在更新res时是对应下标，而比较的是元素值，且元素可能有重复，故不能直接用hash</span></span><br><span class="line">            k = left</span><br><span class="line">            i,j = left,mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;=mid <span class="keyword">and</span> j&lt;=right:</span><br><span class="line">                <span class="keyword">if</span> nums[temp[i]]&lt;=nums[temp[j]]:</span><br><span class="line">                    idx[k] = temp[i]</span><br><span class="line">                    res[idx[k]] += j-mid<span class="number">-1</span> <span class="comment">#当左边的数取出时，则右边比i位置小的个数为j-mid-1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    idx[k] = temp[j]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;=mid: <span class="comment">###########</span></span><br><span class="line">                end = k+mid-i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> t <span class="keyword">in</span> range(k,end):</span><br><span class="line">                    idx[t] = temp[i]</span><br><span class="line">                    res[idx[t]] += j-mid<span class="number">-1</span></span><br><span class="line">                    i += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">if</span> j&lt;=right:</span><br><span class="line">                idx[k:k+right-j+<span class="number">1</span>] = temp[j:right+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        temp = [<span class="number">0</span>]*(len(nums))</span><br><span class="line">        res = [<span class="number">0</span>]*(len(nums))</span><br><span class="line">        idx = list(range(len(nums)))</span><br><span class="line">        MergeSort(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>,temp,res,idx)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=" title="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 动规</span></span><br><span class="line">        <span class="comment"># # dp[i] = max(dp[i-1]+a[i],a[i])</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># cur = 0</span></span><br><span class="line">        <span class="comment"># for i in nums:</span></span><br><span class="line">        <span class="comment">#     # 选或者不选</span></span><br><span class="line">        <span class="comment">#     cur = max(cur+i,i)</span></span><br><span class="line">        <span class="comment">#     res = max(res,cur)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 分治，在分的时候判断组内，在合的时候判断组间</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left==right:</span><br><span class="line">                <span class="keyword">return</span> nums[left]</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            maxleft = Merge(nums,left,mid)</span><br><span class="line">            maxright = Merge(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">            maxcross = merge(nums,left,mid,right)</span><br><span class="line">            <span class="keyword">return</span> max(maxleft,maxright,maxcross)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从mid向两边扩散</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums,left,mid,right)</span>:</span></span><br><span class="line">            leftres,cur = float(<span class="string">'-inf'</span>),<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(mid,left<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment"># 包含mid时则不需要return时的判断</span></span><br><span class="line">            <span class="comment"># for i in range(mid-1,left-1,-1):</span></span><br><span class="line">                cur += nums[i]</span><br><span class="line">                leftres = max(cur,leftres)</span><br><span class="line">            rightres,cur = float(<span class="string">'-inf'</span>),<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(mid+<span class="number">1</span>,right+<span class="number">1</span>):</span><br><span class="line">                cur += nums[i]</span><br><span class="line">                rightres = max(cur,rightres)</span><br><span class="line">            <span class="keyword">return</span> leftres+rightres</span><br><span class="line">            <span class="comment"># return max(nums[mid],leftres+nums[mid],nums[mid]+rightres,leftres+nums[mid]+rightres)</span></span><br><span class="line">        <span class="keyword">return</span> Merge(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="23-合并K个排序链表"><a href="#23-合并K个排序链表" class="headerlink" title="23. 合并K个排序链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2Utay1zb3J0ZWQtbGlzdHMv" title="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个排序链表<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># # 分治</span></span><br><span class="line">        <span class="comment"># def Merge(lists,left,right):</span></span><br><span class="line">        <span class="comment">#     if left&gt;right:</span></span><br><span class="line">        <span class="comment">#         return []</span></span><br><span class="line">        <span class="comment">#     if left==right:</span></span><br><span class="line">        <span class="comment">#         return lists[left]</span></span><br><span class="line">        <span class="comment">#     mid = (left+right)&gt;&gt;1</span></span><br><span class="line">        <span class="comment">#     l1 = Merge(lists,left,mid)</span></span><br><span class="line">        <span class="comment">#     l2 = Merge(lists,mid+1,right)</span></span><br><span class="line">        <span class="comment">#     ans = merge(l1,l2)</span></span><br><span class="line">        <span class="comment">#     return ans</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># def merge(l1,l2):</span></span><br><span class="line">        <span class="comment">#     head = ListNode(None)</span></span><br><span class="line">        <span class="comment">#     first = head</span></span><br><span class="line">        <span class="comment">#     while l1 and l2:</span></span><br><span class="line">        <span class="comment">#         if l1.val&lt;=l2.val:</span></span><br><span class="line">        <span class="comment">#             head.next = l1</span></span><br><span class="line">        <span class="comment">#             l1 = l1.next</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             head.next = l2</span></span><br><span class="line">        <span class="comment">#             l2 = l2.next</span></span><br><span class="line">        <span class="comment">#         head = head.next</span></span><br><span class="line">        <span class="comment">#     if l1:</span></span><br><span class="line">        <span class="comment">#         head.next = l1</span></span><br><span class="line">        <span class="comment">#     if l2:</span></span><br><span class="line">        <span class="comment">#         head.next = l2</span></span><br><span class="line">        <span class="comment">#     return first.next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return Merge(lists,0,len(lists)-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优先队列</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        first = head</span><br><span class="line">        queue = []</span><br><span class="line">        <span class="comment"># 先把每个有效链表的头节点排序加入</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lists)):</span><br><span class="line">            <span class="keyword">if</span> lists[i]:</span><br><span class="line">                heapq.heappush(queue,(lists[i].val,i))</span><br><span class="line">                lists[i] = lists[i].next</span><br><span class="line">        <span class="comment"># 每次连接一个最小节点，再判断该最小结点的链表的下一节点排序加入</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            val,idx = heapq.heappop(queue)</span><br><span class="line">            head.next = ListNode(val)</span><br><span class="line">            head = head.next</span><br><span class="line">            <span class="keyword">if</span> lists[idx]:</span><br><span class="line">                heapq.heappush(queue,(lists[idx].val,idx))</span><br><span class="line">                lists[idx] = lists[idx].next</span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure>



<h1 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h1><h5 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FuLXBsYWNlLWZsb3dlcnMv" title="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPlaceFlowers</span><span class="params">(self, flowerbed: List[int], n: int)</span> -&gt; bool:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        flowerbed = [<span class="number">0</span>] + flowerbed + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(flowerbed)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> flowerbed[i<span class="number">-1</span>]==<span class="number">1</span> <span class="keyword">or</span> flowerbed[i]==<span class="number">1</span> <span class="keyword">or</span> flowerbed[i+<span class="number">1</span>]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 只有当自身及左右均为0的时候才可以种植</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            flowerbed[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count&gt;=n</span><br></pre></td></tr></table></figure>



<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p>主要跟排列相关</p>
<h5 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==" title="https://leetcode-cn.com/problems/permutations/">46. 全排列<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># def helper(nums,path):</span></span><br><span class="line">        <span class="comment">#     if not nums:</span></span><br><span class="line">        <span class="comment">#         res.append(path)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">#     for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#         helper(nums[:i]+nums[i+1:],path+[nums[i]])</span></span><br><span class="line">        <span class="comment"># helper(nums,[])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(visited)==len(nums):</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(j)</span><br><span class="line">                    helper(path+[nums[j]])</span><br><span class="line">                    visited.remove(j)</span><br><span class="line">        res = []</span><br><span class="line">        helper([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="*47. 全排列 II"></a>*<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLWlpLw==" title="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path)==len(nums):</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> i<span class="number">-1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                       <span class="keyword">continue</span></span><br><span class="line">                    visited.add(i)</span><br><span class="line">                    helper(path+[nums[i]])</span><br><span class="line">                    visited.remove(i)</span><br><span class="line">        helper([])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="*51. N皇后"></a>*<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbi1xdWVlbnMv" title="https://leetcode-cn.com/problems/n-queens/">51. N皇后<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        <span class="comment"># 即每次从行中选择列的位置去放置</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(row,matrix)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> row==n:</span><br><span class="line">                temp = [<span class="string">""</span>.join(matrix[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">                res.append(temp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> isvalid(row,col):</span><br><span class="line">                    matrix[row][col] = <span class="string">'Q'</span></span><br><span class="line">                    backtrack(row+<span class="number">1</span>,matrix)</span><br><span class="line">                    matrix[row][col] = <span class="string">'.'</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 行已经是合法的，且当前只有上方的行有值，故判断列上方，左上方向，右上方向</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isvalid</span><span class="params">(row,col)</span>:</span></span><br><span class="line">            <span class="comment"># 列</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][col]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 左上</span></span><br><span class="line">            i,j = row<span class="number">-1</span>,col<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 右上</span></span><br><span class="line">            i,j = row<span class="number">-1</span>,col+<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;n:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">'Q'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        matrix = [[<span class="string">'.'</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        backtrack(<span class="number">0</span>,matrix)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><h5 id="556-下一个更大元素-III"><a href="#556-下一个更大元素-III" class="headerlink" title="556. 下一个更大元素 III"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaWlpLw==" title="https://leetcode-cn.com/problems/next-greater-element-iii/">556. 下一个更大元素 III<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums = list(map(int,str(n)))</span></span><br><span class="line">        <span class="comment"># # 找到最后一个不是降序的元素的下标i</span></span><br><span class="line">        <span class="comment"># i = len(nums)-2</span></span><br><span class="line">        <span class="comment"># while i&gt;=0:</span></span><br><span class="line">        <span class="comment">#     if nums[i]&lt;nums[i+1]:</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line">        <span class="comment">#     i -= 1</span></span><br><span class="line">        <span class="comment"># # 没找到则返回-1</span></span><br><span class="line">        <span class="comment"># if i&lt;0:</span></span><br><span class="line">        <span class="comment">#     return -1</span></span><br><span class="line">        <span class="comment"># # 找到i之后下一个更大的元素的下标j</span></span><br><span class="line">        <span class="comment"># for j in range(len(nums)-1,i,-1):</span></span><br><span class="line">        <span class="comment">#     if nums[j]&gt;nums[i]:</span></span><br><span class="line">        <span class="comment">#         break</span></span><br><span class="line">        <span class="comment"># # 交换</span></span><br><span class="line">        <span class="comment"># nums[i],nums[j] = nums[j],nums[i]</span></span><br><span class="line">        <span class="comment"># # i之后的元素是单减的，要最小则逆序</span></span><br><span class="line">        <span class="comment"># nums[i+1:] = nums[i+1:][::-1]</span></span><br><span class="line">        <span class="comment"># res = "".join(map(str,nums))</span></span><br><span class="line">        <span class="comment"># return -1 if int(res)&gt;(1&lt;&lt;31)-1 else res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单调栈</span></span><br><span class="line">        nums = list(map(int,str(n)))</span><br><span class="line">        stack = [nums.pop()]</span><br><span class="line">        <span class="keyword">while</span> nums <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;=nums[<span class="number">-1</span>]:</span><br><span class="line">            stack.append(nums.pop())</span><br><span class="line">        <span class="comment"># 此时nums[-1]为之前方法的i的元素</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        i = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 逐个交换，直到找到j</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(stack)):</span><br><span class="line">            <span class="keyword">if</span> stack[j] &gt; nums[<span class="number">-1</span>]:</span><br><span class="line">                stack[j], nums[<span class="number">-1</span>] = nums[<span class="number">-1</span>], stack[j]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums += stack</span><br><span class="line">        res = <span class="string">""</span>.join(map(str,nums))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> int(res)&gt;(<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<h5 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1wZXJtdXRhdGlvbi8=" title="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 从右往左找到第一个非升序的元素</span></span><br><span class="line">        i = len(nums)<span class="number">-2</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;=nums[i+<span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;<span class="number">0</span>:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        j = i </span><br><span class="line">        <span class="comment"># 找到j右边最小的大于j位置元素的元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,j,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;nums[j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># swap</span></span><br><span class="line">        nums[i],nums[j] = nums[j],nums[i]</span><br><span class="line">        <span class="comment"># reverse</span></span><br><span class="line">        nums[j+<span class="number">1</span>:] = nums[j+<span class="number">1</span>:][::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stack = [nums.pop()]</span><br><span class="line">        <span class="keyword">while</span> nums <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;=nums[<span class="number">-1</span>]:</span><br><span class="line">            stack.append(nums.pop())</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            nums += stack</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(stack)):</span><br><span class="line">            <span class="keyword">if</span> stack[j]&gt;nums[<span class="number">-1</span>]:</span><br><span class="line">                nums[<span class="number">-1</span>],stack[j] = stack[j],nums[<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        nums += stack</span><br></pre></td></tr></table></figure>









<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>常见思路：利用前缀和+hashmap来优化时间复杂度，即在遍历的同时一边用hashmap保存相关值，一边查找hashmap中是否存在满足条件的值</p>
<p>一般场景：适用于连续子数组中，找到满足某种条件下的值</p>
<h5 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3VtLWVxdWFscy1rLw==" title="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        hashmap = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        cursum,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            cursum += nums[i]</span><br><span class="line">            <span class="comment"># f[j]-f[i]==k ==&gt; f[j]-k==f[i]</span></span><br><span class="line">            <span class="keyword">if</span> cursum-k <span class="keyword">in</span> hashmap:</span><br><span class="line">                res += hashmap[cursum-k]</span><br><span class="line">            hashmap[cursum] = hashmap.get(cursum,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1248-统计「优美子数组」"><a href="#1248-统计「优美子数组」" class="headerlink" title="1248. 统计「优美子数组」"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtbnVtYmVyLW9mLW5pY2Utc3ViYXJyYXlzLw==" title="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/">1248. 统计「优美子数组」<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfSubarrays</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        hashmap = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        curcount,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            curcount += (nums[i]&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># f[j]-f[i]==k ==&gt; f[j]-k==f[i]</span></span><br><span class="line">            <span class="keyword">if</span> curcount-k <span class="keyword">in</span> hashmap:</span><br><span class="line">                res += hashmap[curcount-k]</span><br><span class="line">            hashmap[curcount] = hashmap.get(curcount,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment"># # 统计奇数的下标</span></span><br><span class="line">        <span class="comment"># odd = []</span></span><br><span class="line">        <span class="comment"># for i,v in enumerate(nums):</span></span><br><span class="line">        <span class="comment">#     if v&amp;1:</span></span><br><span class="line">        <span class="comment">#         odd.append(i)</span></span><br><span class="line">        <span class="comment"># odd = [-1] + odd + [len(nums)]</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># # 当恰好有k个奇数时，统计区间的偶数个数，进行排列组合</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(odd)-k):</span></span><br><span class="line">        <span class="comment">#     res += (odd[i]-odd[i-1])*(odd[i+k]-odd[i+k-1])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 滑动窗口</span></span><br><span class="line">        <span class="comment"># l,r = 0,0</span></span><br><span class="line">        <span class="comment"># res,count = 0,0</span></span><br><span class="line">        <span class="comment"># while r&lt;len(nums):</span></span><br><span class="line">        <span class="comment">#     if nums[r]&amp;1:</span></span><br><span class="line">        <span class="comment">#         count += 1</span></span><br><span class="line">        <span class="comment">#     r += 1</span></span><br><span class="line">        <span class="comment">#     # 统计左右的偶数个数</span></span><br><span class="line">        <span class="comment">#     if count==k:</span></span><br><span class="line">        <span class="comment">#         ltemp,rtemp = 1,1</span></span><br><span class="line">        <span class="comment">#         while l&lt;r and nums[l]&amp;1==0:</span></span><br><span class="line">        <span class="comment">#             ltemp += 1</span></span><br><span class="line">        <span class="comment">#             l += 1</span></span><br><span class="line">        <span class="comment">#         r1 = r</span></span><br><span class="line">        <span class="comment">#         while r1&lt;len(nums) and nums[r1]&amp;1==0:</span></span><br><span class="line">        <span class="comment">#             rtemp += 1</span></span><br><span class="line">        <span class="comment">#             r1 += 1</span></span><br><span class="line">        <span class="comment">#         res += ltemp*rtemp</span></span><br><span class="line">        <span class="comment">#         l += 1</span></span><br><span class="line">        <span class="comment">#         count -= 1</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>

<h5 id="974-和可被-K-整除的子数组"><a href="#974-和可被-K-整除的子数组" class="headerlink" title="974. 和可被 K 整除的子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3Vtcy1kaXZpc2libGUtYnktay8=" title="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/">974. 和可被 K 整除的子数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraysDivByK</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class="line">        hashmap = &#123;<span class="number">0</span>:<span class="number">1</span>&#125;</span><br><span class="line">        curmod,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            curmod += A[i]</span><br><span class="line">            key = curmod%K</span><br><span class="line">            <span class="comment"># (f[j]-f[i])%K==0 ==&gt; f[j]%K==f[i]%K</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> hashmap:</span><br><span class="line">                res += hashmap[key]</span><br><span class="line">            hashmap[key] = hashmap.get(key,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvNHN1bS1paS8=" title="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span><span class="params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span></span><br><span class="line">        hashmap_ab = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B)):</span><br><span class="line">                sum_ab = A[i]+B[j]</span><br><span class="line">                hashmap_ab[sum_ab] = hashmap_ab.get(sum_ab,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(C)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(D)):</span><br><span class="line">                sum_cd = C[i]+D[j]</span><br><span class="line">                <span class="comment"># f1[i]+f2[j]==0 ==&gt; f2[j]==-f1[i]</span></span><br><span class="line">                <span class="keyword">if</span> -sum_cd <span class="keyword">in</span> hashmap_ab:</span><br><span class="line">                    res += hashmap_ab[-sum_cd]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h5 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS8=" title="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> nums[l]!=target:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        start = l</span><br><span class="line">        r = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">                r = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid</span><br><span class="line">        <span class="keyword">return</span> [start,l]</span><br></pre></td></tr></table></figure>

<h1 id="TOPK问题"><a href="#TOPK问题" class="headerlink" title="TOPK问题"></a>TOPK问题</h1><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<h3 id="快速选择法"><a href="#快速选择法" class="headerlink" title="快速选择法"></a>快速选择法</h3><hr>
<p>eg：第k大的数 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva3RoLWxhcmdlc3QtZWxlbWVudC1pbi1hbi1hcnJheS8=" title="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># import heapq</span></span><br><span class="line">        <span class="comment"># nums = [-i for i in nums]</span></span><br><span class="line">        <span class="comment"># heapq.heapify(nums)</span></span><br><span class="line">        <span class="comment"># for i in range(k):</span></span><br><span class="line">        <span class="comment">#     res = heapq.heappop(nums)</span></span><br><span class="line">        <span class="comment"># return -res</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">            pivot = nums[left]</span><br><span class="line">            idx = left+<span class="number">1</span></span><br><span class="line">            i = idx</span><br><span class="line">            <span class="keyword">while</span> i&lt;=right:</span><br><span class="line">                <span class="keyword">if</span> nums[i]&lt;pivot:</span><br><span class="line">                    nums[i],nums[idx] = nums[idx],nums[i]</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            nums[left],nums[idx<span class="number">-1</span>] = nums[idx<span class="number">-1</span>],pivot</span><br><span class="line">            <span class="keyword">return</span> idx<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickselect</span><span class="params">(nums,k,left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&lt;right:</span><br><span class="line">                idx = partition(nums,left,right)</span><br><span class="line">                target = idx-left+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k&lt;target:</span><br><span class="line">                    quickselect(nums,k,left,idx<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">elif</span> k&gt;target:</span><br><span class="line">                    quickselect(nums,k-target,idx+<span class="number">1</span>,right)</span><br><span class="line">        </span><br><span class="line">        quickselect(nums,len(nums)-k+<span class="number">1</span>,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)-k]</span><br></pre></td></tr></table></figure>





<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvN2Q5YTA2MTViM2MzNDhiM2JhY2Y4ZTc2ZjhiNzc5NmE/Zj1kaXNjdXNzaW9u" title="https://www.nowcoder.com/questionTerminal/7d9a0615b3c348b3bacf8e76f8b7796a?f=discussion">[编程题]质因数统计<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = int(input())</span><br><span class="line">dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,math.ceil(math.sqrt(i))+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 非质数才更新，否则为1</span></span><br><span class="line">        <span class="keyword">if</span> i%j==<span class="number">0</span>:</span><br><span class="line">            dp[i] = dp[j] + dp[i//j]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">print(sum(dp[<span class="number">2</span>:]))</span><br></pre></td></tr></table></figure>

<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>矩阵分解的思路<br>$$<br>[f(n),f(n-1)]=[f(n-1),f(n-2)]<em>\begin{vmatrix}1&amp;1\1&amp;0\end{vmatrix}=[f(1),f(0)]</em>\begin{vmatrix}1&amp;1\1&amp;0\end{vmatrix}^{n-1}<br>$$<br>所以主要的时间优化在于矩阵求幂的时候采用快速幂</p>
<h5 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmlib25hY2NpLW51bWJlci8=" title="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># if N==0: return 0</span></span><br><span class="line">        <span class="comment"># if N==1: return 1</span></span><br><span class="line">        <span class="comment"># pre,cur = 0,1</span></span><br><span class="line">        <span class="comment"># for i in range(2,N+1):</span></span><br><span class="line">        <span class="comment">#     cur,pre = pre+cur,cur</span></span><br><span class="line">        <span class="comment"># return cur</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># O(logN)</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matrixpower</span><span class="params">(matrix,N)</span>:</span></span><br><span class="line">            res = matrix</span><br><span class="line">            N -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> N:</span><br><span class="line">                <span class="keyword">if</span> N&amp;<span class="number">1</span>:</span><br><span class="line">                    res = matrixmul(res,matrix)</span><br><span class="line">                matrix = matrixmul(matrix,matrix)</span><br><span class="line">                N &gt;&gt;= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">matrixmul</span><span class="params">(matrix1,matrix2)</span>:</span></span><br><span class="line">            m,p,n = len(matrix1),len(matrix2),len(matrix2[<span class="number">0</span>])</span><br><span class="line">            newmatrix = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(p):</span><br><span class="line">                        newmatrix[i][j] += matrix1[i][k]*matrix2[k][j]</span><br><span class="line">            <span class="keyword">return</span> newmatrix</span><br><span class="line"></span><br><span class="line">        matrix = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">        matrix = matrixpower(matrix,N<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> matrixmul([[<span class="number">1</span>,<span class="number">0</span>]],matrix)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>



<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><hr>
<p>获取二进制中最右边的 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &amp; (-x) 可以获取到二进制中最右边的 1，且其它位设置为 0。</span><br><span class="line"></span><br><span class="line">即</span><br><span class="line">idx = 1</span><br><span class="line">while x&amp;idx==0:</span><br><span class="line">    idx&lt;&lt;=1</span><br></pre></td></tr></table></figure>

<p>去除二进制中最右边的 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &amp; (x - 1) 可以将最右边的 1 设置为 0。</span><br></pre></td></tr></table></figure>

<p>eg：检测是否为2的幂：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># return n &amp; (-n) == n if n&gt;0 else False</span></span><br><span class="line">        <span class="keyword">return</span> n&amp;(n<span class="number">-1</span>)==<span class="number">0</span> <span class="keyword">if</span> n&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>eg：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItamluLXpoaS16aG9uZy0xZGUtZ2Utc2h1LWxjb2Yv" title="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># while n&gt;0:</span></span><br><span class="line">        <span class="comment">#     res += (n&amp;1)</span></span><br><span class="line">        <span class="comment">#     n&gt;&gt;=1</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 更快，因为跳过连续的0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYnUteW9uZy1qaWEtamlhbi1jaGVuZy1jaHUtenVvLWppYS1mYS1sY29mLw==" title="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法<i class="fa fa-external-link"></i></span></p>
<blockquote>
<p>获取负数的补码： 需要将数字与十六进制数 0xffffffff 相与。可理解为舍去此数字 32位以上的数字，从无限长度变为一个 32 位整数。<br>返回前数字还原： 若补码 a 为负数（ 0x7fffffff 是最大的正数的补码 ），需执行 ~(a ^ x) 操作，将补码还原至 Python 的存储格式。 a ^ x 运算将 1至 32 位按位取反； ~ 运算是将整个数字取反；因此， ~(a ^ x) 是将 32 位以上的位取反，即由 0 变为 1 ， 1 至 32 位不变。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (a^b)+((a&amp;b)&lt;&lt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    a &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">    b &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">while</span> b!=<span class="number">0</span>:</span><br><span class="line">        a,b = a^b,(a&amp;b)&lt;&lt;<span class="number">1</span> &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a&lt;<span class="number">0x80000000</span> <span class="keyword">else</span> ~(a^<span class="number">0xffffffff</span>)</span><br></pre></td></tr></table></figure>

<p>eg：有一个数据列表（2N+1个整数），只有一个数出现了1次，其余N个数都出现了2次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任意数和自身异或结果为<span class="number">0</span>；<span class="number">0</span>和任意数异或结果还是其本身</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交换</span></span><br><span class="line">a ^= b</span><br><span class="line">b ^= a</span><br><span class="line">a ^= b</span><br><span class="line"><span class="comment">###即 a,b=b,a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断奇偶</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">else</span> <span class="literal">False</span> 最后为<span class="number">1</span>变为奇，为<span class="number">0</span>则为偶</span><br></pre></td></tr></table></figure>

<h5 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmV2ZXJzZS1iaXRzLw==" title="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBits</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># return int(bin(n)[2:].zfill(32)[::-1],2)</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        power = <span class="number">31</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += (n&amp;<span class="number">1</span>)&lt;&lt;power</span><br><span class="line">            power -= <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>





<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><hr>
<p>eg: <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LXpoaS1kZS16aGVuZy1zaHUtY2ktZmFuZy1sY29mLw==" title="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方<i class="fa fa-external-link"></i></span></p>
<p>即$x^n = x^{a_01+a_12+a_24+a_38+…+a_i2^i}$可以从二进制或二分法两个角度去解释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="comment"># if n&lt;0:</span></span><br><span class="line">        <span class="comment">#     x,n = 1/x,-n</span></span><br><span class="line">        <span class="comment"># res = 1</span></span><br><span class="line">        <span class="comment"># while n:</span></span><br><span class="line">        <span class="comment">#     if n&amp;1: #即n%2==1</span></span><br><span class="line">        <span class="comment">#         res *= x</span></span><br><span class="line">        <span class="comment">#     x *= x</span></span><br><span class="line">        <span class="comment">#     n &gt;&gt;= 1</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> n&lt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/self.myPow(x,-n)</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x*self.myPow(x,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.myPow(x*x,n//<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><hr>
<p>辗转相除法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b)</span><br></pre></td></tr></table></figure>

<h3 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h3><hr>
<p>最小公倍数等于两个数的乘积除以最大公约数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">return</span> a*b//(gcd(a,b))</span><br></pre></td></tr></table></figure>

<h3 id="取数的位数"><a href="#取数的位数" class="headerlink" title="取数的位数"></a>取数的位数</h3><hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="comment"># %10 先模十，取出一位</span></span><br><span class="line"><span class="comment"># /10 再除以10，缩小十倍</span></span><br><span class="line"><span class="comment"># 数的倒序</span></span><br><span class="line">sign = <span class="number">-1</span> <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">x = abs(x)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">    res = res*<span class="number">10</span> + x%<span class="number">10</span> </span><br><span class="line">    x //= <span class="number">10</span></span><br><span class="line">res *= sign</span><br></pre></td></tr></table></figure>

<h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><hr>
<p>N个人编号为1，2，……，N，依次报数，每报到M时，杀掉那个人，求最后胜利者的编号</p>
<p>递推公式为$f(N,M)=(f(N-1,M)+M)%N$，即反推出最后胜利者在每一轮的编号位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">0</span> <span class="comment">#胜利者在只剩一个人时的编号</span></span><br><span class="line"><span class="comment"># i是每一轮的人数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">    res = (res+m)%i</span><br><span class="line"><span class="keyword">return</span> res <span class="comment">#最后的编号</span></span><br></pre></td></tr></table></figure>



<h3 id="数字-1-的个数"><a href="#数字-1-的个数" class="headerlink" title="数字 1 的个数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWRpZ2l0LW9uZS8=" title="https://leetcode-cn.com/problems/number-of-digit-one/">数字 1 的个数<i class="fa fa-external-link"></i></span></h3><hr>
<p>可以推出，对于数n，在每一位$10*i,i=1,10,100,…$(个十百千)的位置上，存在的个数分别为</p>
<p>$[n//(10<em>i)]</em>i+min(max(n%(10*i)-i+1,0),i)$</p>
<p>前一部分表示每($10<em>i$)个数中存在一次，每次有i个(如十位，每100出现一次，一次连着10个，即10,11,12,…19)；后一部分表示最后一个组当中剩下的数(即$n%(10</em>i)$)，若大于$i$，则看其在$i$与$i+i-1$之间有多少个数(n=117，则当按100分组时(即十位)，剩下17，可能在十位为1的数字在10-19之间，即110-117需额外加上)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countDigitOne</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        nums = <span class="number">0</span></span><br><span class="line">        t = n</span><br><span class="line">        <span class="keyword">while</span> t:</span><br><span class="line">            nums += <span class="number">1</span></span><br><span class="line">            t //= <span class="number">10</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(nums):</span><br><span class="line">            i = <span class="number">10</span>**j</span><br><span class="line">            res += n//(<span class="number">10</span>*i)*i + min(max(n%(<span class="number">10</span>*i)-i+<span class="number">1</span>,<span class="number">0</span>),i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="求解一元一次方程"><a href="#求解一元一次方程" class="headerlink" title="求解一元一次方程"></a>求解一元一次方程</h3><hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># eg:输入：2*x+3=x*3-1</span></span><br><span class="line">s = input().replace(<span class="string">'='</span>,<span class="string">'-('</span>) + <span class="string">')'</span></span><br><span class="line">y = eval(s,&#123;<span class="string">'X'</span>:<span class="number">1j</span>&#125;) <span class="comment">#把X替换为复数1j</span></span><br><span class="line">print(int(-y.real/y.imag))</span><br></pre></td></tr></table></figure>

<h5 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXZhbHVhdGUtcmV2ZXJzZS1wb2xpc2gtbm90YXRpb24v" title="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># for i in tokens:</span></span><br><span class="line">        <span class="comment">#     if i=='+':</span></span><br><span class="line">        <span class="comment">#         val = stack.pop()</span></span><br><span class="line">        <span class="comment">#         stack[-1] += val</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     if i=='-':</span></span><br><span class="line">        <span class="comment">#         val = stack.pop()</span></span><br><span class="line">        <span class="comment">#         stack[-1] -= val</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     if i=='/':</span></span><br><span class="line">        <span class="comment">#         val = stack.pop()</span></span><br><span class="line">        <span class="comment">#         stack[-1] = int(stack[-1]/val)</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     if i=='*':</span></span><br><span class="line">        <span class="comment">#         val = stack.pop()</span></span><br><span class="line">        <span class="comment">#         stack[-1] *= val</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     stack.append(int(i))</span></span><br><span class="line">        <span class="comment"># return stack.pop()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># for i in tokens:</span></span><br><span class="line">        <span class="comment">#     if i in '+-*/':</span></span><br><span class="line">        <span class="comment">#         val = stack.pop()</span></span><br><span class="line">        <span class="comment">#         stack[-1] = str(int(eval(stack[-1]+i+val)))</span></span><br><span class="line">        <span class="comment">#         continue</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># return int(stack.pop())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        dics = &#123;<span class="string">'+'</span>:<span class="keyword">lambda</span> x,y:x+y, <span class="string">'-'</span>:<span class="keyword">lambda</span> x,y:x-y, <span class="string">'*'</span>:<span class="keyword">lambda</span> x,y:x*y, <span class="string">'/'</span>:<span class="keyword">lambda</span> x,y:int(x/y)&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">                val = stack.pop()</span><br><span class="line">                stack[<span class="number">-1</span>] = dics[i](stack[<span class="number">-1</span>],val)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            stack.append(int(i))</span><br><span class="line">        <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>



<h3 id="一些好题"><a href="#一些好题" class="headerlink" title="一些好题"></a>一些好题</h3><h5 id="887-鸡蛋掉落"><a href="#887-鸡蛋掉落" class="headerlink" title="887. 鸡蛋掉落"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItZWdnLWRyb3Av" title="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(k,n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> n</span><br><span class="line">            <span class="comment"># # 超时</span></span><br><span class="line">            <span class="comment"># # 若鸡蛋碎，则F在1...x-1层；若鸡蛋未碎，则F在x+1,...,n层</span></span><br><span class="line">            <span class="comment"># ans = float('inf')</span></span><br><span class="line">            <span class="comment"># for x in range(1,n+1):</span></span><br><span class="line">            <span class="comment">#     ans = min(ans,max(dp(k,n-x),dp(k-1,x-1))+1)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 二分</span></span><br><span class="line">            l,r = <span class="number">1</span>,n</span><br><span class="line">            ans = float(<span class="string">'inf'</span>)</span><br><span class="line">            <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">                notbroken = dp(k,n-mid) <span class="comment"># 单减</span></span><br><span class="line">                broken = dp(k<span class="number">-1</span>,mid<span class="number">-1</span>) <span class="comment"># 单增</span></span><br><span class="line">                <span class="keyword">if</span> notbroken&gt;broken:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid </span><br><span class="line">            ans = min(ans,max(dp(k,n-l),dp(k<span class="number">-1</span>,l<span class="number">-1</span>))+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> dp(K,N)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 超时 O(N^2K)</span></span><br><span class="line">        <span class="comment"># # dp[i][j]表示有i层楼j个鸡蛋在最坏情况下最少要扔的鸡蛋数</span></span><br><span class="line">        <span class="comment"># # dp[i][j] = min&#123;m1,m2,...,mi&#125;</span></span><br><span class="line">        <span class="comment"># # mk = max&#123;dp[k-1][j-1],dp[i-k][j]&#125; + 1 表明在第k层扔鸡蛋，如果碎了则在1~k-1层测试，还有j-1个蛋；如果没碎，则在k~i层测试，还有j个蛋</span></span><br><span class="line">        <span class="comment"># dp = [[0]*(K+1) for _ in range(N+1)]</span></span><br><span class="line">        <span class="comment"># for j in range(K+1):</span></span><br><span class="line">        <span class="comment">#     dp[1][j] = 1</span></span><br><span class="line">        <span class="comment"># for i in range(N+1):</span></span><br><span class="line">        <span class="comment">#     dp[i][1] = i</span></span><br><span class="line">        <span class="comment"># for i in range(2,N+1):</span></span><br><span class="line">        <span class="comment">#     for j in range(2,K+1):</span></span><br><span class="line">        <span class="comment">#         dp[i][j] = dp[i][j-1]</span></span><br><span class="line">        <span class="comment">#         for v in range(1,i+1):</span></span><br><span class="line">        <span class="comment">#             dp[i][j] = min(dp[i][j],max(dp[v-1][j-1],dp[i-v][j])+1)</span></span><br><span class="line">        <span class="comment"># return dp[-1][-1]</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># O(NK)</span></span><br><span class="line">        <span class="comment"># dp[i][j]表示用j个鸡蛋扔i次能够判断的最高楼层</span></span><br><span class="line">        <span class="comment"># dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + 1 表明碎与不碎两种情况，即两个区间加起来再加本身即为可以判断的最大高度，即上一种方法的i</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(K+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,K+<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][K]&gt;=N:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW1hbC1zcXVhcmUv" title="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形<i class="fa fa-external-link"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtc3F1YXJlLXN1Ym1hdHJpY2VzLXdpdGgtYWxsLW9uZXMv" title="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/">1277. 统计全为 1 的正方形子矩阵<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    <content><![CDATA[<h1 id="字典树-前缀树"><a href="#字典树-前缀树" class="headerlink" title="字典树/前缀树"></a>字典树/前缀树</h1><p><img src="D:/projects/github/my_notes/please_job/leetcode/pics/1585401054815.png" alt></p>
<p>常见思路：构造一棵多叉树，方便遍历或搜索，注意剪枝条件，且有时候直接hash比前缀树更简单</p>
<p>一般场景：用于字符串搜索或者位运算</p>
<a id="more"></a>

<h5 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXRyaWUtcHJlZml4LXRyZWUv" title="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Trie = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="comment"># if w not in cur:</span></span><br><span class="line">            <span class="comment">#     cur[w] = &#123;&#125;</span></span><br><span class="line">            <span class="comment"># cur = cur[w]</span></span><br><span class="line">            cur = cur.setdefault(w,&#123;&#125;)</span><br><span class="line">        <span class="comment"># 添加结尾标志</span></span><br><span class="line">        cur[<span class="string">'#'</span>] = word</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur[w]</span><br><span class="line">        <span class="comment"># 判断是否到达字典树的叶结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> cur.get(<span class="string">'#'</span>,<span class="number">0</span>) <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            cur = cur[w]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>

<h5 id="211-添加与搜索单词-数据结构设计"><a href="#211-添加与搜索单词-数据结构设计" class="headerlink" title="211. 添加与搜索单词 - 数据结构设计"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkLWFuZC1zZWFyY2gtd29yZC1kYXRhLXN0cnVjdHVyZS1kZXNpZ24v" title="https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/">211. 添加与搜索单词 - 数据结构设计<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Trie = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds a word into the data structure.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            cur = cur.setdefault(w,&#123;&#125;)</span><br><span class="line">        cur[<span class="string">'#'</span>] = word</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="comment"># def helper(word,cur):</span></span><br><span class="line">        <span class="comment">#     if not word:</span></span><br><span class="line">        <span class="comment">#         # return True if cur.get('#') else False</span></span><br><span class="line">        <span class="comment">#         return bool(cur.get('#'))</span></span><br><span class="line">        <span class="comment">#     if word[0]=='.':</span></span><br><span class="line">        <span class="comment">#         for c in cur:</span></span><br><span class="line">        <span class="comment">#             if c!='#' and helper(word[1:],cur[c]):</span></span><br><span class="line">        <span class="comment">#                 return True</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         if word[0] in cur:</span></span><br><span class="line">        <span class="comment">#             return helper(word[1:],cur[word[0]])</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment"># return helper(word,cur)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(word,cur,idx)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> idx==len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'#'</span> <span class="keyword">in</span> cur</span><br><span class="line">            <span class="keyword">if</span> word[idx]==<span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">if</span> c!=<span class="string">'#'</span> <span class="keyword">and</span> helper(word,cur[c],idx+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> word[idx] <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">return</span> helper(word,cur[word[idx]],idx+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> helper(word,cur,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = WordDictionary()</span></span><br><span class="line"><span class="comment"># obj.addWord(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br></pre></td></tr></table></figure>

<h5 id="212-单词搜索-II"><a href="#212-单词搜索-II" class="headerlink" title="212. 单词搜索 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd29yZC1zZWFyY2gtaWkv" title="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span><span class="params">(self, board: List[List[str]], words: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># 将words建字典树</span></span><br><span class="line">        Trie = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            cur = Trie</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">                cur = cur.setdefault(w,&#123;&#125;)</span><br><span class="line">            cur[<span class="string">'#'</span>] = word</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,cur,temp)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> cur:</span><br><span class="line">                res.append(temp)</span><br><span class="line">                <span class="comment"># 删除已找到的单词结尾，但不能return，因为可能存在以当前单词为前缀的单词</span></span><br><span class="line">                cur.pop(<span class="string">'#'</span>)</span><br><span class="line">            <span class="comment"># 为1则表明已访问</span></span><br><span class="line">            val = board[i][j]</span><br><span class="line">            board[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i<span class="number">-1</span>,j),(i+<span class="number">1</span>,j),(i,j<span class="number">-1</span>),(i,j+<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> x&gt;=<span class="number">0</span> <span class="keyword">and</span> y&gt;=<span class="number">0</span> <span class="keyword">and</span> x&lt;m <span class="keyword">and</span> y&lt;n <span class="keyword">and</span> board[x][y]!=<span class="number">1</span> <span class="keyword">and</span> board[x][y] <span class="keyword">in</span> cur:</span><br><span class="line">                    dfs(x,y,cur[board[x][y]],temp+board[x][y])</span><br><span class="line">            board[i][j] = val</span><br><span class="line"></span><br><span class="line">        m,n = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                cur = Trie</span><br><span class="line">                <span class="keyword">if</span> board[i][j] <span class="keyword">in</span> cur:</span><br><span class="line">                    dfs(i,j,cur[board[i][j]],board[i][j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def findWords(self, board: List[List[str]], words: List[str]) -&gt; List[str]:</span></span><br><span class="line"><span class="comment">#         Trie = &#123;&#125;</span></span><br><span class="line"><span class="comment">#         for word in words:</span></span><br><span class="line"><span class="comment">#             cur = Trie</span></span><br><span class="line"><span class="comment">#             for w in word:</span></span><br><span class="line"><span class="comment">#                 cur = cur.setdefault(w,&#123;&#125;)</span></span><br><span class="line"><span class="comment">#             cur['#'] = '#'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         m = len(board)</span></span><br><span class="line"><span class="comment">#         n = len(board[0])</span></span><br><span class="line"><span class="comment">#         visited = [[False]*n for _ in range(m)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         def dfs(i,j,cur,tmp):</span></span><br><span class="line"><span class="comment">#             if board[i][j] in cur:</span></span><br><span class="line"><span class="comment">#                 visited[i][j] = True</span></span><br><span class="line"><span class="comment">#                 if '#' in cur[board[i][j]]:</span></span><br><span class="line"><span class="comment">#                     cur[board[i][j]].pop('#')</span></span><br><span class="line"><span class="comment">#                     # res.add(tmp+board[i][j])</span></span><br><span class="line"><span class="comment">#                     res.append(tmp+board[i][j])</span></span><br><span class="line"><span class="comment">#                 for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span></span><br><span class="line"><span class="comment">#                     if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and not visited[x][y]:</span></span><br><span class="line"><span class="comment">#                         dfs(x,y,cur[board[i][j]],tmp+board[i][j])</span></span><br><span class="line"><span class="comment">#                 visited[i][j] = False</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         # res = set()</span></span><br><span class="line"><span class="comment">#         res = []</span></span><br><span class="line"><span class="comment">#         for i in range(m):</span></span><br><span class="line"><span class="comment">#             for j in range(n):</span></span><br><span class="line"><span class="comment">#                 cur = Trie</span></span><br><span class="line"><span class="comment">#                 dfs(i,j,cur,'')</span></span><br><span class="line"><span class="comment">#         # return list(res)</span></span><br><span class="line"><span class="comment">#         return res</span></span><br></pre></td></tr></table></figure>

<h5 id="336-回文对"><a href="#336-回文对" class="headerlink" title="336. 回文对"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9tZS1wYWlycy8=" title="https://leetcode-cn.com/problems/palindrome-pairs/">336. 回文对<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">palindromePairs</span><span class="params">(self, words: List[str])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># # 暴力法超时</span></span><br><span class="line">        <span class="comment"># n = len(words)</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     for j in range(n):</span></span><br><span class="line">        <span class="comment">#         if i!=j and words[i]+words[j]==(words[i]+words[j])[::-1]:</span></span><br><span class="line">        <span class="comment">#             res.append([i,j])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">## 前缀树+马拉车 太难了！</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># hash</span></span><br><span class="line">        hashmap = &#123;word:i <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(words)&#125;</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(words):</span><br><span class="line">            reversed_word = word[::<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 情况1：直接跟word本身构成回文对</span></span><br><span class="line">            <span class="keyword">if</span> reversed_word <span class="keyword">in</span> hashmap <span class="keyword">and</span> hashmap[reversed_word]!=i:</span><br><span class="line">                res.append([i,hashmap[reversed_word]])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                <span class="comment"># 情况2：word+其它构成回文对，即word内部右边为回文对，右边为回文串的中心处</span></span><br><span class="line">                <span class="comment"># left: from 0 to len(word)-1,即''到word[:len(word)-1]</span></span><br><span class="line">                left = word[:j]</span><br><span class="line">                right = word[j:]</span><br><span class="line">                <span class="keyword">if</span> right==right[::<span class="number">-1</span>] <span class="keyword">and</span> left[::<span class="number">-1</span>] <span class="keyword">in</span> hashmap:</span><br><span class="line">                    res.append([i,hashmap[left[::<span class="number">-1</span>]]])</span><br><span class="line">                <span class="comment"># 情况3：其它+word构成回文对，即word内部左边为回文对，左边为回文串的中心处</span></span><br><span class="line">                <span class="comment"># right: from 1 to len(word),即word[1:]到''</span></span><br><span class="line">                left = word[:j+<span class="number">1</span>]</span><br><span class="line">                right = word[j+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">if</span> left==left[::<span class="number">-1</span>] <span class="keyword">and</span> right[::<span class="number">-1</span>] <span class="keyword">in</span> hashmap:</span><br><span class="line">                    res.append([hashmap[right[::<span class="number">-1</span>]],i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS14b3Itb2YtdHdvLW51bWJlcnMtaW4tYW4tYXJyYXkv" title="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaximumXOR</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># Trie = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># idx = len(bin(max(nums))[2:])</span></span><br><span class="line">        <span class="comment"># for num in nums:</span></span><br><span class="line">        <span class="comment">#     # 二进制位数必须一样，否则下面比较的时候不能确定进入相对应的分支</span></span><br><span class="line">        <span class="comment">#     # num = bin(num)[2:].zfill(32)</span></span><br><span class="line">        <span class="comment">#     num = bin(num)[2:].zfill(idx)</span></span><br><span class="line">        <span class="comment">#     cur = Trie</span></span><br><span class="line">        <span class="comment">#     for n in num:</span></span><br><span class="line">        <span class="comment">#         cur = cur.setdefault(int(n),&#123;&#125;)</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># for num in nums:</span></span><br><span class="line">        <span class="comment">#     # num = bin(num)[2:].zfill(32)</span></span><br><span class="line">        <span class="comment">#     num = bin(num)[2:].zfill(idx)</span></span><br><span class="line">        <span class="comment">#     cur = Trie</span></span><br><span class="line">        <span class="comment">#     temp = 0</span></span><br><span class="line">        <span class="comment">#     # 从高位开始不同，则异或值越大，若为1,则最好为0；若为0，则最好为1；</span></span><br><span class="line">        <span class="comment">#     for i in range(len(num)):</span></span><br><span class="line">        <span class="comment">#         w = int(num[i])</span></span><br><span class="line">        <span class="comment">#         if w^1 in cur:</span></span><br><span class="line">        <span class="comment">#             cur = cur[w^1]</span></span><br><span class="line">        <span class="comment">#             temp += (1&lt;&lt;(len(num)-1-i))</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             cur = cur[w]</span></span><br><span class="line">        <span class="comment">#     res = max(res,temp)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Trie = &#123;&#125;</span><br><span class="line">        idx = len(bin(max(nums))[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 二进制位数必须一样，否则下面比较的时候不能确定进入相对应的分支</span></span><br><span class="line">            cur = Trie</span><br><span class="line">            <span class="comment"># for i in range(31,-1,-1):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(idx,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                bit = (num&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">                cur = cur.setdefault(bit,&#123;&#125;)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            cur = Trie</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 从高位开始不同，则异或值越大，若为1,则最好为0；若为0，则最好为1；</span></span><br><span class="line">            <span class="comment"># for i in range(31,-1,-1):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(idx,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                bit = (num&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit^<span class="number">1</span> <span class="keyword">in</span> cur:</span><br><span class="line">                    cur = cur[bit^<span class="number">1</span>]</span><br><span class="line">                    temp += (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = cur[bit]</span><br><span class="line">            res = max(res,temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # hashmap法 容易晕</span></span><br><span class="line">        <span class="comment"># idx = len(bin(max(nums))[2:])</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># mask = 0</span></span><br><span class="line">        <span class="comment"># for i in range(idx,-1,-1):</span></span><br><span class="line">        <span class="comment">#     # eg: idx=5 ==&gt; mask = 100000 110000 111000 111100 111110 111111</span></span><br><span class="line">        <span class="comment">#     mask = mask | (1&lt;&lt;i)</span></span><br><span class="line">        <span class="comment">#     # 每个元素和mask位与运算</span></span><br><span class="line">        <span class="comment">#     hashmap = &#123;num&amp;mask for num in nums&#125;</span></span><br><span class="line">        <span class="comment">#     # 假设的最大值，即假设将当前位放入异或中，此时需要至少有两个元素在当前位上不同</span></span><br><span class="line">        <span class="comment">#     temp = res | (1&lt;&lt;i)</span></span><br><span class="line">        <span class="comment">#     # 验证假设，t^a=temp ==&gt; temp^t==a 若找到一个a，则满足假设，否则res不变</span></span><br><span class="line">        <span class="comment">#     for t in hashmap:</span></span><br><span class="line">        <span class="comment">#         if temp^t in hashmap:</span></span><br><span class="line">        <span class="comment">#             res = temp</span></span><br><span class="line">        <span class="comment">#             break</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>

<h5 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC13b3JkLWluLWRpY3Rpb25hcnkv" title="https://leetcode-cn.com/problems/longest-word-in-dictionary/">720. 词典中最长的单词<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestWord</span><span class="params">(self, words: List[str])</span> -&gt; str:</span></span><br><span class="line">        Trie = &#123;&#125;</span><br><span class="line">        <span class="comment"># 构建前缀树</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            cur = Trie</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">                cur = cur.setdefault(w,&#123;&#125;)</span><br><span class="line">            cur[<span class="string">'#'</span>] = word</span><br><span class="line">        <span class="comment"># 获得根结点</span></span><br><span class="line">        stack = list(Trie.values())</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="comment"># 如果'#'存在，则表明下一个单词有前缀单词，若无则跳过，去兄弟节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="comment"># 得到保存的单词</span></span><br><span class="line">                word = cur[<span class="string">'#'</span>]</span><br><span class="line">                <span class="comment"># 如果长度更长或者相等且字典序更小时，更新</span></span><br><span class="line">                <span class="keyword">if</span> len(word)&gt;len(res) <span class="keyword">or</span> (len(word)==len(res) <span class="keyword">and</span> word&lt;res):</span><br><span class="line">                    res = word</span><br><span class="line">                <span class="comment"># 向下查找它的子结点</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">if</span> i!=<span class="string">'#'</span>:</span><br><span class="line">                        stack.append(cur[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># res = ''</span></span><br><span class="line">        <span class="comment"># words = set(words)</span></span><br><span class="line">        <span class="comment"># for word in words:</span></span><br><span class="line">        <span class="comment">#     if len(word)&gt;len(res) or (len(word)==len(res) and word&lt;res):</span></span><br><span class="line">        <span class="comment">#         if all(word[:i] in words for i in range(1,len(word))):</span></span><br><span class="line">        <span class="comment">#             res = word</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 排序，第一顺序为长度，第二顺序是字典序</span></span><br><span class="line">        <span class="comment"># words.sort(key=lambda x:(-len(x),x))</span></span><br><span class="line">        <span class="comment"># wordsets = set(words)</span></span><br><span class="line">        <span class="comment"># for word in words:</span></span><br><span class="line">        <span class="comment">#     if all(word[:i] in wordsets for i in range(1,len(word))):</span></span><br><span class="line">        <span class="comment">#         return word</span></span><br></pre></td></tr></table></figure>

<h5 id="692-前K个高频单词"><a href="#692-前K个高频单词" class="headerlink" title="692. 前K个高频单词"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdG9wLWstZnJlcXVlbnQtd29yZHMv" title="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, words: List[str], k: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        <span class="comment"># # hash</span></span><br><span class="line">        <span class="comment"># dics = Counter(words)</span></span><br><span class="line">        <span class="comment"># nums = list(dics.items())</span></span><br><span class="line">        <span class="comment"># nums.sort(key=lambda x:(-x[1],x[0]))</span></span><br><span class="line">        <span class="comment"># return [nums[i][0] for i in range(k)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># heap</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        dics = Counter(words)</span><br><span class="line">        nums = [(-v,k) <span class="keyword">for</span> k,v <span class="keyword">in</span> dics.items()]</span><br><span class="line">        heapq.heapify(nums)</span><br><span class="line">        <span class="keyword">return</span> [heapq.heappop(nums)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br></pre></td></tr></table></figure>

<h5 id="648-单词替换"><a href="#648-单词替换" class="headerlink" title="648. 单词替换"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVwbGFjZS13b3Jkcy8=" title="https://leetcode-cn.com/problems/replace-words/">648. 单词替换<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class Solution:</span></span><br><span class="line"><span class="comment">#     def replaceWords(self, dict: List[str], sentence: str) -&gt; str:</span></span><br><span class="line"><span class="comment">#         # # hashmap</span></span><br><span class="line"><span class="comment">#         # dict = set(dict)</span></span><br><span class="line"><span class="comment">#         # sentence = sentence.split()</span></span><br><span class="line"><span class="comment">#         # for i,word in enumerate(sentence):</span></span><br><span class="line"><span class="comment">#         #     for j in range(1,len(word)):</span></span><br><span class="line"><span class="comment">#         #         if word[:j] in dict:</span></span><br><span class="line"><span class="comment">#         #             sentence[i] = word[:j]</span></span><br><span class="line"><span class="comment">#         #             break</span></span><br><span class="line"><span class="comment">#         # return " ".join(sentence)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         # # hashmap</span></span><br><span class="line"><span class="comment">#         # dict.sort(key=lambda x:len(x))</span></span><br><span class="line"><span class="comment">#         # sentence = sentence.split()</span></span><br><span class="line"><span class="comment">#         # for i,word in enumerate(sentence):</span></span><br><span class="line"><span class="comment">#         #     for j in dict:</span></span><br><span class="line"><span class="comment">#         #         if word.startswith(j):</span></span><br><span class="line"><span class="comment">#         #             sentence[i] = j</span></span><br><span class="line"><span class="comment">#         #             break</span></span><br><span class="line"><span class="comment">#         # return " ".join(sentence)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#         # 前缀树</span></span><br><span class="line"><span class="comment">#         Trie = &#123;&#125;</span></span><br><span class="line"><span class="comment">#         for word in dict:</span></span><br><span class="line"><span class="comment">#             cur = Trie</span></span><br><span class="line"><span class="comment">#             for w in word:</span></span><br><span class="line"><span class="comment">#                 cur = cur.setdefault(w,&#123;&#125;)</span></span><br><span class="line"><span class="comment">#             cur['#'] = word</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#         def startswith(word):</span></span><br><span class="line"><span class="comment">#             cur = Trie</span></span><br><span class="line"><span class="comment">#             for w in word:</span></span><br><span class="line"><span class="comment">#                 # 提前终止</span></span><br><span class="line"><span class="comment">#                 if w not in cur or '#' in cur:</span></span><br><span class="line"><span class="comment">#                     break</span></span><br><span class="line"><span class="comment">#                 cur = cur[w]</span></span><br><span class="line"><span class="comment">#             return cur.get('#')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#         sentence = sentence.split()</span></span><br><span class="line"><span class="comment">#         for i,word in enumerate(sentence):</span></span><br><span class="line"><span class="comment">#             temp = startswith(word)</span></span><br><span class="line"><span class="comment">#             if temp:</span></span><br><span class="line"><span class="comment">#                 sentence[i] = temp</span></span><br><span class="line"><span class="comment">#         return " ".join(sentence)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceWords</span><span class="params">(self, roots, sentence)</span>:</span></span><br><span class="line">        Trie = <span class="keyword">lambda</span>: collections.defaultdict(Trie)</span><br><span class="line">        trie = Trie()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> roots:</span><br><span class="line">            reduce(dict.__getitem__, word, trie)[<span class="string">'#'</span>] = word</span><br><span class="line">            <span class="comment"># print(trie)</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">replace</span><span class="params">(word)</span>:</span></span><br><span class="line">            cur = trie</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">                <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> cur <span class="keyword">or</span> <span class="string">'#'</span> <span class="keyword">in</span> cur:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                cur = cur[w]</span><br><span class="line">            <span class="keyword">return</span> cur.get(<span class="string">'#'</span>, word)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">" "</span>.join(map(replace, sentence.split()))</span><br></pre></td></tr></table></figure>

<h5 id="面试题-17-17-多次搜索"><a href="#面试题-17-17-多次搜索" class="headerlink" title="面试题 17.17. 多次搜索"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbXVsdGktc2VhcmNoLWxjY2kv" title="https://leetcode-cn.com/problems/multi-search-lcci/">面试题 17.17. 多次搜索<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiSearch</span><span class="params">(self, big: str, smalls: List[str])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># for word in smalls:</span></span><br><span class="line">        <span class="comment">#     temp = []</span></span><br><span class="line">        <span class="comment">#     if word:</span></span><br><span class="line">        <span class="comment">#         for i in range(len(big)-len(word)+1):</span></span><br><span class="line">        <span class="comment">#             if big[i:].startswith(word):</span></span><br><span class="line">        <span class="comment">#                 temp.append(i)</span></span><br><span class="line">        <span class="comment">#     res.append(temp)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># hashmap = &#123;&#125;</span></span><br><span class="line">        <span class="comment"># for i,v in enumerate(big):</span></span><br><span class="line">        <span class="comment">#     if v not in hashmap:</span></span><br><span class="line">        <span class="comment">#         hashmap[v] = []</span></span><br><span class="line">        <span class="comment">#     hashmap[v].append(i)</span></span><br><span class="line">        <span class="comment"># for word in smalls:</span></span><br><span class="line">        <span class="comment">#     temp = []</span></span><br><span class="line">        <span class="comment">#     if word and word[0] in hashmap:</span></span><br><span class="line">        <span class="comment">#         for i in hashmap[word[0]]:</span></span><br><span class="line">        <span class="comment">#             if i&lt;=len(big)-len(word) and big[i:].startswith(word):</span></span><br><span class="line">        <span class="comment">#                 temp.append(i)</span></span><br><span class="line">        <span class="comment">#     res.append(temp)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Trie = <span class="keyword">lambda</span>: collections.defaultdict(Trie)</span><br><span class="line">        trie = Trie()</span><br><span class="line">        <span class="comment"># 结尾标志为下标</span></span><br><span class="line">        <span class="keyword">for</span> i,word <span class="keyword">in</span> enumerate(smalls):</span><br><span class="line">            reduce(dict.__getitem__,word,trie)[<span class="string">'#'</span>] = i</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(big)</span>:</span></span><br><span class="line">            res = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(smalls))]</span><br><span class="line">            <span class="comment"># 起始点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(big)):</span><br><span class="line">                cur = trie</span><br><span class="line">                <span class="comment"># 结尾点</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(i,len(big)):</span><br><span class="line">                    <span class="keyword">if</span> big[j] <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    cur = cur[big[j]]</span><br><span class="line">                    <span class="comment"># 如果找到了，则更新；不管是否更新，都会继续往下</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> cur:</span><br><span class="line">                        res[cur[<span class="string">'#'</span>]].append(i)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> search(big)</span><br></pre></td></tr></table></figure>

<h5 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWFwLXN1bS1wYWlycy8=" title="https://leetcode-cn.com/problems/map-sum-pairs/">677. 键值映射<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class MapSum:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     def __init__(self):</span></span><br><span class="line"><span class="comment">#         """</span></span><br><span class="line"><span class="comment">#         Initialize your data structure here.</span></span><br><span class="line"><span class="comment">#         """</span></span><br><span class="line"><span class="comment">#         self.Trie = &#123;&#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">#     def insert(self, key: str, val: int) -&gt; None:</span></span><br><span class="line"><span class="comment">#         self.Trie[key] = val</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     def sum(self, prefix: str) -&gt; int:</span></span><br><span class="line"><span class="comment">#         res = 0</span></span><br><span class="line"><span class="comment">#         for k,v in self.Trie.items():</span></span><br><span class="line"><span class="comment">#             if k.startswith(prefix):</span></span><br><span class="line"><span class="comment">#                 res += v</span></span><br><span class="line"><span class="comment">#         return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.Trie = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, key: str, val: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> key:</span><br><span class="line">            cur = cur.setdefault(k,&#123;&#125;)</span><br><span class="line">        cur[<span class="string">'#'</span>] = val</span><br><span class="line">        <span class="comment"># if key == "aewfwaefjeoawefjwoeajfowajfoewajfoawefjeowajfowaj":</span></span><br><span class="line">        <span class="comment">#     print(self.Trie['a'])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(self, prefix: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 递归</span></span><br><span class="line">        <span class="comment"># cur = self.Trie</span></span><br><span class="line">        <span class="comment"># for k in prefix:</span></span><br><span class="line">        <span class="comment">#     if k not in cur:</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     cur = cur[k]        </span></span><br><span class="line">        <span class="comment"># def helper(cur):</span></span><br><span class="line">        <span class="comment">#     nonlocal res</span></span><br><span class="line">        <span class="comment">#     for k in cur:                </span></span><br><span class="line">        <span class="comment">#         if k=='#':</span></span><br><span class="line">        <span class="comment">#             res += cur['#']</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             helper(cur[k])</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># helper(cur)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        cur = self.Trie</span><br><span class="line">        <span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(prefix):</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            cur = cur[k]</span><br><span class="line">        <span class="comment"># stack = [i for i in cur.values() if isinstance(i,dict)]</span></span><br><span class="line">        <span class="comment"># res = sum([i for i in cur.values() if isinstance(i,int)])</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 可能出现cur为&#123;2,'a':&#123;...&#125;,...&#125;，这个时候的根结点和初值需要额外处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> cur.values():</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,dict):</span><br><span class="line">                stack.append(i)</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,int):</span><br><span class="line">                res += i</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> cur:</span><br><span class="line">                res += cur[<span class="string">'#'</span>]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> cur:</span><br><span class="line">                <span class="keyword">if</span> k!=<span class="string">'#'</span>:</span><br><span class="line">                    stack.append(cur[k])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MapSum()</span></span><br><span class="line"><span class="comment"># obj.insert(key,val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.sum(prefix)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>一般思路：通过两个指针设置一段区间，正常情况下右指针一直向右移动，当区间不满足条件时，左指针也应向右移动，直至满足条件</p>
<p>一般场景：适用于求某个区间，找到满足某种条件下的最值，模板挺好，但有时真的慢，注意<strong>有时跟单调栈结合</strong>，有时需要转换题目求解的思路</p>
<a id="more"></a>

<p>基础模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line">        <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            <span class="comment">// 左移窗口</span></span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=" title="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        windows = &#123;&#125; <span class="comment"># 保存[l,r)字符出现的次数</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(s):</span><br><span class="line">            windows[s[r]] = windows.get(s[r],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> windows[s[r<span class="number">-1</span>]]&gt;<span class="number">1</span>:</span><br><span class="line">                windows[s[l]] -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res,r-l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS13aW5kb3ctc3Vic3RyaW5nLw==" title="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 统计t中字符的次数</span></span><br><span class="line">        need = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            need[c] = need.get(c,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        windows = &#123;&#125; <span class="comment">#保存字符出现的次数</span></span><br><span class="line">        flag = <span class="number">0</span> <span class="comment">#表示满足条件的T中字符的个数</span></span><br><span class="line">        res = s+s</span><br><span class="line">        <span class="keyword">while</span> r&lt;len(s):</span><br><span class="line">            <span class="keyword">if</span> s[r] <span class="keyword">in</span> need:</span><br><span class="line">                windows[s[r]] = windows.get(s[r],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="comment"># == 时才统计，只统计一次</span></span><br><span class="line">                <span class="keyword">if</span> windows[s[r]]==need[s[r]]:</span><br><span class="line">                    flag += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> flag==len(need):</span><br><span class="line">                <span class="keyword">if</span> r-l &lt; len(res):</span><br><span class="line">                    res = s[l:r]</span><br><span class="line">                <span class="keyword">if</span> s[l] <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> windows[s[l]]==need[s[l]]:</span><br><span class="line">                        flag -= <span class="number">1</span></span><br><span class="line">                    windows[s[l]] -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> res==s+s <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure>

<h5 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb24taW4tc3RyaW5nLw==" title="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        need = Counter(s1)</span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        windows = &#123;&#125;</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(s2):</span><br><span class="line">            <span class="keyword">if</span> s2[r] <span class="keyword">in</span> need:</span><br><span class="line">                windows[s2[r]] = windows.get(s2[r],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> windows[s2[r]]==need[s2[r]]:</span><br><span class="line">                    flag += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="comment">##################</span></span><br><span class="line">            <span class="comment"># while r-l&gt;=len(s1):</span></span><br><span class="line">            <span class="comment">#     if flag==len(need):</span></span><br><span class="line">            <span class="comment">#         return True</span></span><br><span class="line">            <span class="comment">################## or</span></span><br><span class="line">            <span class="keyword">while</span> flag==len(need):</span><br><span class="line">                <span class="keyword">if</span> r-l==len(s1):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> s2[l] <span class="keyword">in</span> need:</span><br><span class="line">                    <span class="keyword">if</span> windows[s2[l]]==need[s2[l]]:</span><br><span class="line">                        flag -= <span class="number">1</span></span><br><span class="line">                    windows[s2[l]] -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1hbGwtYW5hZ3JhbXMtaW4tYS1zdHJpbmcv" title="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">        target = Counter(p)</span><br><span class="line">        windows = &#123;&#125;</span><br><span class="line">        res = []</span><br><span class="line">        l,r,flags = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(s):</span><br><span class="line">            <span class="keyword">if</span> s[r] <span class="keyword">in</span> target:</span><br><span class="line">                windows[s[r]] = windows.get(s[r],<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> windows[s[r]]==target[s[r]]:</span><br><span class="line">                    flags += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r-l&gt;=len(p):</span><br><span class="line">                <span class="keyword">if</span> flags==len(target):</span><br><span class="line">                    res.append(l)</span><br><span class="line">                <span class="keyword">if</span> s[l] <span class="keyword">in</span> target:</span><br><span class="line">                    <span class="keyword">if</span> windows[s[l]]==target[s[l]]:</span><br><span class="line">                        flags -= <span class="number">1</span></span><br><span class="line">                    windows[s[l]] -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="713-乘积小于K的子数组"><a href="#713-乘积小于K的子数组" class="headerlink" title="713. 乘积小于K的子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktcHJvZHVjdC1sZXNzLXRoYW4tay8=" title="https://leetcode-cn.com/problems/subarray-product-less-than-k/">713. 乘积小于K的子数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 数组为正整数且要求和&lt;k</span></span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        res,curprod = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(nums):</span><br><span class="line">            curprod *= nums[r]</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> curprod&gt;=k:</span><br><span class="line">                curprod /= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res += (r-l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2xpZGluZy13aW5kb3ctbWF4aW11bS8=" title="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        windows = [] <span class="comment"># 维护一个单调栈，保存下标</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(nums):</span><br><span class="line">            <span class="keyword">while</span> windows <span class="keyword">and</span> nums[windows[<span class="number">-1</span>]]&lt;=nums[r]:</span><br><span class="line">                windows.pop()</span><br><span class="line">            windows.append(r)</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r-l==k:</span><br><span class="line">                res.append(nums[windows[<span class="number">0</span>]])</span><br><span class="line">                <span class="keyword">if</span> windows[<span class="number">0</span>]==l:</span><br><span class="line">                    windows.pop(<span class="number">0</span>)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1438-绝对差不超过限制的最长连续子数组"><a href="#1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="1438. 绝对差不超过限制的最长连续子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb250aW51b3VzLXN1YmFycmF5LXdpdGgtYWJzb2x1dGUtZGlmZi1sZXNzLXRoYW4tb3ItZXF1YWwtdG8tbGltaXQv" title="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestSubarray</span><span class="params">(self, nums: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        minwindows = [] <span class="comment"># 维护一个单调栈，保存下标</span></span><br><span class="line">        maxwindows = [] <span class="comment"># 维护一个单调栈，保存下标</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(nums):</span><br><span class="line">            <span class="keyword">while</span> minwindows <span class="keyword">and</span> nums[minwindows[<span class="number">-1</span>]]&gt;nums[r]:</span><br><span class="line">                minwindows.pop()</span><br><span class="line">            minwindows.append(r)</span><br><span class="line">            <span class="keyword">while</span> maxwindows <span class="keyword">and</span> nums[maxwindows[<span class="number">-1</span>]]&lt;nums[r]:</span><br><span class="line">                maxwindows.pop()</span><br><span class="line">            maxwindows.append(r)</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[maxwindows[<span class="number">0</span>]]-nums[minwindows[<span class="number">0</span>]]&gt;limit:</span><br><span class="line">                <span class="keyword">if</span> l==maxwindows[<span class="number">0</span>]:</span><br><span class="line">                    maxwindows.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> l==minwindows[<span class="number">0</span>]:</span><br><span class="line">                    minwindows.pop(<span class="number">0</span>)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res,r-l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWNvbnNlY3V0aXZlLW9uZXMtaWlpLw==" title="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestOnes</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        curk = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(A):</span><br><span class="line">            <span class="keyword">if</span> A[r]==<span class="number">0</span>:</span><br><span class="line">                curk += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 即区间内最多有K个0</span></span><br><span class="line">            <span class="keyword">while</span> curk==K+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> A[l]==<span class="number">0</span>:</span><br><span class="line">                    curk -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res,r-l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ2V0LWVxdWFsLXN1YnN0cmluZ3Mtd2l0aGluLWJ1ZGdldC8=" title="https://leetcode-cn.com/problems/get-equal-substrings-within-budget/">1208. 尽可能使字符串相等<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equalSubstring</span><span class="params">(self, s: str, t: str, maxCost: int)</span> -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        curcost = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(s):</span><br><span class="line">            curcost += abs(ord(s[r])-ord(t[r]))</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> curcost&gt;maxCost:</span><br><span class="line">                curcost -= abs(ord(s[l])-ord(t[l]))</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            res = max(res,r-l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1423-可获得的最大点数"><a href="#1423-可获得的最大点数" class="headerlink" title="1423. 可获得的最大点数"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1wb2ludHMteW91LWNhbi1vYnRhaW4tZnJvbS1jYXJkcy8=" title="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScore</span><span class="params">(self, cardPoints: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # dfs超时</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># def helper(cardPoints,k,temp):</span></span><br><span class="line">        <span class="comment">#     nonlocal res</span></span><br><span class="line">        <span class="comment">#     if k==0:</span></span><br><span class="line">        <span class="comment">#         res = max(res,temp)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">#     if not cardPoints:</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">#     helper(cardPoints[1:],k-1,temp+cardPoints[0])</span></span><br><span class="line">        <span class="comment">#     helper(cardPoints[:-1],k-1,temp+cardPoints[-1])</span></span><br><span class="line">        <span class="comment"># helper(cardPoints,k,0)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滑动窗口，由题意反过来想，即找到一个区间，使得这个区间的长度刚为len(cardPoints)-k且最小</span></span><br><span class="line">        <span class="keyword">if</span> k==len(cardPoints):</span><br><span class="line">            <span class="keyword">return</span> sum(cardPoints)</span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        cursum = <span class="number">0</span></span><br><span class="line">        res = sum(cardPoints)</span><br><span class="line">        <span class="keyword">while</span> r&lt;len(cardPoints):</span><br><span class="line">            cursum += cardPoints[r]</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r-l==len(cardPoints)-k:</span><br><span class="line">                res = min(res,cursum)</span><br><span class="line">                cursum -= cardPoints[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum(cardPoints)-res</span><br></pre></td></tr></table></figure>

<h5 id="1052-爱生气的书店老板"><a href="#1052-爱生气的书店老板" class="headerlink" title="1052. 爱生气的书店老板"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ3J1bXB5LWJvb2tzdG9yZS1vd25lci8=" title="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 找到X时间内max(顾客数-原本满意的顾客数)，即max(原本不满意的顾客数)</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        cursum = <span class="number">0</span> <span class="comment"># 记录区间内原本不满意的顾客数</span></span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span> <span class="comment"># 记录已经满意的顾客数</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(customers):</span><br><span class="line">            <span class="keyword">if</span> grumpy[r]==<span class="number">1</span>:</span><br><span class="line">                cursum += customers[r]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += customers[r]</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r-l&gt;X:</span><br><span class="line">                <span class="keyword">if</span> grumpy[l]==<span class="number">1</span>:</span><br><span class="line">                    cursum -= customers[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            temp = max(temp,cursum)</span><br><span class="line">        <span class="keyword">return</span> res+temp</span><br></pre></td></tr></table></figure>

<h5 id="978-最长湍流子数组"><a href="#978-最长湍流子数组" class="headerlink" title="978. 最长湍流子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC10dXJidWxlbnQtc3ViYXJyYXkv" title="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxTurbulenceSize</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        l,r = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 由题意,判断当前值与下一值得大小，即希望区间为[1,-1,1,-1,...] or [-1,1,-1,1,...]</span></span><br><span class="line">        <span class="keyword">while</span> r&lt;len(A)<span class="number">-1</span>:</span><br><span class="line">            flag = (A[r]&gt;A[r+<span class="number">1</span>])-(A[r]&lt;A[r+<span class="number">1</span>])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r==len(A)<span class="number">-1</span> <span class="keyword">or</span> ((A[r]&gt;A[r+<span class="number">1</span>])-(A[r]&lt;A[r+<span class="number">1</span>]))*flag!=<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> flag!=<span class="number">0</span>:</span><br><span class="line">                    res = max(res,r-l+<span class="number">1</span>)</span><br><span class="line">                l = r</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>注意：类似反序的写法能够<strong>每次压栈的时候同步更新(意思是每次更新当前步i,使用的是之前入栈的j)</strong>，正序的写法则是<strong>弹栈的时候才更新(意思是每次更新的是之前入栈的j,使用的是当前步i)</strong>；注意哨兵的使用能减少很多边界判断</p>
<a id="more"></a>

<h5 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGFpbHktdGVtcGVyYXR1cmVzLw==" title="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, T: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># # 单调栈正序</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># res = [0 for _ in range(len(T))]</span></span><br><span class="line">        <span class="comment"># for i in range(len(T)):</span></span><br><span class="line">        <span class="comment">#     while stack and T[stack[-1]]&lt;T[i]:</span></span><br><span class="line">        <span class="comment">#         # idx = stack.pop()</span></span><br><span class="line">        <span class="comment">#         # res[idx] = i-idx</span></span><br><span class="line">        <span class="comment">#         res[stack.pop()] = i-stack[-1]</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单调栈逆序</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(T))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(T)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[stack[<span class="number">-1</span>]]&lt;=T[i]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                res[i] = stack[<span class="number">-1</span>]-i</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaS8=" title="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># # 暴力</span></span><br><span class="line">        <span class="comment"># nums = &#123;v:k for k,v in enumerate(nums2)&#125;</span></span><br><span class="line">        <span class="comment"># res = [-1 for _ in range(len(nums1))]</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums1)):</span></span><br><span class="line">        <span class="comment">#     for j in range(nums[nums1[i]]+1,len(nums2)):</span></span><br><span class="line">        <span class="comment">#         if nums2[j]&gt;nums1[i]:</span></span><br><span class="line">        <span class="comment">#             res[i] = nums2[j]</span></span><br><span class="line">        <span class="comment">#             break</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 单调栈正序</span></span><br><span class="line">        <span class="comment"># nums = &#123;v:k for k,v in enumerate(nums1)&#125;</span></span><br><span class="line">        <span class="comment"># res = [-1 for _ in range(len(nums1))]</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># # 利用nums2,构造单调不增栈,每次出栈时判断出栈元素是否在nums1中,在则更新第一个更大的数字</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums2)):</span></span><br><span class="line">        <span class="comment">#     while stack and stack[-1]&lt;nums2[i]:</span></span><br><span class="line">        <span class="comment">#         ele = stack.pop()</span></span><br><span class="line">        <span class="comment">#         # nums1是nums2的子集</span></span><br><span class="line">        <span class="comment">#         if ele in nums:</span></span><br><span class="line">        <span class="comment">#             res[nums[ele]] = nums2[i]</span></span><br><span class="line">        <span class="comment">#     stack.append(nums2[i])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单调栈反序</span></span><br><span class="line">        nums = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(nums1)&#125;</span><br><span class="line">        res = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums1))]</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;=nums2[i]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                <span class="keyword">if</span> nums2[i] <span class="keyword">in</span> nums:</span><br><span class="line">                    res[nums[nums2[i]]] = stack[<span class="number">-1</span>]</span><br><span class="line">            stack.append(nums2[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLWVsZW1lbnQtaWkv" title="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># nums += nums</span></span><br><span class="line">        <span class="comment"># res = [-1 for _ in range(len(nums))]</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># # 拼接时,只有前半部分能满足</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     while stack and nums[stack[-1]]&lt;nums[i]:</span></span><br><span class="line">        <span class="comment">#         res[stack.pop()] = nums[i]</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># return res[:len(res)//2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 单调栈正序</span></span><br><span class="line">        <span class="comment"># res = [-1 for _ in range(len(nums))]</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># n = len(nums) </span></span><br><span class="line">        <span class="comment"># # 循环数组,所以将两个数组相连;栈保存的是下标</span></span><br><span class="line">        <span class="comment"># for i in range(2*n):</span></span><br><span class="line">        <span class="comment">#     while stack and nums[stack[-1]]&lt;nums[i%n]:</span></span><br><span class="line">        <span class="comment">#         res[stack.pop()] = nums[i%n]</span></span><br><span class="line">        <span class="comment">#     stack.append(i%n)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单调栈反序</span></span><br><span class="line">        res = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        stack = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>*n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 需要寻找的大的值,所以&lt;=都要删</span></span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&lt;=nums[i%n]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                res[i%n] = nums[stack[<span class="number">-1</span>]]</span><br><span class="line">            stack.append(i%n)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901. 股票价格跨度"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvb25saW5lLXN0b2NrLXNwYW4v" title="https://leetcode-cn.com/problems/online-stock-span/">901. 股票价格跨度<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 哨兵永远不会出栈</span></span><br><span class="line">        self.stack = [(<span class="number">0</span>,float(<span class="string">'inf'</span>))]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, price: int)</span> -&gt; int:</span></span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.stack <span class="keyword">and</span> self.stack[<span class="number">-1</span>][<span class="number">-1</span>]&lt;=price:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">        res = self.index-self.stack[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">        self.stack.append((self.index,price))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = StockSpanner()</span></span><br><span class="line"><span class="comment"># param_1 = obj.next(price)</span></span><br></pre></td></tr></table></figure>

<h5 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtLw==" title="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 找左右 单调栈逆序</span></span><br><span class="line">        <span class="comment"># heights = [0]+heights+[0] # 哨兵</span></span><br><span class="line">        <span class="comment"># left,right = [0]*len(heights),[len(heights)-1]*len(heights)</span></span><br><span class="line">        <span class="comment"># stack = [0]</span></span><br><span class="line">        <span class="comment"># # 当前坐标左边第一个比它小的坐标</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(heights)-1):</span></span><br><span class="line">        <span class="comment">#     while stack and heights[stack[-1]]&gt;=heights[i]:</span></span><br><span class="line">        <span class="comment">#         stack.pop()</span></span><br><span class="line">        <span class="comment">#     if stack:</span></span><br><span class="line">        <span class="comment">#         left[i] = stack[-1]</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># stack = [len(heights)-1]</span></span><br><span class="line">        <span class="comment"># # 当前坐标右边第一个比它小的坐标</span></span><br><span class="line">        <span class="comment"># for i in range(len(heights)-2,0,-1):</span></span><br><span class="line">        <span class="comment">#     while stack and heights[stack[-1]]&gt;=heights[i]:</span></span><br><span class="line">        <span class="comment">#         stack.pop()</span></span><br><span class="line">        <span class="comment">#     if stack:</span></span><br><span class="line">        <span class="comment">#         right[i] = stack[-1]</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># for i in range(len(heights)):</span></span><br><span class="line">        <span class="comment">#     res = max(res,heights[i]*(right[i]-left[i]-1))</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># # 单调栈正序</span></span><br><span class="line">        <span class="comment"># heights = [0]+heights+[0]</span></span><br><span class="line">        <span class="comment"># left,right = [0]*len(heights),[len(heights)-1]*len(heights)</span></span><br><span class="line">        <span class="comment"># stack = [0]</span></span><br><span class="line">        <span class="comment"># for i in range(1,len(heights)-1):</span></span><br><span class="line">        <span class="comment">#     while stack and heights[stack[-1]]&gt;heights[i]:</span></span><br><span class="line">        <span class="comment">#         right[stack.pop()] = i</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># stack = [len(heights)-1]</span></span><br><span class="line">        <span class="comment"># for i in range(len(heights)-2,0,-1):</span></span><br><span class="line">        <span class="comment">#     while stack and heights[stack[-1]]&gt;heights[i]:</span></span><br><span class="line">        <span class="comment">#         left[stack.pop()] = i</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># for i in range(len(heights)):</span></span><br><span class="line">        <span class="comment">#     res = max(res,heights[i]*(right[i]-left[i]-1))</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 单调栈+常数优化</span></span><br><span class="line">        heights = [<span class="number">0</span>]+heights+[<span class="number">0</span>]</span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heights)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> heights[stack[<span class="number">-1</span>]]&gt;heights[i]:</span><br><span class="line">                <span class="comment"># t对应的是height的坐标</span></span><br><span class="line">                t = stack.pop()</span><br><span class="line">                <span class="comment"># stack[-1]是左(即左边最近的&lt;=heights[t]的坐标),i是右</span></span><br><span class="line">                res = max(res,heights[t]*(i-stack[<span class="number">-1</span>]<span class="number">-1</span>))</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJhcHBpbmctcmFpbi13YXRlci8=" title="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 按列累加</span></span><br><span class="line">        <span class="comment"># if not height: return 0</span></span><br><span class="line">        <span class="comment"># n = len(height)</span></span><br><span class="line">        <span class="comment"># # 记录左右的最大值</span></span><br><span class="line">        <span class="comment"># left = [0 for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># left[0] = height[0]</span></span><br><span class="line">        <span class="comment"># for i in range(1,n):</span></span><br><span class="line">        <span class="comment">#     left[i] = max(left[i-1],height[i])</span></span><br><span class="line">        <span class="comment"># right = [0 for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># right[-1] = height[-1]</span></span><br><span class="line">        <span class="comment"># for i in range(n-2,-1,-1):</span></span><br><span class="line">        <span class="comment">#     right[i] = max(right[i+1],height[i])</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># # 相当于累加计算竖直方向的量</span></span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     if min(left[i],right[i])&gt;height[i]:</span></span><br><span class="line">        <span class="comment">#         res += min(left[i],right[i])-height[i]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 按列累加</span></span><br><span class="line">        <span class="comment"># # 1、定义两个指针 （左、右指针）</span></span><br><span class="line">        <span class="comment"># # 2、定义左、右的边界最大值，并在移动中更新这两个max（用于计算比他低的差值——也就是存水量）。</span></span><br><span class="line">        <span class="comment"># # 3、比较2个指针所在位置的高度，然后谁小谁先移动（左++，右-- 两边收紧模式）</span></span><br><span class="line">        <span class="comment"># # 4、移动的同时计算差值（谁小谁先动，另一边一定比他高所以不用担心漏的问题）</span></span><br><span class="line">        <span class="comment"># # ps:按第一种方法，即我们要找当前位置左右最大高度中小的那一个，现在对于l或r，如果maxleft&lt;maxright，即说明l位置，其左边最大值已经确定为maxleft，右边最大值&gt;=maxright，则最小的左右最大值肯定为maxleft</span></span><br><span class="line">        <span class="comment"># if not height: return 0</span></span><br><span class="line">        <span class="comment"># maxleft,maxright = 0,0</span></span><br><span class="line">        <span class="comment"># n = len(height)</span></span><br><span class="line">        <span class="comment"># l,r = 0,n-1</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># while l&lt;r:</span></span><br><span class="line">        <span class="comment">#     maxleft = max(maxleft,height[l])</span></span><br><span class="line">        <span class="comment">#     maxright = max(maxright,height[r])</span></span><br><span class="line">        <span class="comment">#     if maxleft&lt;maxright:</span></span><br><span class="line">        <span class="comment">#         res += maxleft-height[l]</span></span><br><span class="line">        <span class="comment">#         l += 1</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         res += maxright-height[r]</span></span><br><span class="line">        <span class="comment">#         r -= 1</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单调栈，按行累加</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(height)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[<span class="number">-1</span>]]&lt;height[i]:</span><br><span class="line">                <span class="comment"># 当前下标，i为右，stack[-1]为左</span></span><br><span class="line">                t = stack.pop()</span><br><span class="line">                <span class="comment"># 跳过相同高度部分</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> height[stack[<span class="number">-1</span>]]==height[t]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="comment"># 找到左边第一个比t大的和右边第一个比t大的</span></span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    res += (min(height[i],height[stack[<span class="number">-1</span>]])-height[t])*(i-stack[<span class="number">-1</span>]<span class="number">-1</span>)</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581. 最短无序连续子数组"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2hvcnRlc3QtdW5zb3J0ZWQtY29udGludW91cy1zdWJhcnJheS8=" title="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">581. 最短无序连续子数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 左右边界</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># l = len(nums)-1</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     while stack and nums[stack[-1]]&gt;nums[i]:</span></span><br><span class="line">        <span class="comment">#         l = min(l,stack.pop())</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># r = 0</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)-1,-1,-1):</span></span><br><span class="line">        <span class="comment">#     while stack and nums[stack[-1]]&lt;nums[i]:</span></span><br><span class="line">        <span class="comment">#         r = max(r,stack.pop())</span></span><br><span class="line">        <span class="comment">#     stack.append(i)</span></span><br><span class="line">        <span class="comment"># print(l,r)</span></span><br><span class="line">        <span class="comment"># return 0 if r&lt;=l else r-l+1</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 从左到右找出最后一个破坏递增的数</span></span><br><span class="line">        <span class="comment"># 从右到左找出最后一个破坏递减的数</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        curmax = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;=curmax:</span><br><span class="line">                curmax = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = i</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        curmin = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;=curmin:</span><br><span class="line">                curmin = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> r&lt;=l <span class="keyword">else</span> r-l+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWstZGlnaXRzLw==" title="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        nums = list(map(int,num))</span><br><span class="line">        stack = []</span><br><span class="line">        tmp = set() <span class="comment"># 记录删除的下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 当前面的元素更大时，优先删除前面的元素</span></span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&gt;nums[i]:</span><br><span class="line">                tmp.add(stack.pop())</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 对于剩下的k，此时数组是升序，需要删除末尾的元素</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                tmp.add(len(nums)-i)</span><br><span class="line">        nums = [nums[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)) <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> tmp]</span><br><span class="line">        res = <span class="string">""</span>.join(map(str,nums)).lstrip(<span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res <span class="keyword">else</span> <span class="string">"0"</span></span><br></pre></td></tr></table></figure>

<h5 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316. 去除重复字母"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZS1sZXR0ZXJzLw==" title="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        last = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(s)&#125; <span class="comment"># 记录每个不同元素最后出现的位置</span></span><br><span class="line">        seen = set() <span class="comment"># 记录stack里有的元素</span></span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="comment"># 在保证每个元素必有一个的时候，再判断字典序</span></span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&gt;v <span class="keyword">and</span> i&lt;last[stack[<span class="number">-1</span>]]:</span><br><span class="line">                    seen.discard(stack.pop())</span><br><span class="line">                seen.add(v)</span><br><span class="line">                stack.append(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(stack)</span><br></pre></td></tr></table></figure>

<h5 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV4dC1ncmVhdGVyLW5vZGUtaW4tbGlua2VkLWxpc3Qv" title="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/">1019. 链表中的下一个更大节点<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextLargerNodes</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        dics = collections.defaultdict(list)</span><br><span class="line">        stack = []</span><br><span class="line">        first = head</span><br><span class="line">        <span class="comment"># 记录每个值对应的下一个更大值，对于相同值，最先进入列表的是链表头部</span></span><br><span class="line">        <span class="keyword">while</span> first:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;first.val:</span><br><span class="line">                dics[stack.pop()].append(first.val)</span><br><span class="line">            stack.append(first.val)</span><br><span class="line">            first = first.next</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val <span class="keyword">in</span> dics <span class="keyword">and</span> dics[head.val]:</span><br><span class="line">                res.append(dics[head.val].pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="编程题-逛街"><a href="#编程题-逛街" class="headerlink" title="[编程题]逛街"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvMzVmYWM4ZDY5ZjMxNGU5NThhMTUwYzE0MTg5NGVmNmE/YW5zd2VyVHlwZT0xJmY9ZGlzY3Vzc2lvbg==" title="https://www.nowcoder.com/questionTerminal/35fac8d69f314e958a150c141894ef6a?answerType=1&f=discussion">[编程题]逛街<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">w = list(map(int,input().split()))</span><br><span class="line">res = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    res[i] += len(stack)</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;= w[i]:</span><br><span class="line">        stack.pop()</span><br><span class="line">    stack.append(w[i])</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    res[i] += len(stack)</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>]&lt;=w[i]:</span><br><span class="line">        stack.pop()</span><br><span class="line">    stack.append(w[i])</span><br><span class="line">print(<span class="string">" "</span>.join(map(str,res)))</span><br></pre></td></tr></table></figure>

<h5 id="编程题-编程题2"><a href="#编程题-编程题2" class="headerlink" title="[编程题]编程题2"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvZTZlNTdlZjI3NzE1NDFkZmEyZjE3MjBlNTBiZWJjOWE/YW5zd2VyVHlwZT0xJmY9ZGlzY3Vzc2lvbg==" title="https://www.nowcoder.com/questionTerminal/e6e57ef2771541dfa2f1720e50bebc9a?answerType=1&f=discussion">[编程题]编程题2<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">nums = [<span class="number">0</span>] + list(map(int,input().split())) + [<span class="number">0</span>]</span><br><span class="line">stack = []</span><br><span class="line">r = <span class="number">0</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">cursum = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> r&lt;len(nums):</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]]&gt;nums[r]:</span><br><span class="line">        <span class="comment"># 找到当前最小的值的位置</span></span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        <span class="comment"># 包含当前最小值的最长区间</span></span><br><span class="line">        res = max(res,nums[cur]*sum(nums[stack[<span class="number">-1</span>]+<span class="number">1</span>:r]))</span><br><span class="line">    stack.append(r)</span><br><span class="line">    r += <span class="number">1</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h1><h3 id="dijkstra算法-有权图的单源最短路-gt-适用于所有边权为正值"><a href="#dijkstra算法-有权图的单源最短路-gt-适用于所有边权为正值" class="headerlink" title="dijkstra算法(有权图的单源最短路)==&gt; 适用于所有边权为正值"></a>dijkstra算法(有权图的单源最短路)==&gt; 适用于所有边权为正值</h3><ul>
<li><p><strong>朴素dijkstra算法(时间复杂度为O(n^2+m)，n为结点数，m为边数)</strong></p>
<p>引进两个集合，一个记录已求出最短路径的顶点及对应长度，一个记录还未求出最短路径的顶点及该点到起点的距离</p>
<p>即找出路径最短的结点，再遍历其相邻结点，检查是否有更短的路径，若有则更新</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m = map(int,input().split())</span><br><span class="line">graph = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z = map(int,input().split())</span><br><span class="line">    graph[x<span class="number">-1</span>][y<span class="number">-1</span>] = min(graph[x<span class="number">-1</span>][y<span class="number">-1</span>],z) <span class="comment"># 对于重边只保存最小边</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求0号点到n-1号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(graph)</span>:</span> <span class="comment"># graph是邻接矩阵</span></span><br><span class="line">    n = len(graph)</span><br><span class="line">    dist = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 记录是否已经被访问</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># 从未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        t = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> visited[j]==<span class="number">0</span> <span class="keyword">and</span> (t==<span class="number">-1</span> <span class="keyword">or</span> dist[t]&gt;dist[j]):</span><br><span class="line">                t = j</span><br><span class="line">        <span class="comment"># 更新该点t到其它点的距离</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dist[j] = min(dist[j],dist[t]+graph[t][j])</span><br><span class="line">        visited[t] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">-1</span>] <span class="keyword">if</span> dist[<span class="number">-1</span>]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">print(dijkstra(graph))</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>堆优化版dijkstra算法(时间复杂度为O(mlogn))</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m = map(int,input().split())</span><br><span class="line">adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z = map(int,input().split())</span><br><span class="line">    adj[x<span class="number">-1</span>].append((z,y<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(adj)</span>:</span> <span class="comment"># adj为邻接表</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    n = len(adj)</span><br><span class="line">    dist = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 记录是否已经被访问</span></span><br><span class="line">    prioqueue = [(<span class="number">0</span>,<span class="number">0</span>)] <span class="comment"># 第一个值存储距离，第二个值存储节点编号</span></span><br><span class="line">    <span class="keyword">while</span> prioqueue:</span><br><span class="line">        distance,t = heapq.heappop(prioqueue)</span><br><span class="line">        <span class="keyword">if</span> visited[t]==<span class="number">1</span>: <span class="comment">#因为是最小堆，所以之后的更大可以跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        visited[t] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> d,j <span class="keyword">in</span> adj[t]:</span><br><span class="line">            <span class="keyword">if</span> dist[j]&gt;dist[t]+d:</span><br><span class="line">                dist[j] = dist[t]+d</span><br><span class="line">                heapq.heappush(prioqueue,(dist[j],j))</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">-1</span>] <span class="keyword">if</span> dist[<span class="number">-1</span>]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(dijkstra(adj))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="Bellman-Ford算法-有权图的单源最短路，判断负环，在边数限制的情况下求最长路-gt-支持存在负权重的情况，但如果存在负环，则最短路失效"><a href="#Bellman-Ford算法-有权图的单源最短路，判断负环，在边数限制的情况下求最长路-gt-支持存在负权重的情况，但如果存在负环，则最短路失效" class="headerlink" title="Bellman-Ford算法(有权图的单源最短路，判断负环，在边数限制的情况下求最长路)==&gt;支持存在负权重的情况，但如果存在负环，则最短路失效"></a>Bellman-Ford算法(有权图的单源最短路，判断负环，在边数限制的情况下求最长路)==&gt;支持存在负权重的情况，但如果存在负环，则最短路失效</h3><p><strong>时间复杂度为O(nm)</strong></p>
<p>贝尔曼-福特算法每次对所有的边进行松弛，每次松弛都会得到一条最短路径，所以总共需要要做的松弛操作是V - 1次。在完成这么多次松弛后如果还是可以松弛的话，那么就意味着，其中包含负环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m = map(int,input().split())</span><br><span class="line">edges = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z = map(int,input().split())</span><br><span class="line">    edges.append([x<span class="number">-1</span>,y<span class="number">-1</span>,z])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span><span class="params">(edges,n,m)</span>:</span> <span class="comment"># edges中直接表示(x,y,z)即表示x-&gt;y的边的权重为z</span></span><br><span class="line">    dist = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            a,b,w = edges[j]</span><br><span class="line">            <span class="keyword">if</span> dist[b]&gt;dist[a]+w:</span><br><span class="line">                dist[b] = dist[a]+w</span><br><span class="line">    <span class="comment"># 执行n-1次迭代之后判断是否存在负环</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        a,b,w = edges[j]</span><br><span class="line">        <span class="keyword">if</span> dist[b]&gt;dist[a]+w:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"存在负环"</span></span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">-1</span>] <span class="keyword">if</span> dist[<span class="number">-1</span>]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">print(bellman_ford(edges,n,m))</span><br></pre></td></tr></table></figure>



<h3 id="SPFA算法-队列优化的Bellman-Ford算法"><a href="#SPFA算法-队列优化的Bellman-Ford算法" class="headerlink" title="SPFA算法(队列优化的Bellman-Ford算法)"></a>SPFA算法(队列优化的Bellman-Ford算法)</h3><p><strong>平均时间复杂度为O(m)，最坏时间复杂度为O(nm)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m = map(int,input().split())</span><br><span class="line">adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z = map(int,input().split())</span><br><span class="line">    adj[x<span class="number">-1</span>].append((z,y<span class="number">-1</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spfa</span><span class="params">(adj)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    n = len(adj)</span><br><span class="line">    dist = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 记录是否在队列中</span></span><br><span class="line">    visited[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    queue = deque([<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        t = queue.popleft()</span><br><span class="line">        visited[t] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d,j <span class="keyword">in</span> adj[t]:</span><br><span class="line">            <span class="keyword">if</span> dist[j]&gt;dist[t]+d:</span><br><span class="line">                dist[j] = dist[t]+d</span><br><span class="line">                <span class="keyword">if</span> visited[j]==<span class="number">0</span>: <span class="comment"># 如果队列中已经存在j，则不需要重复插入</span></span><br><span class="line">                    queue.append(j)</span><br><span class="line">                    visited[j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">-1</span>] <span class="keyword">if</span> dist[<span class="number">-1</span>]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(spfa(adj))</span><br></pre></td></tr></table></figure>

<p><strong>spfa算法判断负环(时间复杂度为O(nm))</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m = map(int,input().split())</span><br><span class="line">adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z = map(int,input().split())</span><br><span class="line">    adj[x<span class="number">-1</span>].append((z,y<span class="number">-1</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果存在负环，则返回true，否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spfa</span><span class="params">(adj)</span>:</span></span><br><span class="line">    <span class="comment"># 如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    n = len(adj)</span><br><span class="line">    dist = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离</span></span><br><span class="line">    cnt = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离的点数</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 记录是否在队列中</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        queue.append(i)</span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        t = queue.popleft()</span><br><span class="line">        visited[t] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d,j <span class="keyword">in</span> adj[t]:</span><br><span class="line">            <span class="keyword">if</span> dist[j]&gt;dist[t]+d:</span><br><span class="line">                dist[j] = dist[t]+d</span><br><span class="line">                cnt[j] = cnt[t]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt[j]&gt;=n: <span class="comment"># 包含的路径长度(不包含自身)&gt;=n，则有环</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> visited[j]==<span class="number">0</span>: <span class="comment"># 如果队列中已经存在j，则不需要重复插入</span></span><br><span class="line">                    queue.append(j)</span><br><span class="line">                    visited[j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">print(spfa(adj))</span><br></pre></td></tr></table></figure>



<h3 id="Floyd算法-有权图的多源最短路"><a href="#Floyd算法-有权图的多源最短路" class="headerlink" title="Floyd算法(有权图的多源最短路)"></a>Floyd算法(有权图的多源最短路)</h3><p><strong>时间复杂度为O(n^3)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n,m = map(int,input().split())</span><br><span class="line">graph = [[float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">    x,y,z = map(int,input().split())</span><br><span class="line">    graph[x<span class="number">-1</span>][y<span class="number">-1</span>] = min(graph[x<span class="number">-1</span>][y<span class="number">-1</span>],z)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd</span><span class="params">(graph)</span>:</span></span><br><span class="line">    n = len(graph)</span><br><span class="line">    dist = graph <span class="comment">#dist[i][j]表示i到j的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dist[i][i] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dist[i][j] = min(dist[i][j],dist[i][k]+dist[k][j])</span><br><span class="line">    <span class="keyword">return</span> dist[<span class="number">0</span>][<span class="number">-1</span>] <span class="keyword">if</span> dist[<span class="number">0</span>][<span class="number">-1</span>]!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(floyd(graph))</span><br></pre></td></tr></table></figure>





<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h3 id="prim算法-加点法"><a href="#prim算法-加点法" class="headerlink" title="prim算法(加点法)"></a>prim算法(加点法)</h3><p><strong>朴素prime算法，时间复杂度为O(n\</strong>2+m)**</p>
<p><strong>将所有节点划分为两类：selected_node和candidate_node</strong></p>
<ul>
<li>任取一节点加入selected_node，遍历头结点在selected_node，尾节点在candidate_node的边，选取符合条件的权重最小的边，加入最小生成树；</li>
<li>将边的尾节点加入selected_node中，并在candidate_node中删除，直至candidate_node中无节点。循环条件为：所有节点都有边连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果图不连通，则返回-1, 否则返回最小生成树的树边权重之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span><span class="params">(graph)</span>:</span></span><br><span class="line">    n = len(graph)</span><br><span class="line">    dist = [float(<span class="string">'inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 0号点到每个点的最短距离</span></span><br><span class="line">    visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="comment"># 记录是否已经被访问</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        t = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> visited[j]==<span class="number">0</span> <span class="keyword">and</span> (t==<span class="number">-1</span> <span class="keyword">or</span> dist[t]&gt;dist[j]):</span><br><span class="line">                t = j</span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> dist[t]==float(<span class="string">'inf'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            res += dist[t]</span><br><span class="line">        visited[t] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dist[j] = min(dist[j],graph[t][j])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="kruskal算法-避圈法"><a href="#kruskal算法-避圈法" class="headerlink" title="kruskal算法(避圈法)"></a>kruskal算法(避圈法)</h3><p><strong>时间复杂度是 O(mlogm)</strong></p>
<p>按照边的从小到大取边，并入边的两个节点，在这个过程中保证并入边后不构成圈，因此也称避圈法。<br>算法过程：<br>1）先对边按权重从小到大排序；<br>2）取权重最小的一条边，若该边两个节点均为不同分量，则加入最小生成树；<br>3）以此类推，直至遍历完所有的边。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h5 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162. 地图分析"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXMtZmFyLWZyb20tbGFuZC1hcy1wb3NzaWJsZS8=" title="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">1162. 地图分析<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxDistance(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        # if all(grid) or any(grid):</span><br><span class="line">        #     return -1</span><br><span class="line">        n = len(grid)</span><br><span class="line">        from collections import deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if grid[i][j] == 1:</span><br><span class="line">                    queue.append((i,j,0))</span><br><span class="line">        if len(queue)==0 or len(queue)==n*n:</span><br><span class="line">            return -1</span><br><span class="line">        while queue:</span><br><span class="line">            for _ in range(len(queue)):</span><br><span class="line">                i,j,depth = queue.popleft()</span><br><span class="line">                for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span><br><span class="line">                    if x&gt;=0 and y&gt;=0 and x&lt;n and y&lt;n and grid[x][y]==0:</span><br><span class="line">                        grid[x][y] = -1</span><br><span class="line">                        queue.append((x,y,depth+1))</span><br><span class="line">        return depth</span><br></pre></td></tr></table></figure>





<h1 id="矩阵搜索-dfs-bfs-并查集"><a href="#矩阵搜索-dfs-bfs-并查集" class="headerlink" title="矩阵搜索(dfs/bfs/并查集)"></a>矩阵搜索(dfs/bfs/并查集)</h1><p>并查集：常用来查找图连通分量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self,n):</span><br><span class="line">        &quot;&quot;&quot;初始化并查集&quot;&quot;&quot;</span><br><span class="line">        #i=n为设置的特殊结点</span><br><span class="line">        self.parent = [i for i in range(n)] #即每个结点i的根结点初始时为i，即独立的,</span><br><span class="line">        self.rank = [0 for i in range(n)] #即每个结点合并的次数，可以理解为树的深度</span><br><span class="line">        self.size = [1 for i in range(n)] #即为每个结点为跟结点时的集合中的结点数</span><br><span class="line">        self.count = n #即团/连通分量的个数</span><br><span class="line">    </span><br><span class="line">    # #当要保存的结点稀疏的时候，改用字典保存     </span><br><span class="line">    # def __init__(self,nums):</span><br><span class="line">    #     self.parent = &#123;num:num for num in nums&#125;</span><br><span class="line">    #     self.rank = collections.defaultdict(lambda:1)</span><br><span class="line">    #     self.size = collections.defaultdict(lambda:1)</span><br><span class="line">        </span><br><span class="line">    def find(self,p):</span><br><span class="line">        &quot;&quot;&quot;找到p结点的根结点&quot;&quot;&quot;</span><br><span class="line">        # 当不为自身时，尾递归找根结点，即所有结点直接指向根结点</span><br><span class="line">        if self.parent[p]!=p:</span><br><span class="line">            self.parent[p] = self.find(self.parent[p])</span><br><span class="line">        return self.parent[p]</span><br><span class="line">    </span><br><span class="line">    def union(self,p,q):</span><br><span class="line">        &quot;&quot;&quot;将p结点和q结点合并&quot;&quot;&quot;</span><br><span class="line">        pr,qr = self.find(p),self.find(q) # 找到各自的根结点</span><br><span class="line">        if pr==qr:</span><br><span class="line">            return</span><br><span class="line">        # 当pr的深度/合并次数小于qr时，交换，即确保qr的&lt;=pr的</span><br><span class="line">        if self.rank[pr]&lt;self.rank[qr]:</span><br><span class="line">            pr,qr = qr,pr</span><br><span class="line">        if self.rank[pr]==self.rank[qr]:</span><br><span class="line">            self.rank[pr] += 1 #相同时才深度+1，否则还是为最大深度</span><br><span class="line">            </span><br><span class="line">        self.parent[qr] = pr # 将qr合并到pr处</span><br><span class="line">        self.size[pr] += self.size[qr] #合并后pr的集合大小增加</span><br><span class="line">        self.count -= 1 # 每次union意味着连通分量减少了一个</span><br><span class="line">        # union之后，路径压缩就失效了 eg: 1-&gt;2 4-&gt;3 ==&gt; 2&lt;-1-&gt;4-&gt;3</span><br><span class="line">        # 需要重新对小的qr的子结点更新，将其指向pr</span><br><span class="line">        # for k,v in self.parent.items():</span><br><span class="line">        #     if v==qr:</span><br><span class="line">        #         self.parent[k] = pr</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    def is_connect(self,p,q):</span><br><span class="line">        &quot;&quot;&quot;判断是否相连&quot;&quot;&quot;</span><br><span class="line">        return self.find(p)==self.find(q)</span><br></pre></td></tr></table></figure>

<h5 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd29yZC1zZWFyY2gv" title="https://leetcode-cn.com/problems/word-search/">79. 单词搜索<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def exist(self, board: List[List[str]], word: str) -&gt; bool:</span><br><span class="line">        def dfs(i,j,word,count):</span><br><span class="line">            if count==len(word):</span><br><span class="line">                return True</span><br><span class="line">            if board[i][j]==1:</span><br><span class="line">                return False</span><br><span class="line">            # 标记为1则代表已经遍历过</span><br><span class="line">            val = board[i][j]</span><br><span class="line">            board[i][j] = 1</span><br><span class="line">            for (x,y) in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span><br><span class="line">                if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and board[x][y]==word[count]:</span><br><span class="line">                    if dfs(x,y,word,count+1):</span><br><span class="line">                        return True</span><br><span class="line">            board[i][j] = val</span><br><span class="line">            return False</span><br><span class="line">        m,n = len(board),len(board[0])</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if board[i][j]==word[0]:</span><br><span class="line">                    if dfs(i,j,word,1):</span><br><span class="line">                        return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<h5 id="547-朋友圈"><a href="#547-朋友圈" class="headerlink" title="547. 朋友圈"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZnJpZW5kLWNpcmNsZXMv" title="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findCircleNum(self, M: List[List[int]]) -&gt; int:</span><br><span class="line">        # 并查集</span><br><span class="line">        class UnionFind:</span><br><span class="line">            def __init__(self,n):</span><br><span class="line">                self.parent = [i for i in range(n)]</span><br><span class="line">                self.rank = [0 for _ in range(n)]</span><br><span class="line">                self.size = [1 for _ in range(n)]</span><br><span class="line">                self.count = n</span><br><span class="line"></span><br><span class="line">            def find(self,p):</span><br><span class="line">                if self.parent[p]!=p:</span><br><span class="line">                    self.parent[p] = self.find(self.parent[p])</span><br><span class="line">                return self.parent[p]</span><br><span class="line"></span><br><span class="line">            def union(self,p,q):</span><br><span class="line">                proot,qroot = self.find(p),self.find(q)</span><br><span class="line">                if proot==qroot:</span><br><span class="line">                    return</span><br><span class="line">                if self.rank[proot]&lt;self.rank[qroot]:</span><br><span class="line">                    proot,qroot = qroot,proot</span><br><span class="line">                if self.rank[proot]==self.rank[qroot]:</span><br><span class="line">                    self.rank[proot] += 1</span><br><span class="line">                self.parent[qroot] = proot</span><br><span class="line">                self.size[proot] += self.size[qroot]</span><br><span class="line">                self.count -= 1</span><br><span class="line">            </span><br><span class="line">        m = len(M)</span><br><span class="line">        uf = UnionFind(m)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(i+1,m):</span><br><span class="line">                if M[i][j]==1:</span><br><span class="line">                    uf.union(i,j)</span><br><span class="line">        return uf.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # dfs 每次将一个结点和其它与其相连的结点标记</span><br><span class="line">        # def dfs(i):</span><br><span class="line">        #     visited[i] = 1</span><br><span class="line">        #     for j in range(m):</span><br><span class="line">        #         if M[i][j]==1 and visited[j]==0:</span><br><span class="line">        #             dfs(j)</span><br><span class="line">        # m = len(M)</span><br><span class="line">        # visited = [0 for _ in range(m)]</span><br><span class="line">        # res = 0</span><br><span class="line">        # for i in range(m):</span><br><span class="line">        #     if visited[i]==0:</span><br><span class="line">        #         dfs(i)</span><br><span class="line">        #         res += 1</span><br><span class="line">        # return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # bfs</span><br><span class="line">        # def bfs(i):</span><br><span class="line">        #     queue = deque([i])</span><br><span class="line">        #     while queue:</span><br><span class="line">        #         i = queue.popleft()</span><br><span class="line">        #         for j in range(m):</span><br><span class="line">        #             if M[i][j]==1 and visited[j]==0:</span><br><span class="line">        #                 queue.append(j)</span><br><span class="line">        #                 visited[j] = 1</span><br><span class="line">        # from collections import deque</span><br><span class="line">        # m = len(M)</span><br><span class="line">        # visited = [0 for _ in range(m)]</span><br><span class="line">        # res = 0</span><br><span class="line">        # for i in range(m):</span><br><span class="line">        #     if visited[i]==0:</span><br><span class="line">        #         visited[i] = 1</span><br><span class="line">        #         bfs(i)</span><br><span class="line">        #         res += 1</span><br><span class="line">        # return res</span><br></pre></td></tr></table></figure>

<h5 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWlzbGFuZHMv" title="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numIslands(self, grid: List[List[str]]) -&gt; int:</span><br><span class="line">        # unionfind</span><br><span class="line">        class UnionFind:</span><br><span class="line">            def __init__(self,n):</span><br><span class="line">                # 多建一个结点n,与所有水域相连</span><br><span class="line">                self.parent = [i for i in range(n+1)]</span><br><span class="line">                # self.rank = [1 for _ in range(n+1)]</span><br><span class="line">                self.count = n #不包括n那个点</span><br><span class="line">            </span><br><span class="line">            def find(self,p):</span><br><span class="line">                if self.parent[p]!=p:</span><br><span class="line">                    self.parent[p] = self.find(self.parent[p])</span><br><span class="line">                return self.parent[p]</span><br><span class="line"></span><br><span class="line">            def union(self,p,q):</span><br><span class="line">                pr,qr = self.find(p),self.find(q)</span><br><span class="line">                if pr==qr:</span><br><span class="line">                    return</span><br><span class="line">                # if self.rank[pr]&lt;self.rank[qr]:</span><br><span class="line">                #     pr,qr = qr,pr</span><br><span class="line">                # if self.rank[pr]==self.rank[qr]:</span><br><span class="line">                #     self.rank[pr] += 1</span><br><span class="line">                self.parent[qr] = pr</span><br><span class="line">                self.count -= 1</span><br><span class="line"></span><br><span class="line">        if not grid:</span><br><span class="line">            return 0</span><br><span class="line">        m,n = len(grid),len(grid[0])</span><br><span class="line">        uf = UnionFind(m*n)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if grid[i][j]==&apos;0&apos;:</span><br><span class="line">                    uf.union(i*n+j,m*n)</span><br><span class="line">                else:</span><br><span class="line">                    # for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span><br><span class="line">                    for x,y in [(i+1,j),(i,j+1)]:</span><br><span class="line">                        if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and grid[x][y]==&apos;1&apos;:</span><br><span class="line">                            uf.union(x*n+y,i*n+j)</span><br><span class="line">        return uf.count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # dfs 每次将一个团的所有1全部标记</span><br><span class="line">        # def dfs(i,j):</span><br><span class="line">        #     grid[i][j] = &apos;o&apos; #表示已经访问</span><br><span class="line">        #     for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span><br><span class="line">        #         if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and grid[x][y]==&apos;1&apos;:</span><br><span class="line">        #             dfs(x,y)</span><br><span class="line">        # if not grid:</span><br><span class="line">        #     return 0</span><br><span class="line">        # m,n = len(grid),len(grid[0])</span><br><span class="line">        # res = 0</span><br><span class="line">        # for i in range(m):</span><br><span class="line">        #     for j in range(n):</span><br><span class="line">        #         if grid[i][j]==&apos;1&apos;:</span><br><span class="line">        #             dfs(i,j)</span><br><span class="line">        #             res += 1</span><br><span class="line">        # return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # bfs 将一个团的所有1全部标记</span><br><span class="line">        # def bfs(i,j):</span><br><span class="line">        #     queue = deque([(i,j)])</span><br><span class="line">        #     while queue:</span><br><span class="line">        #         i,j = queue.popleft()</span><br><span class="line">        #         for x,y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span><br><span class="line">        #             if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and grid[x][y]==&apos;1&apos;:</span><br><span class="line">        #                 queue.append((x,y))</span><br><span class="line">        #                 grid[x][y] = &apos;o&apos;</span><br><span class="line">        # if not grid:</span><br><span class="line">        #     return 0</span><br><span class="line">        # m,n = len(grid),len(grid[0])</span><br><span class="line">        # from collections import deque</span><br><span class="line">        # res = 0</span><br><span class="line">        # for i in range(m):</span><br><span class="line">        #     for j in range(n):</span><br><span class="line">        #         if grid[i][j]==&apos;1&apos;:</span><br><span class="line">        #             grid[i][j] = &apos;o&apos;</span><br><span class="line">        #             bfs(i,j)</span><br><span class="line">        #             res += 1</span><br><span class="line">        # return res</span><br></pre></td></tr></table></figure>

<h5 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vycm91bmRlZC1yZWdpb25zLw==" title="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def solve(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify board in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        class UnionFind:</span><br><span class="line">            def __init__(self,n):</span><br><span class="line">                # 多建一个n,表示边界上的O</span><br><span class="line">                self.parent = [i for i in range(n+1)]</span><br><span class="line">                self.rank = [0 for _ in range(n+1)]</span><br><span class="line"></span><br><span class="line">            def find(self,p):</span><br><span class="line">                if self.parent[p]!=p:</span><br><span class="line">                    self.parent[p] = self.find(self.parent[p])</span><br><span class="line">                return self.parent[p]</span><br><span class="line"></span><br><span class="line">            def union(self,p,q):</span><br><span class="line">                pr,qr = self.find(p),self.find(q)</span><br><span class="line">                if pr==qr:</span><br><span class="line">                    return</span><br><span class="line">                if self.rank[pr]&lt;self.rank[qr]:</span><br><span class="line">                    pr,qr = qr,pr</span><br><span class="line">                if self.rank[pr]==self.rank[qr]:</span><br><span class="line">                    self.rank[pr] += 1</span><br><span class="line">                self.parent[qr] = pr</span><br><span class="line"></span><br><span class="line">            def is_connect(self,p,q):</span><br><span class="line">                return self.find(p)==self.find(q)</span><br><span class="line"></span><br><span class="line">        if not board: return </span><br><span class="line">        m,n = len(board),len(board[0])</span><br><span class="line">        uf = UnionFind(m*n)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if board[i][j]==&apos;O&apos;:</span><br><span class="line">                    if (i==0 or i==m-1 or j==0 or j==n-1):</span><br><span class="line">                        uf.union(i*n+j,m*n)</span><br><span class="line">                    else:</span><br><span class="line">                        # 中间部分的O</span><br><span class="line">                        for (x,y) in [(i,j-1),(i,j+1),(i-1,j),(i+1,j)]:</span><br><span class="line">                            if board[x][y]==&apos;O&apos;:</span><br><span class="line">                                uf.union(i*n+j,x*n+y)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if board[i][j]==&apos;O&apos;:</span><br><span class="line">                    if not uf.is_connect(i*n+j,m*n):</span><br><span class="line">                        board[i][j] = &apos;X&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # dfs 相当于找连通区域</span><br><span class="line">        # def dfs(i,j):</span><br><span class="line">        #     board[i][j] = &apos;#&apos;</span><br><span class="line">        #     for (x,y) in [(i,j-1),(i,j+1),(i-1,j),(i+1,j)]:</span><br><span class="line">        #         if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and board[x][y]==&apos;O&apos;:</span><br><span class="line">        #             dfs(x,y)</span><br><span class="line">        # if not board: return </span><br><span class="line">        # m,n = len(board),len(board[0])</span><br><span class="line">        # # 第一行/最后一行</span><br><span class="line">        # for i in [0,m-1]:</span><br><span class="line">        #     for j in range(n):</span><br><span class="line">        #         if board[i][j]==&apos;O&apos;:</span><br><span class="line">        #             dfs(i,j)</span><br><span class="line">        # # 第一列/最后一列</span><br><span class="line">        # for j in [0,n-1]:</span><br><span class="line">        #     for i in range(m):</span><br><span class="line">        #         if board[i][j]==&apos;O&apos;:</span><br><span class="line">        #             dfs(i,j)</span><br><span class="line">        # for i in range(m):</span><br><span class="line">        #     for j in range(n):</span><br><span class="line">        #         if board[i][j]==&apos;O&apos;:</span><br><span class="line">        #             board[i][j] = &apos;X&apos;</span><br><span class="line">        #         elif board[i][j]==&apos;#&apos;:</span><br><span class="line">        #             board[i][j] = &apos;O&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # bfs</span><br><span class="line">        # def bfs(i,j):</span><br><span class="line">        #     queue = deque([(i,j)])</span><br><span class="line">        #     board[i][j] = &apos;#&apos;</span><br><span class="line">        #     while queue:</span><br><span class="line">        #         i,j = queue.popleft()</span><br><span class="line">        #         for (x,y) in [(i,j-1),(i,j+1),(i-1,j),(i+1,j)]:</span><br><span class="line">        #             if x&gt;=0 and y&gt;=0 and x&lt;m and y&lt;n and board[x][y]==&apos;O&apos;:</span><br><span class="line">        #                 queue.append((x,y))</span><br><span class="line">        #                 board[x][y] = &apos;#&apos;</span><br><span class="line">        # if not board: return</span><br><span class="line">        # m,n = len(board),len(board[0])</span><br><span class="line">        # for i in [0,m-1]:</span><br><span class="line">        #     for j in range(n):</span><br><span class="line">        #         if board[i][j]==&apos;O&apos;:</span><br><span class="line">        #             bfs(i,j)</span><br><span class="line">        # for j in [0,n-1]:</span><br><span class="line">        #     for i in range(m):</span><br><span class="line">        #         if board[i][j]==&apos;O&apos;:</span><br><span class="line">        #             bfs(i,j)</span><br><span class="line">        # for i in range(m):</span><br><span class="line">        #     for j in range(n):</span><br><span class="line">        #         if board[i][j]==&apos;O&apos;:</span><br><span class="line">        #             board[i][j] = &apos;X&apos;</span><br><span class="line">        #         elif board[i][j]==&apos;#&apos;:</span><br><span class="line">        #             board[i][j] = &apos;O&apos;</span><br></pre></td></tr></table></figure>

<h5 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb25zZWN1dGl2ZS1zZXF1ZW5jZS8=" title="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestConsecutive(self, nums: List[int]) -&gt; int:</span><br><span class="line">        # # 排序 O(nlogn)</span><br><span class="line">        # if not nums:</span><br><span class="line">        #     return 0</span><br><span class="line">        # nums.sort()</span><br><span class="line">        # res = 1</span><br><span class="line">        # temp = 1</span><br><span class="line">        # for i in range(len(nums)-1):</span><br><span class="line">        #     # 相等时则跳过</span><br><span class="line">        #     if nums[i]==nums[i+1]:</span><br><span class="line">        #         continue</span><br><span class="line">        #     # 满足连续时更新，否则返回初值</span><br><span class="line">        #     if nums[i]+1==nums[i+1]:</span><br><span class="line">        #         temp += 1</span><br><span class="line">        #     else:</span><br><span class="line">        #         res = max(res,temp)</span><br><span class="line">        #         temp = 1</span><br><span class="line">        # return max(res,temp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # # hash O(n)</span><br><span class="line">        # if not nums:</span><br><span class="line">        #     return 0</span><br><span class="line">        # nums = set(nums)</span><br><span class="line">        # res = 1</span><br><span class="line">        # for num in nums:</span><br><span class="line">        #     # 如果存在则肯定更长，所以当前可以跳过</span><br><span class="line">        #     if num-1 in nums:</span><br><span class="line">        #         continue</span><br><span class="line">        #     temp = 1</span><br><span class="line">        #     while num+1 in nums:</span><br><span class="line">        #         temp += 1</span><br><span class="line">        #         num += 1</span><br><span class="line">        #     res = max(res,temp)</span><br><span class="line">        # return res</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        # # hash</span><br><span class="line">        # from collections import defaultdict</span><br><span class="line">        # dics = defaultdict(lambda:0)</span><br><span class="line">        # res = 0</span><br><span class="line">        # for i in nums:</span><br><span class="line">        #     if dics[i]==0:</span><br><span class="line">        #         dics[i] = dics[i-1]+dics[i+1]+1</span><br><span class="line">        #         # 头尾设置新的最大长度</span><br><span class="line">        #         dics[i-dics[i-1]] = dics[i]</span><br><span class="line">        #         dics[i+dics[i+1]] = dics[i]</span><br><span class="line">        #         res = max(res,dics[i])</span><br><span class="line">        # return res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # UnionFind</span><br><span class="line">        class UnionFind:</span><br><span class="line">            def __init__(self,nums):</span><br><span class="line">                self.parent = &#123;num:num for num in nums&#125;</span><br><span class="line">                self.rank = collections.defaultdict(lambda:1)</span><br><span class="line">                self.size = collections.defaultdict(lambda:1)</span><br><span class="line"></span><br><span class="line">            def find(self,p):</span><br><span class="line">                if self.parent[p]!=p:</span><br><span class="line">                    self.parent[p] = self.find(self.parent[p])</span><br><span class="line">                return self.parent[p]</span><br><span class="line"></span><br><span class="line">            def union(self,p,q):</span><br><span class="line">                pr,qr = self.find(p),self.find(q)</span><br><span class="line">                if pr==qr:</span><br><span class="line">                    return</span><br><span class="line">                if self.rank[pr]&lt;self.rank[qr]:</span><br><span class="line">                    pr,qr = qr,pr</span><br><span class="line">                if self.rank[pr]==self.rank[qr]:</span><br><span class="line">                    self.rank[pr] += 1</span><br><span class="line">                self.parent[qr] = self.parent[pr]</span><br><span class="line">                self.size[pr] += self.size[qr]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        uf = UnionFind(nums)</span><br><span class="line">        flag = 1</span><br><span class="line">        for num in nums:</span><br><span class="line">            if num+1 in uf.parent:</span><br><span class="line">                flag = 0</span><br><span class="line">                uf.union(num,num+1)</span><br><span class="line">        # 若flag==1,说明没有执行union，否则取最大的size</span><br><span class="line">        return 1 if flag==1 else max(uf.size.values())</span><br></pre></td></tr></table></figure>

<h5 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4LWFyZWEtb2YtaXNsYW5kLw==" title="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # dfs</span></span><br><span class="line">        <span class="comment"># if not grid: return 0</span></span><br><span class="line">        <span class="comment"># m,n = len(grid),len(grid[0])</span></span><br><span class="line">        <span class="comment"># def helper(i,j):</span></span><br><span class="line">        <span class="comment">#     count = 1</span></span><br><span class="line">        <span class="comment">#     for (x,y) in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:</span></span><br><span class="line">        <span class="comment">#         if x&gt;=0 and x&lt;m and y&gt;=0 and y&lt;n and grid[x][y]:</span></span><br><span class="line">        <span class="comment">#             grid[x][y] = 0</span></span><br><span class="line">        <span class="comment">#             count += helper(x,y)</span></span><br><span class="line">        <span class="comment">#     return count</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># for i in range(m):</span></span><br><span class="line">        <span class="comment">#     for j in range(n):</span></span><br><span class="line">        <span class="comment">#         if grid[i][j]==1:</span></span><br><span class="line">        <span class="comment">#             grid[i][j] = 0</span></span><br><span class="line">        <span class="comment">#             res = max(res,helper(i,j))</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            queue = deque([(i,j)])</span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                i,j = queue.popleft()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i<span class="number">-1</span>,j),(i+<span class="number">1</span>,j),(i,j<span class="number">-1</span>),(i,j+<span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> x&gt;=<span class="number">0</span> <span class="keyword">and</span> x&lt;m <span class="keyword">and</span> y&gt;=<span class="number">0</span> <span class="keyword">and</span> y&lt;n <span class="keyword">and</span> grid[x][y]:</span><br><span class="line">                        grid[x][y] = <span class="number">0</span></span><br><span class="line">                        queue.append((x,y))</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    res = max(res,helper(i,j))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>主要应用在有向图(判断是否有环)</p>
<p>dfs解法：</p>
<ul>
<li><p>从每一个结点开始，由深度优先搜索：</p>
<p>每次经过一个结点，则将该结点的状态置为1；若在遍历的过程中再次经过到达这个结点，则说明有环；若没有，则将该结点状态置为-1，表示已访问且无环</p>
</li>
</ul>
<p>bfs解法：</p>
<ul>
<li>选择一个入度为0的顶点并输出；</li>
<li>从网中删除此顶点及所有出边</li>
<li>重复上述步骤，若循环结束时输出的顶点数小于网中的顶点数，则说明有环</li>
</ul>
<h5 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLw==" title="https://leetcode-cn.com/problems/course-schedule/">207. 课程表<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        edges = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)] <span class="comment"># 出边</span></span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">            edges[j].append(i)</span><br><span class="line">        visited = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="comment"># dfs</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            <span class="comment"># 上一轮访问过，则认为为真</span></span><br><span class="line">            <span class="keyword">if</span> visited[i]==<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 当前轮再次被访问，则有环，认为为假</span></span><br><span class="line">            <span class="keyword">if</span> visited[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            visited[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> edges[i]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(j):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            visited[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> visited[i]==<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># degree = [0 for _ in range(numCourses)] # 入度</span></span><br><span class="line">        <span class="comment"># edges = [[] for _ in range(numCourses)] # 出边</span></span><br><span class="line">        <span class="comment"># for i,j in prerequisites:</span></span><br><span class="line">        <span class="comment">#     degree[i] += 1</span></span><br><span class="line">        <span class="comment">#     edges[j].append(i)</span></span><br><span class="line">        <span class="comment"># # bfs</span></span><br><span class="line">        <span class="comment"># from collections import deque</span></span><br><span class="line">        <span class="comment"># queue = deque()</span></span><br><span class="line">        <span class="comment"># for i in range(numCourses):</span></span><br><span class="line">        <span class="comment">#     if degree[i]==0:</span></span><br><span class="line">        <span class="comment">#         queue.append(i)</span></span><br><span class="line">        <span class="comment"># learned = [] # 保存学过的课程,只有先修课程学完才能保存</span></span><br><span class="line">        <span class="comment"># while queue:</span></span><br><span class="line">        <span class="comment">#     i = queue.popleft()</span></span><br><span class="line">        <span class="comment">#     learned.append(i)</span></span><br><span class="line">        <span class="comment">#     for j in edges[i]:</span></span><br><span class="line">        <span class="comment">#         degree[j] -= 1</span></span><br><span class="line">        <span class="comment">#         # 先修课程学完再加入</span></span><br><span class="line">        <span class="comment">#         if degree[j]==0:</span></span><br><span class="line">        <span class="comment">#             queue.append(j)</span></span><br><span class="line">        <span class="comment"># return len(learned)==numCourses</span></span><br></pre></td></tr></table></figure>

<h5 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLWlpLw==" title="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self,numCourses:int,prerequisites:List[List[int]])</span>-&gt;List[int]:</span></span><br><span class="line">        <span class="comment"># # 保存每个结点的出边结点</span></span><br><span class="line">        <span class="comment"># adj = [[] for _ in range(numCourses)]</span></span><br><span class="line">        <span class="comment"># for i,j in prerequisites:</span></span><br><span class="line">        <span class="comment">#     adj[j].append(i)</span></span><br><span class="line">        <span class="comment"># # 记录每个结点的状态，0未访问，1当前轮遍历时被访问，-1之前轮被访问</span></span><br><span class="line">        <span class="comment"># visited = [0 for _ in range(numCourses)]</span></span><br><span class="line">        <span class="comment"># def dfs(i,learned):</span></span><br><span class="line">        <span class="comment">#     # 之前已被访问，且无环</span></span><br><span class="line">        <span class="comment">#     if visited[i]==-1:</span></span><br><span class="line">        <span class="comment">#         return True</span></span><br><span class="line">        <span class="comment">#     # 当前轮再次被访问，说明有环</span></span><br><span class="line">        <span class="comment">#     if visited[i]==1:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment">#     visited[i] = 1</span></span><br><span class="line">        <span class="comment">#     if adj[i]:</span></span><br><span class="line">        <span class="comment">#         for j in adj[i]:</span></span><br><span class="line">        <span class="comment">#             # 如果子结点发现有环</span></span><br><span class="line">        <span class="comment">#             if not dfs(j,learned):</span></span><br><span class="line">        <span class="comment">#                 return False</span></span><br><span class="line">        <span class="comment">#     learned.append(i)</span></span><br><span class="line">        <span class="comment">#     visited[i] = -1</span></span><br><span class="line">        <span class="comment">#     return True</span></span><br><span class="line">        <span class="comment"># # 对每个结点</span></span><br><span class="line">        <span class="comment"># learned = []</span></span><br><span class="line">        <span class="comment"># for i in range(numCourses):</span></span><br><span class="line">        <span class="comment">#     # 若发现有环，则直接返回[]</span></span><br><span class="line">        <span class="comment">#     if not dfs(i,learned):</span></span><br><span class="line">        <span class="comment">#         return []</span></span><br><span class="line">        <span class="comment"># return learned[::-1] #反序(因为dfs先加入的是叶结点)</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算每个结点的入度</span></span><br><span class="line">        degree = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="comment"># 保存每个结点的出边结点</span></span><br><span class="line">        adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> prerequisites:</span><br><span class="line">            degree[i] += <span class="number">1</span></span><br><span class="line">            adj[j].append(i)</span><br><span class="line">        <span class="comment"># queue</span></span><br><span class="line">        <span class="keyword">from</span> collections imprt deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 将入度为0的结点作为起始点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> degree[i]==<span class="number">0</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="comment"># 记录已选的课程</span></span><br><span class="line">        learned = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            lens = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(lens):</span><br><span class="line">                i = queue.popleft()</span><br><span class="line">                learned.append(i)</span><br><span class="line">                <span class="comment"># 若存在出边</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> adj[i]:</span><br><span class="line">                    degree[j] -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> degree[j]==<span class="number">0</span>:</span><br><span class="line">                        queue.append(j)</span><br><span class="line">        <span class="keyword">return</span> learned <span class="keyword">if</span> len(learned)==numCourses <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>

<h5 id="630-课程表-III"><a href="#630-课程表-III" class="headerlink" title="630. 课程表 III"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLWlpaS8=" title="https://leetcode-cn.com/problems/course-schedule-iii/">630. 课程表 III<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduleCourse</span><span class="params">(self, courses: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="comment"># 按照结束时间排序</span></span><br><span class="line">        courses.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        learned = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> t,d <span class="keyword">in</span> courses:</span><br><span class="line">            <span class="comment"># 当选择的课程超过结束时间，则把之前最耗时的课程取消，否则直接加入</span></span><br><span class="line">            <span class="keyword">if</span> cur+t&lt;=d:</span><br><span class="line">                cur += t</span><br><span class="line">                heapq.heappush(learned,-t)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> learned <span class="keyword">and</span> -learned[<span class="number">0</span>]&gt;t:</span><br><span class="line">                    cur += learned[<span class="number">0</span>] + t</span><br><span class="line">                    heapq.heapreplace(learned,-t)</span><br><span class="line">        <span class="keyword">return</span> len(learned)</span><br></pre></td></tr></table></figure>

<h5 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1oZWlnaHQtdHJlZXMv" title="https://leetcode-cn.com/problems/minimum-height-trees/">310. 最小高度树<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># # 暴力解法 超时</span></span><br><span class="line">        <span class="comment"># adj = [[] for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># for i,j in edges:</span></span><br><span class="line">        <span class="comment">#     adj[i].append(j)</span></span><br><span class="line">        <span class="comment">#     adj[j].append(i)</span></span><br><span class="line">        <span class="comment"># from collections import deque</span></span><br><span class="line">        <span class="comment"># def helper(i):</span></span><br><span class="line">        <span class="comment">#     queue = deque([(i,0)])</span></span><br><span class="line">        <span class="comment">#     visited = [0 for _ in range(n)]</span></span><br><span class="line">        <span class="comment">#     while queue:</span></span><br><span class="line">        <span class="comment">#         i,depth = queue.popleft()</span></span><br><span class="line">        <span class="comment">#         visited[i] = 1</span></span><br><span class="line">        <span class="comment">#         for j in adj[i]:</span></span><br><span class="line">        <span class="comment">#             if visited[j]==0:</span></span><br><span class="line">        <span class="comment">#                 queue.append((j,depth+1))</span></span><br><span class="line">        <span class="comment">#     return depth</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># MIN = n</span></span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     temp = helper(i)</span></span><br><span class="line">        <span class="comment">#     if temp&lt;MIN:</span></span><br><span class="line">        <span class="comment">#         MIN = temp</span></span><br><span class="line">        <span class="comment">#         res = [i]</span></span><br><span class="line">        <span class="comment">#     elif temp==MIN:</span></span><br><span class="line">        <span class="comment">#         res.append(i)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 贪心 每次删除边缘节点(即度为1的节点,类似于找树的重心？)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> edges: <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> edges:</span><br><span class="line">            adj[i].append(j)</span><br><span class="line">            adj[j].append(i)</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> len(adj[i])==<span class="number">1</span>:</span><br><span class="line">                queue.append(i)</span><br><span class="line">        <span class="comment"># 最后可能的结果为1个数或者两个数</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">2</span>:</span><br><span class="line">            n -= len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                i = queue.popleft()</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> adj[i]:</span><br><span class="line">                    adj[j].remove(i)</span><br><span class="line">                    <span class="keyword">if</span> len(adj[j])==<span class="number">1</span>:</span><br><span class="line">                        queue.append(j)</span><br><span class="line">        <span class="keyword">return</span> list(queue)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelorder_</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = [root]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder_</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = []</span><br><span class="line">    node = root</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        node = node.right</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder_</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = []</span><br><span class="line">    node = root</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            stack.append(node)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = node.right</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].right!=node:</span><br><span class="line">            node = stack[<span class="number">-1</span>].right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qzh</span><span class="params">(preorder,inorder)</span>:</span></span><br><span class="line">    hashtable = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        val = preorder.pop(<span class="number">0</span>)</span><br><span class="line">        cur = TreeNode(val)</span><br><span class="line">        idx = hashtable[val]</span><br><span class="line">        cur.left = helper(left,idx<span class="number">-1</span>)</span><br><span class="line">        cur.right = helper(idx+<span class="number">1</span>,right)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    <span class="keyword">return</span> postorder_(helper(<span class="number">0</span>,len(inorder)<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hzq</span><span class="params">(inorder,postorder)</span>:</span></span><br><span class="line">    hashtable = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        val = postorder.pop()</span><br><span class="line">        cur = TreeNode(val)</span><br><span class="line">        idx = hashtable[val]</span><br><span class="line">        cur.right = helper(idx+<span class="number">1</span>,right)</span><br><span class="line">        cur.left = helper(left,idx<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    <span class="keyword">return</span> preorder_(helper(<span class="number">0</span>,len(inorder)<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qhz</span><span class="params">(preorder,postorder)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(preleft,postleft,lens)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> lens==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        cur = TreeNode(preorder[preleft])</span><br><span class="line">        <span class="keyword">if</span> lens==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx&lt;lens:</span><br><span class="line">            <span class="keyword">if</span> preorder[preleft+<span class="number">1</span>]==postorder[postleft<span class="number">-1</span>+idx]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        cur.left = helper(preleft+<span class="number">1</span>,postleft,idx)</span><br><span class="line">        cur.right = helper(preleft+<span class="number">1</span>+idx,postleft+idx,lens-idx<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">    <span class="keyword">return</span> inorder_(helper(<span class="number">0</span>,<span class="number">0</span>,len(preorder)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtree</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    root = TreeNode(nums[<span class="number">0</span>])</span><br><span class="line">    queue = deque([root])</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> nums[i]!=<span class="literal">None</span>:</span><br><span class="line">            node.left = TreeNode(nums[i])</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==len(nums):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]!=<span class="literal">None</span>:</span><br><span class="line">            node.right = TreeNode(nums[i])</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i==len(nums):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">7</span>]</span><br><span class="line">root = createtree(nums)</span><br><span class="line">print(root)</span><br><span class="line">levelorder = levelorder_(root)</span><br><span class="line">print(levelorder)</span><br><span class="line">preorder = preorder_(root)</span><br><span class="line">print(preorder)</span><br><span class="line">inorder = inorder_(root)</span><br><span class="line">print(inorder)</span><br><span class="line">postorder = postorder_(root)</span><br><span class="line">print(postorder)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(qzh(preorder,inorder))</span></span><br><span class="line"><span class="comment"># print(hzq(inorder,postorder))</span></span><br><span class="line">print(qhz(preorder,postorder))</span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><hr>
<ul>
<li><p>颜色标记法：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwvc29sdXRpb24veWFuLXNlLWJpYW8tamktZmEteWktY2hvbmctdG9uZy15b25nLXFpZS1qaWFuLW1pbmcv" title="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 层次遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        stack = [(<span class="number">0</span>,root)]</span><br><span class="line">        rst = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            level,i = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,TreeNode):</span><br><span class="line">                stack.extend([(level+<span class="number">1</span>,i.right),(level+<span class="number">1</span>,i.left),(level,i.val)])</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,int):</span><br><span class="line">                <span class="keyword">if</span> len(rst)==level:</span><br><span class="line">                    rst.append([])</span><br><span class="line">                rst[level].append(i)</span><br><span class="line">        <span class="keyword">return</span> rst</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            i = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,TreeNode):</span><br><span class="line">                stack.extend([i.right,i.left,i.val])</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,int):</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            i = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,TreeNode):</span><br><span class="line">                stack.extend([i.right,i.val,i.left])</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,int):</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 颜色标记法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            i = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,TreeNode):</span><br><span class="line">                stack.extend([i.val,i.right,i.left])</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,int):</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>层次遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((root,<span class="number">0</span>))</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            lens = len(queue)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(lens):</span><br><span class="line">                node,level = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> len(res)==level:</span><br><span class="line">                    res.append([])</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    queue.append((root.left,level+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    queue.append((root.right,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(node,level)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(res)==level:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                bfs(node.left,level+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                bfs(node.right,level+<span class="number">1</span>)</span><br><span class="line">        bfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>前序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                stack.extend(node.right,node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Morris非破坏版</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right!=cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="comment"># 当没有相连时，则相连</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    res.append(cur.val) <span class="comment">##########</span></span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 已经相连时,则断开</span></span><br><span class="line">                <span class="keyword">if</span> pre.right==cur:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Morris破坏版(最后变成了一个单链表)</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 找到左结点的右子树的最右结点与当前根结点相连，当前根结点与左子结点则断开</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = cur</span><br><span class="line">                tmp = cur</span><br><span class="line">                cur = cur.left</span><br><span class="line">                tmp.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># Morris非破坏版</span></span><br><span class="line">        res = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right <span class="keyword">and</span> pre.right!=cur:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                <span class="comment"># 当没有相连时，则相连</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pre.right:</span><br><span class="line">                    pre.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 已经相连时,则断开</span></span><br><span class="line">                <span class="keyword">if</span> pre.right==cur:</span><br><span class="line">                    pre.right = <span class="literal">None</span></span><br><span class="line">                    res.append(cur.val) <span class="comment">##########</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 迭代</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node = node.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.right</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].right!=node:</span><br><span class="line">                node = stack[<span class="number">-1</span>].right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><hr>
<ul>
<li><p>由前序，中序构建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(preorder,inorder)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            root = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">            loc = inorder.index(root.val)</span><br><span class="line">            root.left = helper(preorder,inorder[:loc])</span><br><span class="line">            root.right = helper(preorder,inorder[loc+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(preorder,inorder)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># hashmap会快很多</span></span><br><span class="line">        hashmap = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            curval = preorder.pop(<span class="number">0</span>) <span class="comment">##############</span></span><br><span class="line">            cur = TreeNode(curval)</span><br><span class="line">            idx = hashmap[curval]</span><br><span class="line">            cur.left = helper(left,idx<span class="number">-1</span>) <span class="comment">#############</span></span><br><span class="line">            cur.right = helper(idx+<span class="number">1</span>,right) <span class="comment">###########</span></span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>由中，后序构建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        hashmap = &#123;v:k <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            curval = postorder.pop() <span class="comment">############</span></span><br><span class="line">            cur = TreeNode(curval)</span><br><span class="line">            idx = hashmap[curval]</span><br><span class="line">            cur.right = helper(idx+<span class="number">1</span>,right) <span class="comment">###########</span></span><br><span class="line">            cur.left = helper(left,idx<span class="number">-1</span>) <span class="comment">###############</span></span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLXBvc3RvcmRlci10cmF2ZXJzYWwv" title="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">根据前序和后序遍历构造二叉树<i class="fa fa-external-link"></i></span>不唯一</p>
<p>考虑：前序树的第一个结点和后序树的最后一个结点是根结点，所以前序树的第二个结点是左子树的根结点(若有左子树)，则找到与它相同的后序树的结点，以其为分界点，则可以将其分为左子树和右子树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span><span class="params">(self, pre, post)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        i = post.index(pre[<span class="number">1</span>])</span><br><span class="line">        node.left = self.constructFromPrePost(pre[<span class="number">1</span>:i+<span class="number">2</span>], post[:i+<span class="number">1</span>])</span><br><span class="line">        node.right = self.constructFromPrePost(pre[i+<span class="number">2</span>:], post[i+<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="常见题"><a href="#常见题" class="headerlink" title="常见题"></a>常见题</h3><hr>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLXp1aS1qaW4tZ29uZy1nb25nLXp1LXhpYW4tbGNvZi8=" title="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">面试题68 - I. 二叉搜索树的最近公共祖先<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     if p.val&lt;root.val and q.val&lt;root.val:</span></span><br><span class="line">        <span class="comment">#         return helper(root.left)</span></span><br><span class="line">        <span class="comment">#     elif p.val&gt;root.val and q.val&gt;root.val:</span></span><br><span class="line">        <span class="comment">#         return helper(root.right)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return root</span></span><br><span class="line">        <span class="comment"># return helper(root)</span></span><br><span class="line"></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            <span class="keyword">if</span> p.val&lt;node.val <span class="keyword">and</span> q.val&lt;node.val:</span><br><span class="line">                node = node.left</span><br><span class="line">            <span class="keyword">elif</span> p.val&gt;node.val <span class="keyword">and</span> q.val&gt;node.val:</span><br><span class="line">                node = node.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS16dWktamluLWdvbmctZ29uZy16dS14aWFuLWxjb2Yv" title="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">面试题68 - II. 二叉树的最近公共祖先<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: TreeNode, p: TreeNode, q: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># # 找到p或q的位置，若不在同一子树，则返回该根结点，否则返回第一个</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     if not root or root==p or root==q:</span></span><br><span class="line">        <span class="comment">#         return root</span></span><br><span class="line">        <span class="comment">#     left = helper(root.left)</span></span><br><span class="line">        <span class="comment">#     right = helper(root.right)</span></span><br><span class="line">        <span class="comment">#     if not left:</span></span><br><span class="line">        <span class="comment">#         return right</span></span><br><span class="line">        <span class="comment">#     if not right:</span></span><br><span class="line">        <span class="comment">#         return left</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        <span class="comment"># return helper(root)</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     nonlocal res</span></span><br><span class="line">        <span class="comment">#     if not root:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment">#     left = helper(root.left)</span></span><br><span class="line">        <span class="comment">#     right = helper(root.right)</span></span><br><span class="line">        <span class="comment">#     mid = p==root or q==root</span></span><br><span class="line">        <span class="comment">#     if mid+left+right&gt;=2:</span></span><br><span class="line">        <span class="comment">#         res = root</span></span><br><span class="line">        <span class="comment">#     return mid or left or right</span></span><br><span class="line">        <span class="comment"># res = TreeNode(None)</span></span><br><span class="line">        <span class="comment"># helper(root)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWRhdGUtYmluYXJ5LXNlYXJjaC10cmVlLw==" title="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># # 递归</span></span><br><span class="line">        <span class="comment"># def helper(root,minval,maxval):</span></span><br><span class="line">        <span class="comment">#     if not root:</span></span><br><span class="line">        <span class="comment">#         return True</span></span><br><span class="line">        <span class="comment">#     if root.val&lt;=minval or root.val&gt;=maxval:</span></span><br><span class="line">        <span class="comment">#         return False</span></span><br><span class="line">        <span class="comment">#     return helper(root.left,minval,root.val) and helper(root.right,root.val,maxval)</span></span><br><span class="line">        <span class="comment"># return helper(root,float('-inf'),float('inf'))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 中序迭代 有序</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        lower = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node.val&lt;=lower:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            lower = node.val</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2h1LWRlLXppLWppZS1nb3UtbGNvZi8=" title="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">树的子结构<i class="fa fa-external-link"></i></span>题目说可能有空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubStructure</span><span class="params">(self, A: TreeNode, B: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(A,B)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> B:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> A.val==B.val <span class="keyword">and</span> helper(A.left,B.left) <span class="keyword">and</span> helper(A.right,B.right)</span><br><span class="line">        <span class="keyword">return</span> helper(A,B) <span class="keyword">or</span> self.isSubStructure(A.left,B) <span class="keyword">or</span> self.isSubStructure(A.right,B)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VidHJlZS1vZi1hbm90aGVyLXRyZWUv" title="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树<i class="fa fa-external-link"></i></span>注意子树跟子结构的区别，且题目说非空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span><span class="params">(self, s: TreeNode, t: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s,t)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t <span class="keyword">and</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> t <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> s.val==t.val <span class="keyword">and</span> helper(s.left,t.left) <span class="keyword">and</span> helper(s.right,t.right)</span><br><span class="line">        <span class="keyword">return</span> helper(s,t) <span class="keyword">or</span> self.isSubtree(s.left,t) <span class="keyword">or</span> self.isSubtree(s.right,t)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS1kZS1qaW5nLXhpYW5nLWxjb2Yv" title="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.mirrorTree(root.right)</span><br><span class="line">        right = self.mirrorTree(root.left)</span><br><span class="line">        root.left,root.right = left,right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZHVpLWNoZW5nLWRlLWVyLWNoYS1zaHUtbGNvZi8=" title="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">对称的二叉树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> left.val==right.val <span class="keyword">and</span> helper(left.left,right.right) <span class="keyword">and</span> helper(left.right,right.left)</span><br><span class="line">        <span class="keyword">return</span> helper(root,root)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 迭代，类似层序遍历</span></span><br><span class="line">        stack = [(root,root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            left,right = stack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> left.val!=right.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            stack.append((left.left,right.right))</span><br><span class="line">            stack.append((left.right,right.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNvdS1zdW8tc2h1LWRlLWhvdS14dS1iaWFuLWxpLXh1LWxpZS1sY29mLw==" title="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">二叉搜索树的后序遍历序列<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span><span class="params">(self, postorder: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            l = i</span><br><span class="line">            <span class="comment"># 找到第一个大于j的元素的位置，即左右子树的分隔点</span></span><br><span class="line">            <span class="keyword">while</span> postorder[l]&lt;postorder[j]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            m = l <span class="comment"># 找到第一个大于j位置的元素位置</span></span><br><span class="line">            <span class="keyword">while</span> postorder[l]&gt;postorder[j]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 判断l==j，表明m之后的元素确实都大于j的元素，即满足二叉搜索树特性，左|右|根，再循环判断左子树及右子树</span></span><br><span class="line">            <span class="keyword">return</span> l==j <span class="keyword">and</span> helper(i,m<span class="number">-1</span>) <span class="keyword">and</span> helper(m,j<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(postorder)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXItY2hhLXNodS16aG9uZy1oZS13ZWktbW91LXlpLXpoaS1kZS1sdS1qaW5nLWxjb2Yv" title="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/"> 二叉树中和为某一值的路径<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,target,ans)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">if</span> target==root.val:</span><br><span class="line">                    res.append(ans+[root.val])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                helper(root.left,target-root.val,ans+[root.val])</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                helper(root.right,target-root.val,ans+[root.val])</span><br><span class="line">        res = []</span><br><span class="line">        helper(root,sum,ans=[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZQ==" title="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">111.二叉树的最小深度<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # dfs</span></span><br><span class="line">        <span class="comment"># if not root:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># # 确保是到叶子结点</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     if not root.left and not root.right:</span></span><br><span class="line">        <span class="comment">#         return 1</span></span><br><span class="line">        <span class="comment">#     if root.left and root.right:</span></span><br><span class="line">        <span class="comment">#         return 1+min(helper(root.left),helper(root.right))</span></span><br><span class="line">        <span class="comment">#     if root.left:</span></span><br><span class="line">        <span class="comment">#         return 1+helper(root.left)</span></span><br><span class="line">        <span class="comment">#     if root.right:</span></span><br><span class="line">        <span class="comment">#         return 1+helper(root.right)</span></span><br><span class="line">        <span class="comment"># return helper(root)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([(root,<span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node,depth = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.append((node.right,depth+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.append((node.left,depth+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=" title="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树的最大深度<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.right),self.maxDepth(root.left))</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLWJpbmFyeS1zZWFyY2gtdHJlZXMtaWkv" title="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">不同的二叉搜索树 II<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> [<span class="literal">None</span>]</span><br><span class="line">            tree = []</span><br><span class="line">            <span class="comment"># i为根结点</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(left,right+<span class="number">1</span>):</span><br><span class="line">                lefttree = helper(left,i<span class="number">-1</span>)</span><br><span class="line">                righttree = helper(i+<span class="number">1</span>,right)</span><br><span class="line">                <span class="comment"># 从可能的子树中进行排列组合</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> lefttree:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> righttree:</span><br><span class="line">                        cur = TreeNode(i)</span><br><span class="line">                        cur.left = l</span><br><span class="line">                        cur.right = r</span><br><span class="line">                        tree.append(cur)</span><br><span class="line">            <span class="keyword">return</span> tree</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>,n) <span class="keyword">if</span> n&gt;=<span class="number">1</span> <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==" title="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            left = helper(root.right)</span><br><span class="line">            right = helper(root.left)</span><br><span class="line">            root.left,root.right = left,right</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1zb3J0ZWQtYXJyYXktdG8tYmluYXJ5LXNlYXJjaC10cmVlLw==" title="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left&gt;right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (left+right+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            cur = TreeNode(nums[mid])</span><br><span class="line">            cur.left = helper(left,mid<span class="number">-1</span>)</span><br><span class="line">            cur.right = helper(mid+<span class="number">1</span>,right)</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv" title="https://leetcode-cn.com/problems/diameter-of-binary-tree/">二叉树的直径<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diameterOfBinaryTree</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            leftlen = helper(root.left)</span><br><span class="line">            rightlen = helper(root.right)</span><br><span class="line">            res = max(res,<span class="number">1</span>+leftlen+rightlen)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(leftlen,rightlen)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC11bml2YWx1ZS1wYXRoLw==" title="https://leetcode-cn.com/problems/longest-univalue-path/">最长同值路径<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestUnivaluePath</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            leftlen,rightlen = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                leftlen = helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                rightlen = helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.right <span class="keyword">and</span> root.val==root.left.val <span class="keyword">and</span> root.val==root.right.val:</span><br><span class="line">                res = max(res,<span class="number">1</span>+leftlen+rightlen)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+max(leftlen,rightlen)</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> root.val==root.left.val:</span><br><span class="line">                res = max(res,<span class="number">1</span>+leftlen)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+leftlen</span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">and</span> root.val==root.right.val:</span><br><span class="line">                res = max(res,<span class="number">1</span>+rightlen)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>+rightlen</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbWF4aW11bS1wYXRoLXN1bS8=" title="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 如果是负的，宁愿不加</span></span><br><span class="line">            left = max(helper(root.left),<span class="number">0</span>)</span><br><span class="line">            right = max(helper(root.right),<span class="number">0</span>)</span><br><span class="line">            res = max(res,left+right+root.val)</span><br><span class="line">            <span class="keyword">return</span> max(left,right) + root.val</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1iaW5hcnktdHJlZS10by1saW5rZWQtbGlzdC8=" title="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># morris的变体</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                pre = cur.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = cur.right</span><br><span class="line">                cur.right = cur.left</span><br><span class="line">                cur.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 类似后序跟morris的结合</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                pre = root.left</span><br><span class="line">                <span class="keyword">while</span> pre.right:</span><br><span class="line">                    pre = pre.right</span><br><span class="line">                pre.right = root.right</span><br><span class="line">                root.right = root.left</span><br><span class="line">                root.left = <span class="literal">None</span></span><br><span class="line">        helper(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcmlnaHQtc2lkZS12aWV3Lw==" title="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root,level)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(res)==level:</span><br><span class="line">                res.append(<span class="number">0</span>)</span><br><span class="line">            res[level] = root.val</span><br><span class="line">            helper(root.left,level+<span class="number">1</span>)</span><br><span class="line">            helper(root.right,level+<span class="number">1</span>)</span><br><span class="line">        helper(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJpbS1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=" title="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">修剪二叉搜索树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span><span class="params">(self, root: TreeNode, L: int, R: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> root.val&gt;R:</span><br><span class="line">                <span class="keyword">return</span> helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.val&lt;L:</span><br><span class="line">                <span class="keyword">return</span> helper(root.right)</span><br><span class="line">            root.left = helper(root.left)</span><br><span class="line">            root.right = helper(root.right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29udmVydC1ic3QtdG8tZ3JlYXRlci10cmVlLw==" title="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 反序中序遍历</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> total</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.right)</span><br><span class="line">            total += root.val</span><br><span class="line">            root.val = total</span><br><span class="line">            helper(root.left)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.right</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                total += node.val</span><br><span class="line">                node.val = total</span><br><span class="line">                node = node.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGluZy1oZW5nLWVyLWNoYS1zaHUtbGNvZi8=" title="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">面试题55 - II. 平衡二叉树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = helper(root.left)</span><br><span class="line">            <span class="keyword">if</span> left==<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            right = helper(root.right)</span><br><span class="line">            <span class="keyword">if</span> right==<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> abs(left-right)&gt;<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+max(left,right)</span><br><span class="line">        <span class="keyword">return</span> helper(root)!=<span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2stY29tcGxldGVuZXNzLW9mLWEtYmluYXJ5LXRyZWUv" title="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCompleteTree</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque([(root,<span class="number">1</span>)])</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                node,i = queue.popleft()</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count&lt;i:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> node:</span><br><span class="line">                    queue.append((node.left,<span class="number">2</span>*i))</span><br><span class="line">                    queue.append((node.right,<span class="number">2</span>*i+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>*<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ3JhcGgtdmFsaWQtdHJlZS8=" title="https://leetcode-cn.com/problems/graph-valid-tree/">261. 以图判树<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># class UF:</span></span><br><span class="line">        <span class="comment">#     def __init__(self,n):</span></span><br><span class="line">        <span class="comment">#         self.parents = [i for i in range(n)]</span></span><br><span class="line">        <span class="comment">#         self.rank = [0 for _ in range(n)]</span></span><br><span class="line">        <span class="comment">#         self.size = [1 for _ in range(n)]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     def find(self,p):</span></span><br><span class="line">        <span class="comment">#         if self.parents[p]!=p:</span></span><br><span class="line">        <span class="comment">#             self.parents[p] = self.find(self.parents[p])</span></span><br><span class="line">        <span class="comment">#         return self.parents[p]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     def union(self,p,q):</span></span><br><span class="line">        <span class="comment">#         pr,qr = self.find(p),self.find(q)</span></span><br><span class="line">        <span class="comment">#         if pr==qr:</span></span><br><span class="line">        <span class="comment">#             return</span></span><br><span class="line">        <span class="comment">#         if self.rank[pr]&gt;self.rank[qr]:</span></span><br><span class="line">        <span class="comment">#             pr,qr = qr,pr</span></span><br><span class="line">        <span class="comment">#         self.parents[qr] = pr</span></span><br><span class="line">        <span class="comment">#         if self.rank[pr]==self.rank[qr]:</span></span><br><span class="line">        <span class="comment">#             self.rank[pr] += 1</span></span><br><span class="line">        <span class="comment">#         self.size[pr] += self.size[qr]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if len(edges)!=n-1:</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># uf = UF(n)</span></span><br><span class="line">        <span class="comment"># for i,j in edges:</span></span><br><span class="line">        <span class="comment">#     uf.union(i,j)</span></span><br><span class="line">        <span class="comment"># # 如果能构成一个团</span></span><br><span class="line">        <span class="comment"># for i in uf.size:</span></span><br><span class="line">        <span class="comment">#     if i==n:</span></span><br><span class="line">        <span class="comment">#         return True</span></span><br><span class="line">        <span class="comment"># return False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(edges)!=n<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        adj = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> edges:</span><br><span class="line">            adj[i].append(j)</span><br><span class="line">            adj[j].append(i)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> adj[root]:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(i)</span><br><span class="line">                    dfs(i)</span><br><span class="line">        visited = set()</span><br><span class="line">        visited.add(<span class="number">0</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> len(visited)==n</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h3 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h3><a id="more"></a>

<h4 id="序列问题"><a href="#序列问题" class="headerlink" title="序列问题"></a>序列问题</h4><h5 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="*300. 最长上升子序列"></a>*<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==" title="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dp[i]表示a[i]为结尾的最长上升子序列的长度</span><br><span class="line">dp[i] = max(dp[j]+1,dp[i]),if a[j]&lt;a[i],0&lt;=j&lt;i</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># if not nums: return 0</span></span><br><span class="line">        <span class="comment"># dp = [1 for _ in range(len(nums))] # 表示以i结尾的最长上升子序列的长度</span></span><br><span class="line">        <span class="comment"># for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#     for j in range(i):</span></span><br><span class="line">        <span class="comment">#         if nums[j]&lt;nums[i]:</span></span><br><span class="line">        <span class="comment">#             dp[i] = max(dp[i],dp[j]+1)</span></span><br><span class="line">        <span class="comment"># return max(dp)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要使上升子序列尽可能的长，则需要让序列上升得尽可能慢</span></span><br><span class="line">        <span class="comment"># 因此希望每次在上升子序列最后加上的那个数尽可能的小</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = [nums[<span class="number">0</span>]] <span class="comment"># res[i]保存的是长度为i+1的上升子序列的最小尾部值，(所以长度是不变或增加的)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="comment"># 希望上升子序列长</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;res[<span class="number">-1</span>]:</span><br><span class="line">                res.append(nums[i])</span><br><span class="line">            <span class="comment"># 否则需要查找可以被替换为更小的值</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l,r = <span class="number">0</span>,len(res)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                    mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> res[mid]&lt;nums[i]:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = mid</span><br><span class="line">                <span class="comment"># 替换</span></span><br><span class="line">                res[l] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure>

<h5 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv" title="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dp[i][j]表示前缀子串a[1~i]与b[1~j]的最长公共子序列的长度</span><br><span class="line">dp[i][j] = 0 if i==0 or j==0</span><br><span class="line">if a[i]==b[j]:</span><br><span class="line">    dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = max(dp[i-1][j],dp[i][j-1])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, text1: str, text2: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 二维dp</span></span><br><span class="line">        <span class="comment"># m,n = len(text1),len(text2)</span></span><br><span class="line">        <span class="comment"># dp = [[0]*(n+1) for _ in range(m+1)] # i=0 or j=0 则为0</span></span><br><span class="line">        <span class="comment"># for i in range(1,m+1):</span></span><br><span class="line">        <span class="comment">#     for j in range(1,n+1):</span></span><br><span class="line">        <span class="comment">#         if text1[i-1]==text2[j-1]:</span></span><br><span class="line">        <span class="comment">#             dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             dp[i][j] = max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line">        <span class="comment"># return dp[-1][-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 空间压缩</span></span><br><span class="line">        m,n = len(text1),len(text2)</span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        one,two = <span class="number">0</span>,<span class="number">0</span> <span class="comment"># 分别表示i-1层的j-1和j</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            one,two = <span class="number">0</span>,dp[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[j] = one + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = max(two,dp[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">if</span> j&lt;n:</span><br><span class="line">                    one,two = two,dp[j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dp[i][j]表示a[1~j]和b[1~j]可以构成的以b[j]为结尾的长度</span><br><span class="line">if a[i]==b[j]:</span><br><span class="line">    dp[i][j] = max(dp[i][j],dp[i-1][k]+1),if b[k]&lt;b[j],0&lt;=k&lt;j</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = dp[i-1][j]</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h4><h5 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZWRpdC1kaXN0YW5jZS8=" title="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dp[i][j]为word1[0...i]和word2[0...j]匹配的最小编辑距离</span><br><span class="line">if a[i]==b[j]:</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1</span><br><span class="line"># dp[i-1][j] 删除</span><br><span class="line"># dp[i][j-1] 插入</span><br><span class="line"># dp[i][j-1] 替换/跳过</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1: str, word2: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 递归</span></span><br><span class="line">        <span class="comment"># if len(word1)*len(word2)==0:</span></span><br><span class="line">        <span class="comment">#     return len(word1)+len(word2)</span></span><br><span class="line">        <span class="comment"># from functools import lru_cache</span></span><br><span class="line">        <span class="comment"># @lru_cache(None)</span></span><br><span class="line">        <span class="comment"># def helper(i,j):</span></span><br><span class="line">        <span class="comment">#     if i==-1:</span></span><br><span class="line">        <span class="comment">#         return j+1</span></span><br><span class="line">        <span class="comment">#     if j==-1:</span></span><br><span class="line">        <span class="comment">#         return i+1</span></span><br><span class="line">        <span class="comment">#     if word1[i]==word2[j]:</span></span><br><span class="line">        <span class="comment">#         return helper(i-1,j-1)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         return min(</span></span><br><span class="line">        <span class="comment">#             helper(i,j-1)+1,helper(i-1,j)+1,helper(i-1,j-1)+1</span></span><br><span class="line">        <span class="comment">#         )</span></span><br><span class="line">        <span class="comment"># return helper(len(word1)-1,len(word2)-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动规</span></span><br><span class="line">        m,n = len(word1),len(word2)</span><br><span class="line">        <span class="keyword">if</span> m*n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> m+n</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 对于某一word为0时，距离则为另一word的长度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 相同时状态不变</span></span><br><span class="line">                <span class="keyword">if</span> word1[i<span class="number">-1</span>]==word2[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="comment"># 否则取三种操作中最小的</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="面试题-01-05-一次编辑"><a href="#面试题-01-05-一次编辑" class="headerlink" title="面试题 01.05. 一次编辑"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvb25lLWF3YXktbGNjaS8=" title="https://leetcode-cn.com/problems/one-away-lcci/">面试题 01.05. 一次编辑<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oneEditAway</span><span class="params">(self, first: str, second: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> abs(len(first)-len(second))&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(first) <span class="keyword">and</span> j&lt;len(second):</span><br><span class="line">            <span class="keyword">if</span> first[i]==second[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">return</span> first[i+<span class="number">1</span>:]==second[j:] <span class="keyword">or</span> first[i:]==second[j+<span class="number">1</span>:] <span class="keyword">or</span> first[i+<span class="number">1</span>:]==second[j+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="最大和问题"><a href="#最大和问题" class="headerlink" title="最大和问题"></a>最大和问题</h4><h5 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=" title="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 暴力</span></span><br><span class="line">        cur = nums[<span class="number">0</span>]</span><br><span class="line">        res = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> cur&lt;<span class="number">0</span>:</span><br><span class="line">                cur = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur += nums[i]</span><br><span class="line">            res = max(res,cur)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 动规</span></span><br><span class="line">        <span class="comment"># # dp[i] = max(dp[i-1]+a[i],a[i])</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># cur = 0</span></span><br><span class="line">        <span class="comment"># for i in nums:</span></span><br><span class="line">        <span class="comment">#     # 选或者不选</span></span><br><span class="line">        <span class="comment">#     cur = max(cur+i,i)</span></span><br><span class="line">        <span class="comment">#     res = max(res,cur)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 分治</span></span><br><span class="line">        <span class="comment"># def Merge(nums,l,r):</span></span><br><span class="line">        <span class="comment">#     if l==r:</span></span><br><span class="line">        <span class="comment">#         return nums[l]</span></span><br><span class="line">        <span class="comment">#     mid = (l+r)&gt;&gt;1</span></span><br><span class="line">        <span class="comment">#     left = Merge(nums,l,mid)</span></span><br><span class="line">        <span class="comment">#     right = Merge(nums,mid+1,r)</span></span><br><span class="line">        <span class="comment">#     cross = merge(nums,l,mid,r)</span></span><br><span class="line">        <span class="comment">#     return max(left,cross,right)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># def merge(nums,l,mid,r):</span></span><br><span class="line">        <span class="comment">#     cursum = 0</span></span><br><span class="line">        <span class="comment">#     left = float('-inf')</span></span><br><span class="line">        <span class="comment">#     for i in range(mid,l-1,-1):</span></span><br><span class="line">        <span class="comment">#         cursum += nums[i]</span></span><br><span class="line">        <span class="comment">#         left = max(left,cursum)</span></span><br><span class="line">        <span class="comment">#     cursum = 0</span></span><br><span class="line">        <span class="comment">#     right = float('-inf')</span></span><br><span class="line">        <span class="comment">#     for i in range(mid+1,r+1):</span></span><br><span class="line">        <span class="comment">#         cursum += nums[i]</span></span><br><span class="line">        <span class="comment">#         right = max(right,cursum)</span></span><br><span class="line">        <span class="comment">#     return left+right</span></span><br><span class="line">        <span class="comment"># return Merge(nums,0,len(nums)-1)</span></span><br></pre></td></tr></table></figure>

<h5 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdHJpYW5nbGUv" title="https://leetcode-cn.com/problems/triangle/">120. 三角形最小路径和<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + a[i][j]</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> triangle <span class="keyword">or</span> len(triangle[<span class="number">0</span>])==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m,n = len(triangle),len(triangle[<span class="number">-1</span>])</span><br><span class="line">        dp = [[float(<span class="string">'inf'</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j==i:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + a[i][j]</span></span><br><span class="line">        <span class="comment"># if not triangle or len(triangle[0])==0:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># m,n = len(triangle),len(triangle[-1])</span></span><br><span class="line">        <span class="comment"># dp = [float('inf') for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># dp[0] = triangle[0][0]</span></span><br><span class="line">        <span class="comment"># for i in range(1,m):</span></span><br><span class="line">        <span class="comment">#     pre,cur = dp[0],dp[1]</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1):</span></span><br><span class="line">        <span class="comment">#         if j==0 or j==i:</span></span><br><span class="line">        <span class="comment">#             dp[j] = pre + triangle[i][j]</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             dp[j] = min(pre,cur) + triangle[i][j]</span></span><br><span class="line">        <span class="comment">#             if j&gt;=1:</span></span><br><span class="line">        <span class="comment">#                 pre,cur = cur,dp[j+1]</span></span><br><span class="line">        <span class="comment"># return min(dp)</span></span><br></pre></td></tr></table></figure>

<h3 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i][j]一般表示区间[i,j)之间的某个属性，它是分阶段划分问题，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系(例：dp[i][j] = max(dp[i][k]+dp[k][j]+决策,k为断点）</span><br><span class="line"># 枚举合并点，将问题分解成为左右两个部分，再将左右两个部分的最优值进行合并得到原问题的最优值。 </span><br><span class="line">区间DP的做法较为固定，即枚举区间长度，再枚举左端点，之后枚举区间的断点进行转移</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">memset(dp,0,sizeof(dp));</span><br><span class="line">//初始dp数组</span><br><span class="line">for(int len=2;len&lt;=n;len++)&#123;</span><br><span class="line">    //枚举区间长度</span><br><span class="line">    for(int i=0;i&lt;n;++i)&#123;//枚举区间的起点</span><br><span class="line">        int j=i+len;//根据起点和长度得出终点</span><br><span class="line">        if(j&gt;=n) break;//符合条件的终点</span><br><span class="line">        for(int k=i;k&lt;j;++k)//枚举最优分割点</span><br><span class="line">            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]+w[i][j]);//状态转移方程</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzZXF1ZW5jZS8=" title="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># if s[i]==s[j]:</span></span><br><span class="line">        <span class="comment">#     dp[i][j] = dp[i+1][j-1] + 2</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     dp[i][j] = max(dp[i+1][j],dp[i][j-1])</span></span><br><span class="line"></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 由右、下、右下推左上</span></span><br><span class="line">        <span class="comment"># for j in range(n):</span></span><br><span class="line">        <span class="comment">#     for i in range(j-1,-1,-1):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> s[i]==s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="**5. 最长回文子串"></a>**<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzdHJpbmcv" title="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 中心扩散法</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">panlidrome</span><span class="params">(s,l,r)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> r&lt;n <span class="keyword">and</span> s[l]==s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            even = panlidrome(s,i,i+<span class="number">1</span>)</span><br><span class="line">            odd = panlidrome(s,i,i)</span><br><span class="line">            res = res <span class="keyword">if</span> len(res)&gt;=len(even) <span class="keyword">else</span> even</span><br><span class="line">            res = res <span class="keyword">if</span> len(res)&gt;=len(odd) <span class="keyword">else</span> odd</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 动规</span></span><br><span class="line">        <span class="comment"># n = len(s)</span></span><br><span class="line">        <span class="comment"># dp = [[False]*n for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># res = ''</span></span><br><span class="line">        <span class="comment"># for j in range(n):</span></span><br><span class="line">        <span class="comment">#     for i in range(j+1):</span></span><br><span class="line">        <span class="comment">#         if s[i]==s[j]:</span></span><br><span class="line">        <span class="comment">#             if j-i&lt;=2:</span></span><br><span class="line">        <span class="comment">#                 dp[i][j] = True</span></span><br><span class="line">        <span class="comment">#             else:</span></span><br><span class="line">        <span class="comment">#                 dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line">        <span class="comment">#             if dp[i][j] and j-i+1&gt;len(res):</span></span><br><span class="line">        <span class="comment">#                 res = s[i:j+1]</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>

<h5 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFsaW5kcm9taWMtc3Vic3RyaW5ncy8=" title="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># n = len(s)</span></span><br><span class="line">        <span class="comment"># dp = [[False]*n for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     dp[i][i] = True</span></span><br><span class="line">        <span class="comment"># res = n</span></span><br><span class="line">        <span class="comment"># for j in range(n):</span></span><br><span class="line">        <span class="comment">#     for i in range(j):</span></span><br><span class="line">        <span class="comment">#         if s[i]==s[j]:</span></span><br><span class="line">        <span class="comment">#             if j-i&lt;3:</span></span><br><span class="line">        <span class="comment">#                 dp[i][j] = True</span></span><br><span class="line">        <span class="comment">#             else:</span></span><br><span class="line">        <span class="comment">#                 dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line">        <span class="comment">#             if dp[i][j]:</span></span><br><span class="line">        <span class="comment">#                 res += 1</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(l,r)</span>:</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> l&gt;=<span class="number">0</span> <span class="keyword">and</span> r&lt;n <span class="keyword">and</span> s[l]==s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        n = len(s)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res += center(i,i+<span class="number">1</span>)</span><br><span class="line">            res += center(i,i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1039-多边形三角剖分的最低得分"><a href="#1039-多边形三角剖分的最低得分" class="headerlink" title="1039. 多边形三角剖分的最低得分"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1zY29yZS10cmlhbmd1bGF0aW9uLW9mLXBvbHlnb24v" title="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/">1039. 多边形三角剖分的最低得分<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minScoreTriangulation</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> lens <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                j = i+lens</span><br><span class="line">                <span class="keyword">if</span> j&gt;=n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                dp[i][j] = float(<span class="string">'inf'</span>)</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i+<span class="number">1</span>,j):</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]+A[i]*A[k]*A[j])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYnVyc3QtYmFsbG9vbnMv" title="https://leetcode-cn.com/problems/burst-balloons/">312. 戳气球<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxCoins</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 动规</span></span><br><span class="line">        <span class="comment"># nums = [1] + nums + [1]</span></span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        <span class="comment"># dp = [[0]*n for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># for i in range(n-1,-1,-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,n):</span></span><br><span class="line">        <span class="comment">#         if j-i&lt;=1:</span></span><br><span class="line">        <span class="comment">#             continue</span></span><br><span class="line">        <span class="comment">#         for k in range(i+1,j):</span></span><br><span class="line">        <span class="comment">#             dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j])</span></span><br><span class="line">        <span class="comment"># return dp[0][n-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动规</span></span><br><span class="line">        nums = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> lens <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                j = i+lens</span><br><span class="line">                <span class="keyword">if</span> j&gt;n<span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(i+<span class="number">1</span>,j):</span><br><span class="line">                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+nums[i]*nums[k]*nums[j])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># from functools import lru_cache</span></span><br><span class="line">        <span class="comment"># nums = [1]+nums+[1]</span></span><br><span class="line">        <span class="comment"># @lru_cache(None)</span></span><br><span class="line">        <span class="comment"># def helper(l,r):</span></span><br><span class="line">        <span class="comment">#     # 区间长度为2时，即只剩1,1</span></span><br><span class="line">        <span class="comment">#     if r-l==1:</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     tmp = 0</span></span><br><span class="line">        <span class="comment">#     for i in range(l+1,r):</span></span><br><span class="line">        <span class="comment">#         tmp = max(tmp,nums[l]*nums[i]*nums[r]+helper(l,i)+helper(i,r))</span></span><br><span class="line">        <span class="comment">#     return tmp</span></span><br><span class="line">        <span class="comment"># return helper(0,len(nums)-1)</span></span><br></pre></td></tr></table></figure>

<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h4><hr>
<ul>
<li><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
</li>
<li><p>特点：<strong>每种物品仅有一件</strong>，可以选择放或不放。</p>
</li>
<li><p>状态转移方程：$F[i,v]=max(F[i-1,v],F[i-1,v-c_i]+w_i)$,即前i件物品放入一个容量为v的背包时可获得的最大价值</p>
</li>
<li><p>初始化的细节问题：<strong>要求恰好装满背包</strong>，那么在初始化时除了F[0]为0,其它F[1…V]均设为$-\infty$，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。<strong>只希望价格尽量大</strong>，初始化时应该将 F[0..V ] 全部设为0</p>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二维</span></span><br><span class="line">N,V = map(int,input().split())</span><br><span class="line">c,w = [<span class="number">0</span>],[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">    line = list(map(int,input().split()))</span><br><span class="line">    c.append(line[<span class="number">0</span>])</span><br><span class="line">    w.append(line[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>,V+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 第i个物品不选择时</span></span><br><span class="line">        dp[i][v] = dp[i<span class="number">-1</span>][v]</span><br><span class="line">        <span class="keyword">if</span> v&gt;=c[i<span class="number">-1</span>]:</span><br><span class="line">            <span class="comment"># 背包容量v大于第i件物品费用时，选择最大值</span></span><br><span class="line">            dp[i][v] = max(dp[i][v],dp[i<span class="number">-1</span>][v-c[i]]+w[i])</span><br><span class="line">print(dp[<span class="number">-1</span>][<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 由二维优化到一维</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V,c[i]<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment">################从后往前</span></span><br><span class="line">        dp[v] = max(dp[v],dp[v-c[i]]+w[i])</span><br><span class="line">print(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度为O(NV)，空间复杂度为O(V)</p>
</li>
</ul>
<h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h4><hr>
<ul>
<li><p>特点：<strong>每种物品都有无限件可用</strong></p>
</li>
<li><p>状态转移方程：$F[i,v]=max(F[i-1,v-kc_i]+kw_i|0\le kc_i\le v)$,即前i件物品放入一个容量为v的背包时可获得的最大价值，每件物品可能取k次，等价为$F[i,v] = max(F[i−1,v],F[i,v−c_i] + w_i) $，即将第一个式子v-c_i替换v结合得到</p>
</li>
<li><p>优化问题：</p>
<ul>
<li>若两件物品i,j，满足$c_i\le c_j \ \ and \ \ w_i \ge w_j$，则删除j</li>
<li>删除$c_i&gt;V$的i，并做排序，可以找出费用相同的物品中价值最高的是哪个</li>
</ul>
</li>
<li><p>其他想法：转化为01背包问题求解</p>
<ul>
<li>把每件物品转换为$V//c_i$件物品，费用和价值不变</li>
<li>二进制优化：将每件物品转换为费用为$c_i2^k$，价值为$w_i2^k$的若干件物品，k为$c_i2^k\le V$的非负整数</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维按0-1背包问题，即每次选物品可以选择k次，kc_i&lt;=v，对应第一个状态转移方程</span></span><br><span class="line">dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V,<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment">####从后往前</span></span><br><span class="line">        k = v//c[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[v] = max(dp[v],dp[v-j*c[i]]+j*w[i])</span><br><span class="line">print(dp[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 一维优化，对应第二个状态转移方程    </span></span><br><span class="line">dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V+<span class="number">1</span>): <span class="comment">#####从前往后</span></span><br><span class="line">        <span class="keyword">if</span> v&gt;= c[i]:</span><br><span class="line">            dp[v] = max(dp[v],dp[v-c[i]]+w[i])</span><br><span class="line">print(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度为O(NV)，空间复杂度为O(V)</p>
</li>
</ul>
<h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h4><ul>
<li><p>特点：<strong>每种物品i最多选择m[i]件</strong></p>
</li>
<li><p>状态转移方程：$F[i,v]=max(F[i-1,v-kc_i]+kw_i|0\le k\le m_i \ \ and \ \ 0\le kc_i \le v)$,即前i件物品放入一个容量为v的背包时可获得的最大价值，每件物品可能取k次</p>
</li>
<li><p>其他想法：转化为01背包问题求解</p>
<ul>
<li><p>二进制优化，每件物品限制的个数为$m_i$，则取$floor(log_2(m_i))+1$组，其中个数分别为$2^k,k=0,1,2…floor(log_2(m_i))$，最后一组为剩下的个数，则对应的费用则为$c_i<em>个数$，价值为$w_i</em>个数$的若干件物品</p>
</li>
<li><p>单调队列优化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i,v] = max(f[i-1,v-kc_i]+kw_i|0&lt;=k&lt;=m_i and 0&lt;=kc_i&lt;=v)</span><br><span class="line">令 a=v/c_i,b=v%c_i ==&gt; v=ac_i+b ==&gt; f[i,v] = max(f[i-1,b+(a-k)c_i]+kw_i|0&lt;=k&lt;=m_i and 0&lt;=kc_i&lt;=v) 令k=a-k ==&gt; f[i,v] = max(f[i-1,b+kc_i]-kw_i)+aw_i|a-m_i&lt;=k&lt;=a and 0&lt;=(a-k)c_i&lt;=v</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维按0-1背包问题，即每次选物品可以选择k次，kc_i&lt;=v and k&lt;=m_i，对应第一个状态转移方程</span></span><br><span class="line">dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V,<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment">####从后往前</span></span><br><span class="line">        k = min(v//c[i],m[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">            dp[v] = max(dp[v],dp[v-j*c[i]]+j*w[i])</span><br><span class="line">print(dp[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        c,w,m = [],[],[]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            line = list(map(int,input().split()))</span><br><span class="line">            c.append(line[<span class="number">0</span>])</span><br><span class="line">            w.append(line[<span class="number">1</span>])</span><br><span class="line">            m.append(line[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 二进制优化 O(NVlogM)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="comment"># k为1,2,4,8...，m[i]则逐步减少，最后m[i]为剩余的数量&gt;0</span></span><br><span class="line">        <span class="keyword">while</span> k&lt;m[i]:</span><br><span class="line">            c.append(k*c[i])</span><br><span class="line">            w.append(k*w[i])</span><br><span class="line">            m[i] -= k</span><br><span class="line">            k *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> m[i]: <span class="comment">#肯定成立</span></span><br><span class="line">            c[i] = m[i]*c[i]</span><br><span class="line">            w[i] = m[i]*w[i]</span><br><span class="line">    <span class="comment"># 0-1背包</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    N = len(c) <span class="comment"># N更新</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> v&gt;=c[i]:</span><br><span class="line">                dp[v] = max(dp[v],dp[v-c[i]]+w[i])</span><br><span class="line">    print(dp[<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 单调队列优化O(NV)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        c,w,m = [],[],[]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            line = list(map(int,input().split()))</span><br><span class="line">            c.append(line[<span class="number">0</span>])</span><br><span class="line">            w.append(line[<span class="number">1</span>])</span><br><span class="line">            m.append(line[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    queue = deque([[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]) <span class="comment"># 每一轮最值的k和dp值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(c[i]):</span><br><span class="line">            head,tail = <span class="number">0</span>,<span class="number">0</span> <span class="comment"># 队首，队尾</span></span><br><span class="line">            stop = (V-b)//c[i] <span class="comment"># b+kci&lt;=V</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(stop+<span class="number">1</span>):</span><br><span class="line">                temp = dp[k*c[i]+b]-k*w[i]</span><br><span class="line">                <span class="comment"># 保证队列单调递减，队尾为dp[k*c[i]+b]-k*w[i]</span></span><br><span class="line">                <span class="keyword">while</span> head&lt;tail <span class="keyword">and</span> temp&gt;=queue[tail<span class="number">-1</span>][<span class="number">-1</span>]:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">                queue[tail] = [k,temp]</span><br><span class="line">                tail += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> queue[head][<span class="number">0</span>]&lt;k-m[i]:</span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">                <span class="comment"># queue的头部为最大值 </span></span><br><span class="line">                <span class="comment"># dp[b+kc_i] = max&#123;dp[b+jc_i]-jw_i|0&lt;=j&lt;=k&#125;+kw_i</span></span><br><span class="line">                dp[k*c[i]+b] = queue[head][<span class="number">-1</span>] + k*w[i]</span><br><span class="line">    print(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度为O(NV)，空间复杂度为O(V)</p>
</li>
</ul>
<h4 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h4><ul>
<li><p>特点：即<strong>所有的物品可能有三种状态</strong>，当$m_i有-1,0,&gt;0三种状态，分别表示0-1，完全，多重$</p>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,c,m,w)</span>:</span></span><br><span class="line">        self.c = c</span><br><span class="line">        self.m = m</span><br><span class="line">        self.w = w</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            c,w,m = map(int,input().split())</span><br><span class="line">            <span class="keyword">if</span> m&lt;=<span class="number">0</span>:</span><br><span class="line">                nums.append(Node(c,m,w))</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#将混合背包二进制优化</span></span><br><span class="line">                k = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k&lt;=m:</span><br><span class="line">                    nums.append(Node(k*c,<span class="number">-1</span>,k*w))</span><br><span class="line">                    m -= k</span><br><span class="line">                    k *= <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> m:</span><br><span class="line">                    nums.append(Node(m*c,<span class="number">-1</span>,m*w))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    N = len(nums)</span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> nums[i].m==<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(V,nums[i].c<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                dp[v] = max(dp[v],dp[v-nums[i].c]+nums[i].w)</span><br><span class="line">        <span class="keyword">elif</span> nums[i].m==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(nums[i].c,V+<span class="number">1</span>):</span><br><span class="line">                dp[v] = max(dp[v],dp[v-nums[i].c]+nums[i].w)</span><br><span class="line">    print(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h4><ul>
<li><p>特点：<strong>即0-1背包问题的基础上，增加一个重量限制</strong></p>
</li>
<li><p>状态转移方程：$F[i,v,m]=max(F[i-1,v,m],F[i-1,v-c_i,m-m_i]+w_i)$，即前i件物品放入一个容量为v，质量限制为m的背包时可获得的最大价值</p>
</li>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,c,m,w)</span>:</span></span><br><span class="line">        self.c = c</span><br><span class="line">        self.m = m</span><br><span class="line">        self.w = w</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V,M = map(int,input().split())</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            c,m,w = map(int,input().split())</span><br><span class="line">            nums.append(Node(c,m,w))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V,nums[i].c<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> range(M,nums[i].m<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                dp[v][m] = max(dp[v][m],dp[v-nums[i].c][m-nums[i].m]+nums[i].w)</span><br><span class="line">    print(dp[<span class="number">-1</span>][<span class="number">-1</span>])</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">########################################</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V,M = map(int,input().split())</span><br><span class="line">        nums = []</span><br><span class="line">        dp = [[<span class="number">0</span>]*(M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            c,m,w = map(int,input().split())</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(V,c<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(M,m<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    dp[v][j] = max(dp[v][j],dp[v-c][j-m]+w)          </span><br><span class="line">        print(dp[<span class="number">-1</span>][<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h4><ul>
<li><p>特点：<strong>即0-1背包问题的基础上，所有物品被分为若干组N，每一组有s_i件物品，但最多只能选择一件物品，即分组互斥</strong></p>
</li>
<li><p>状态转移方程：$F[i,v]=max(F[i-1,v],F[i-1,v-c_{s_j}]+w_{s_j}|j=1…s)$,即<strong>前i组</strong>物品放入一个容量为v时可获得的最大价值</p>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,c,w)</span>:</span></span><br><span class="line">        self.c = c</span><br><span class="line">        self.w = w</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            s = int(input())</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(s):</span><br><span class="line">                c,w = map(int,input().split())</span><br><span class="line">                tmp.append(Node(c,w))</span><br><span class="line">            nums.append(tmp)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> range(len(nums[i])):</span><br><span class="line">                <span class="keyword">if</span> v&gt;=nums[i][s].c:</span><br><span class="line">                    dp[v] = max(dp[v],dp[v-nums[i][s].c]+nums[i][s].w)</span><br><span class="line">    print(dp[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="有依赖的背包-hard"><a href="#有依赖的背包-hard" class="headerlink" title="有依赖的背包(hard)"></a>有依赖的背包(hard)</h4><ul>
<li><p>特点：<strong>即所有物品构成一棵树，选择时有依赖关系，选择某个结点时，其父结点也必须选择</strong></p>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addedge</span><span class="params">(u,v)</span>:</span> <span class="comment">#建立链式前向星，a起点指向b终点</span></span><br><span class="line">    <span class="keyword">global</span> idx</span><br><span class="line">    e[idx] = v <span class="comment">#每个输入边的终点,这里即输入的编号</span></span><br><span class="line">    ne[idx] = h[u] <span class="comment">#用来表示以idx为起点的下一条边在e中存储的位置,这里的第一条边存储的位置其实在以idx为起点的所有边的最后输入的那个idx</span></span><br><span class="line">    h[u] = idx <span class="comment">#以u为起点的第一条边在e的存储位置</span></span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root,dp)</span>:</span></span><br><span class="line">    i = h[root] <span class="comment">#以root为起点的一条边的序号</span></span><br><span class="line">    <span class="keyword">while</span> i!=<span class="number">-1</span>:</span><br><span class="line">        son = e[i] <span class="comment">#子结点</span></span><br><span class="line">        dfs(son,dp)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V-c[root],<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment">#必须留出根结点的容量，才能拿它的子结点</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,v+<span class="number">1</span>): <span class="comment">#将不同的子树选择看作分组背包问题</span></span><br><span class="line">                <span class="comment"># 从子树更新最大价值</span></span><br><span class="line">                dp[root][v] = max(dp[root][v],dp[root][v-k]+dp[son][k])</span><br><span class="line">        i = ne[i]</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V,c[root]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 背包容量足够时，则加上当前结点</span></span><br><span class="line">        dp[root][v] = dp[root][v-c[root]]+w[root]</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">0</span>,c[root]):</span><br><span class="line">        <span class="comment"># 背包容量不够时，该结点及子结点均不能放入</span></span><br><span class="line">        dp[root][v] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        c = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        w = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        e = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        ne = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        h = [<span class="number">-1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        idx = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            line = list(map(int,input().split())) </span><br><span class="line">            <span class="comment">#line[-1]表示该物品的父结点</span></span><br><span class="line">            <span class="keyword">if</span> line[<span class="number">-1</span>]==<span class="number">-1</span>:</span><br><span class="line">                root = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                addedge(line[<span class="number">-1</span>],i)</span><br><span class="line">            c[i] = line[<span class="number">0</span>]</span><br><span class="line">            w[i] = line[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    dfs(root,dp)</span><br><span class="line">    print(dp[root][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="背包的方案数"><a href="#背包的方案数" class="headerlink" title="背包的方案数"></a>背包的方案数</h4><ul>
<li><p>特点：求最优时的方案数</p>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        dp = [float(<span class="string">'-inf'</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)] <span class="comment">#恰好</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">#v为0的时候只有一种方案</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            c,w = map(int, input().split())</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(V,c<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                tmp = max(dp[v],dp[v-c]+w)</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> tmp==dp[v]:</span><br><span class="line">                    s += res[v]</span><br><span class="line">                <span class="keyword">if</span> tmp==dp[v-c]+w:</span><br><span class="line">                    s += res[v-c]</span><br><span class="line">                dp[v] = tmp</span><br><span class="line">                res[v] = s%<span class="number">1000000007</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 统计最大价值w,可能对应多个v</span></span><br><span class="line">    maxw = float(<span class="string">'-inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">        maxw = max(maxw,dp[v])</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> maxw==dp[v]:</span><br><span class="line">            ans = (ans+res[v])%<span class="number">1000000007</span></span><br><span class="line">    print(ans)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="背包的方案"><a href="#背包的方案" class="headerlink" title="背包的方案"></a>背包的方案</h4><ul>
<li><p>特点：求0-1背包时的最优方案，按照字典序最小的方法排列(即1,4和2,3均满足条件时，选择1,4)</p>
</li>
<li><p>代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        c,w = [<span class="number">0</span>],[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            line = list(map(int, input().split()))</span><br><span class="line">            c.append(line[<span class="number">0</span>])</span><br><span class="line">            w.append(line[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            dp[i][v] = dp[i+<span class="number">1</span>][v]</span><br><span class="line">            <span class="keyword">if</span> v&gt;=c[i]:</span><br><span class="line">                dp[i][v] = max(dp[i][v],dp[i+<span class="number">1</span>][v-c[i]]+w[i])</span><br><span class="line">    vol = V</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># print(c[i])</span></span><br><span class="line">        <span class="comment"># print(dp[i][vol])</span></span><br><span class="line">        <span class="comment"># eg:当i=1时，因为是逆序遍历N的，所以dp[1][V]肯定是最大价值，当其与dp[2][V-c[1]]+w[1]相等时，则说明选择了1</span></span><br><span class="line">        <span class="keyword">if</span> vol&gt;=c[i] <span class="keyword">and</span> dp[i][vol] == dp[i+<span class="number">1</span>][vol-c[i]]+w[i]:</span><br><span class="line">            print(i,end=<span class="string">' '</span>)</span><br><span class="line">            vol -= c[i]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 反正上述代码中dp[0]一直没被用到，故减少一行        </span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        N,V = map(int,input().split())</span><br><span class="line">        c,w = [],[]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">            line = list(map(int, input().split()))</span><br><span class="line">            c.append(line[<span class="number">0</span>])</span><br><span class="line">            w.append(line[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    dp = [[<span class="number">0</span>]*(V+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            dp[i][v] = dp[i+<span class="number">1</span>][v]</span><br><span class="line">            <span class="keyword">if</span> v&gt;=c[i]:</span><br><span class="line">                dp[i][v] = max(dp[i][v],dp[i+<span class="number">1</span>][v-c[i]]+w[i])</span><br><span class="line">    vol = V</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="comment"># eg:当i=1时，因为是逆序遍历N的，所以dp[1][V]肯定是最大价值，当其与dp[2][V-c[1]]+w[1]相等时，则说明选择了1</span></span><br><span class="line">        <span class="keyword">if</span> vol&gt;=c[i] <span class="keyword">and</span> dp[i][vol] == dp[i+<span class="number">1</span>][vol-c[i]]+w[i]:</span><br><span class="line">            print(i+<span class="number">1</span>,end=<span class="string">' '</span>) <span class="comment"># 从1开始编号的</span></span><br><span class="line">            vol -= c[i]</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">// c++版本</span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int N=<span class="number">0</span>;</span><br><span class="line">    int V=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line">    int c[N+<span class="number">1</span>],w[N+<span class="number">1</span>]=&#123;&#125;; //一定要初始化</span><br><span class="line">    int dp[N+<span class="number">1</span>][V+<span class="number">1</span>]=&#123;&#125;; //一定要初始化</span><br><span class="line">    <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;N;i++) cin&gt;&gt;c[i]&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span> (int i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (int v=<span class="number">0</span>;v&lt;=V;v++)&#123;</span><br><span class="line">            dp[i][v] = dp[i+<span class="number">1</span>][v];</span><br><span class="line">            <span class="keyword">if</span> (v&gt;=c[i])</span><br><span class="line">                dp[i][v] = max(dp[i][v],dp[i+<span class="number">1</span>][v-c[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int vol=V;</span><br><span class="line">    <span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (vol&gt;=c[i] &amp;&amp; dp[i][vol]==dp[i+<span class="number">1</span>][vol-c[i]]+w[i])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">            vol-=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><h5 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWVxdWFsLXN1YnNldC1zdW0v" title="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 0-1背包</span></span><br><span class="line">        total = sum(nums)</span><br><span class="line">        <span class="comment"># 奇数则不可能</span></span><br><span class="line">        <span class="keyword">if</span> total&amp;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        V = total//<span class="number">2</span></span><br><span class="line">        N = len(nums)</span><br><span class="line">        dp = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(V+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(V,nums[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                dp[v] = dp[v] <span class="keyword">or</span> dp[v-nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 0-1背包</span></span><br><span class="line">        <span class="comment"># total = sum(nums)</span></span><br><span class="line">        <span class="comment"># # 奇数则不可能</span></span><br><span class="line">        <span class="comment"># if total&amp;1:</span></span><br><span class="line">        <span class="comment">#     return False</span></span><br><span class="line">        <span class="comment"># V = total//2</span></span><br><span class="line">        <span class="comment"># N = len(nums)</span></span><br><span class="line">        <span class="comment"># dp = [float('-inf') for _ in range(V+1)] #恰好</span></span><br><span class="line">        <span class="comment"># dp[0] = 0</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     for v in range(V,nums[i]-1,-1):</span></span><br><span class="line">        <span class="comment">#         dp[v] = max(dp[v],dp[v-nums[i]]+nums[i])</span></span><br><span class="line">        <span class="comment"># return dp[-1]==V</span></span><br></pre></td></tr></table></figure>

<h5 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdGFyZ2V0LXN1bS8=" title="https://leetcode-cn.com/problems/target-sum/">494. 目标和<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums: List[int], S: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # sum(P)-sum(N)=S ==&gt; sum(P)-(sum(T)-sum(P))=S ==&gt; 2sum(P)=S+sum(T)</span></span><br><span class="line">        <span class="comment"># total = sum(nums)</span></span><br><span class="line">        <span class="comment"># if total&lt;S or (total+S)&amp;1:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="comment"># V = (total+S)//2</span></span><br><span class="line">        <span class="comment"># N = len(nums)</span></span><br><span class="line">        <span class="comment"># dp = [0 for _ in range(V+1)]</span></span><br><span class="line">        <span class="comment"># dp[0] = 1</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     for v in range(V,nums[i]-1,-1):</span></span><br><span class="line">        <span class="comment">#         dp[v] += dp[v-nums[i]]</span></span><br><span class="line">        <span class="comment"># return dp[-1]</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line">        n = len(nums)</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,sums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i==n:</span><br><span class="line">                <span class="keyword">return</span> int(S==sums)</span><br><span class="line">            <span class="keyword">return</span> helper(i+<span class="number">1</span>,sums+nums[i]) + helper(i+<span class="number">1</span>,sums-nums[i])</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2Uv" title="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(level,sums)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> sums&gt;amount:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> sums==amount:</span><br><span class="line">                res = min(res,level)</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> coins:</span><br><span class="line">                helper(level+<span class="number">1</span>,sums+j)</span><br><span class="line">        helper(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res!=float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> coins:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> amount==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        coins.sort()</span><br><span class="line">        <span class="keyword">if</span> coins[<span class="number">0</span>]&gt;amount:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">        queue = deque()</span><br><span class="line">        queue.append((amount,<span class="number">0</span>))</span><br><span class="line">        visited = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            lens = len(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(lens):</span><br><span class="line">                j,level = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited[j] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">                        <span class="keyword">if</span> j-c&gt;=<span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> visited.get(j-c):</span><br><span class="line">                            queue.append((j-c,level+<span class="number">1</span>))</span><br><span class="line">                            <span class="keyword">if</span> j-c==<span class="number">0</span>:</span><br><span class="line">                                <span class="keyword">return</span> level+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 完全背包求最小的选择数 dp[i][v] = min&#123;dp[i-1][v],dp[i-1][v-kc_j]+k&#125;</span></span><br><span class="line">        <span class="comment"># N = len(coins)</span></span><br><span class="line">        <span class="comment"># dp = [float('inf') for _ in range(amount+1)]</span></span><br><span class="line">        <span class="comment"># dp[0] = 0</span></span><br><span class="line">        <span class="comment"># for i in range(N):</span></span><br><span class="line">        <span class="comment">#     for v in range(coins[i],amount+1):</span></span><br><span class="line">        <span class="comment">#         dp[v] = min(dp[v],dp[v-coins[i]]+1)</span></span><br><span class="line">        <span class="comment"># return dp[-1] if dp[-1]!=float('inf') else -1</span></span><br></pre></td></tr></table></figure>

<h5 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2UtMi8=" title="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount: int, coins: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 完全背包求方案数</span></span><br><span class="line">        <span class="comment"># dp[i][v] = dp[i-1][v]+dp[i-1][v-c_j]+...+dp[i-1][v-kc_j] </span></span><br><span class="line">        <span class="comment">#          -&gt; dp[i][v] = dp[i-1][v]+dp[i-1][v-c_j]</span></span><br><span class="line">        <span class="comment"># 一维</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(amount+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i,coin <span class="keyword">in</span> enumerate(coins):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(coin,amount+<span class="number">1</span>):</span><br><span class="line">                dp[v] += dp[v-coin]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 二维</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*(amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(coins)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(coins)+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(coins)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> range(<span class="number">1</span>,amount+<span class="number">1</span>):</span><br><span class="line">                dp[i][v] = dp[i<span class="number">-1</span>][v]</span><br><span class="line">                <span class="keyword">if</span> v&gt;=coins[i<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][v] += dp[i][v-coins[i<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvb25lcy1hbmQtemVyb2VzLw==" title="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        dp = [[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        nums = &#123;k:Counter(v) <span class="keyword">for</span> k,v <span class="keyword">in</span> enumerate(strs)&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            num0 = nums[i].get(<span class="string">'0'</span>,<span class="number">0</span>)</span><br><span class="line">            num1 = nums[i].get(<span class="string">'1'</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m,num0<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(n,num1<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                    dp[j][v] = max(dp[j][v],dp[j-num0][v-num1]+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="编程题-运矿石"><a href="#编程题-运矿石" class="headerlink" title="[编程题]运矿石"></a><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3F1ZXN0aW9uVGVybWluYWwvYjU4ZjkyMmNjOTI0NDc4ZmExZTJkY2EyY2M0ZjRlYjc/YW5zd2VyVHlwZT0xJmY9ZGlzY3Vzc2lvbg==" title="https://www.nowcoder.com/questionTerminal/b58f922cc924478fa1e2dca2cc4f4eb7?answerType=1&f=discussion">[编程题]运矿石<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(stone_list)</span>:</span></span><br><span class="line">    n = len(stone_list)</span><br><span class="line">    total = sum(stone_list)</span><br><span class="line">    res = float(<span class="string">'inf'</span>)</span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">    @lru_cache(None)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(k,sums)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="comment"># 假设取得较小的那一部分，当==n/2时，另一边为n//2 or n//2+1</span></span><br><span class="line">        <span class="keyword">if</span> k==n//<span class="number">2</span>:</span><br><span class="line">            res = min(res,abs(<span class="number">2</span>*sums-total))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 防止重复</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(i)</span><br><span class="line">                helper(k+<span class="number">1</span>,sums+stone_list[i])</span><br><span class="line">                seen.discard(i)</span><br><span class="line">    helper(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">stone_list = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> input().split()]</span><br><span class="line">print(solution(stone_list))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组背包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(stone_list)</span>:</span></span><br><span class="line">    n = len(stone_list)</span><br><span class="line">    total = sum(stone_list)</span><br><span class="line">    <span class="comment"># dp[i][v][k] 表示前i个物品中取v次时且重量为k时的总重量</span></span><br><span class="line">    dp = [[float(<span class="string">'-inf'</span>)]*(total//<span class="number">2</span>+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n//<span class="number">2</span>+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(total//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][k] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(n//<span class="number">2</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(total//<span class="number">2</span>,stone_list[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                dp[v][k] = max(dp[v][k],dp[v<span class="number">-1</span>][k-stone_list[i]]+stone_list[i])</span><br><span class="line">    <span class="keyword">return</span> abs(<span class="number">2</span>*dp[<span class="number">-1</span>][<span class="number">-1</span>]-total)</span><br><span class="line"></span><br><span class="line">stone_list = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> input().split()]</span><br><span class="line">print(solution(stone_list))</span><br></pre></td></tr></table></figure>

<h5 id="629-K个逆序对数组"><a href="#629-K个逆序对数组" class="headerlink" title="*629. K个逆序对数组"></a>*<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvay1pbnZlcnNlLXBhaXJzLWFycmF5Lw==" title="https://leetcode-cn.com/problems/k-inverse-pairs-array/">629. K个逆序对数组<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kInversePairs</span><span class="params">(self, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(k+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># dp[i][j] 表示前i个数字组成j个逆序对时的数目</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j&lt;i:</span><br><span class="line">                    dp[i][j] = (dp[i][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j])%(<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = (dp[i][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j] - dp[i<span class="number">-1</span>][j-i])%(<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>



<h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><p>dfs</p>
<h4 id="树的最值路径"><a href="#树的最值路径" class="headerlink" title="树的最值路径"></a>树的最值路径</h4><h5 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbWF4aW11bS1wYXRoLXN1bS8=" title="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># def helper(root):</span></span><br><span class="line">        <span class="comment">#     nonlocal res</span></span><br><span class="line">        <span class="comment">#     if not root:</span></span><br><span class="line">        <span class="comment">#         return 0</span></span><br><span class="line">        <span class="comment">#     left = max(helper(root.left),0)</span></span><br><span class="line">        <span class="comment">#     right = max(helper(root.right),0)</span></span><br><span class="line">        <span class="comment">#     res = max(res,left+root.val+right)</span></span><br><span class="line">        <span class="comment">#     return max(left,right) + root.val # 返回左右最大的一个长度</span></span><br><span class="line">        <span class="comment"># helper(root)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'-inf'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            left = helper(root.left)</span><br><span class="line">            right = helper(root.right)</span><br><span class="line">            res = max(res,left+root.val+right)</span><br><span class="line">            <span class="keyword">return</span> max(<span class="number">0</span>,max(left,right)+root.val)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="树的独立集"><a href="#树的独立集" class="headerlink" title="树的独立集"></a>树的独立集</h4><h5 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaG91c2Utcm9iYmVyLWlpaS8=" title="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">            left_butou,left_tou = dfs(root.left)</span><br><span class="line">            right_butou,right_tou = dfs(root.right)</span><br><span class="line">            <span class="keyword">return</span> max(left_butou+right_butou,left_butou+right_tou,left_tou+right_butou,left_tou+right_tou),left_butou+root.val+right_butou</span><br><span class="line">        <span class="keyword">return</span> max(dfs(root))</span><br></pre></td></tr></table></figure>

<h3 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h3><p>一般是dfs遍历所有情况+剪枝+记忆化，注意状态的对称性(一般这种问题跟排列和图相关)</p>
<p>原意是用二进制的不同位表示不同的状态，再依次做出决策</p>
<h5 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmVhdXRpZnVsLWFycmFuZ2VtZW50Lw==" title="https://leetcode-cn.com/problems/beautiful-arrangement/">526. 优美的排列<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(count)</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> res</span><br><span class="line">            <span class="keyword">if</span> count==N+<span class="number">1</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                    visited[i] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> i%count==<span class="number">0</span> <span class="keyword">or</span> count%i==<span class="number">0</span>:</span><br><span class="line">                        helper(count+<span class="number">1</span>)</span><br><span class="line">                    visited[i] = <span class="literal">False</span></span><br><span class="line">        helper(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="464-我能赢吗"><a href="#464-我能赢吗" class="headerlink" title="464. 我能赢吗"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2FuLWktd2luLw==" title="https://leetcode-cn.com/problems/can-i-win/">464. 我能赢吗<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canIWin</span><span class="params">(self, maxChoosableInteger: int, desiredTotal: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line">        <span class="comment"># 要求值&lt;=可选的最大值</span></span><br><span class="line">        <span class="keyword">if</span> desiredTotal&lt;=maxChoosableInteger:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 所有值之和&lt;要求值</span></span><br><span class="line">        <span class="keyword">if</span> sum(range(<span class="number">1</span>,maxChoosableInteger+<span class="number">1</span>))&lt;desiredTotal:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(used,desiredTotal)</span>:</span></span><br><span class="line">            <span class="comment"># 枚举状态</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(maxChoosableInteger):</span><br><span class="line">                cur = <span class="number">1</span>&lt;&lt;i</span><br><span class="line">                <span class="comment"># &amp;比较是否存在相同的bit位为1</span></span><br><span class="line">                <span class="keyword">if</span> used&amp;cur==<span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># |更新used的bit位</span></span><br><span class="line">                    <span class="comment"># 如果自己选的时候满足要求或者另一个人选的时候为False，则自己为True</span></span><br><span class="line">                    <span class="keyword">if</span> desiredTotal&lt;=i+<span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> helper(used|cur,desiredTotal-i<span class="number">-1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,desiredTotal)</span><br></pre></td></tr></table></figure>

<h5 id="935-骑士拨号器"><a href="#935-骑士拨号器" class="headerlink" title="935. 骑士拨号器"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMva25pZ2h0LWRpYWxlci8=" title="https://leetcode-cn.com/problems/knight-dialer/">935. 骑士拨号器<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">knightDialer</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># stat = &#123;0:[4,6],1:[6,8],2:[7,9],3:[4,8],4:[0,3,9],5:[],6:[0,1,7],7:[2,6],8:[1,3],9:[2,4]&#125;</span></span><br><span class="line">        <span class="comment"># from functools import lru_cache</span></span><br><span class="line">        <span class="comment"># @lru_cache(None)</span></span><br><span class="line">        <span class="comment"># def helper(i,N):</span></span><br><span class="line">        <span class="comment">#     res = 0</span></span><br><span class="line">        <span class="comment">#     if N==0:</span></span><br><span class="line">        <span class="comment">#         res += 1</span></span><br><span class="line">        <span class="comment">#         return res</span></span><br><span class="line">        <span class="comment">#     for j in stat[i]:</span></span><br><span class="line">        <span class="comment">#         res += helper(j,N-1)%(10**9+7)</span></span><br><span class="line">        <span class="comment">#     return res</span></span><br><span class="line">        <span class="comment"># # res = 0</span></span><br><span class="line">        <span class="comment"># # for i in stat.keys():</span></span><br><span class="line">        <span class="comment"># #     res += helper(i,N-1)%(10**9+7)</span></span><br><span class="line">        <span class="comment"># # return res%(10**9+7)</span></span><br><span class="line">        <span class="comment"># return (4*helper(1,N-1) + 2*helper(2,N-1) + 2*helper(6,N-1) + helper(0,N-1) + helper(5,N-1))%(10**9+7)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 画出状态图可知 或由上述的stat a,b,c,d分别为1,2,6,0</span></span><br><span class="line">        <span class="keyword">if</span> N==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">10</span> <span class="comment">#多了一个5</span></span><br><span class="line">        a,b,c,d = <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>,N+<span class="number">1</span>):</span><br><span class="line">            a,b,c,d = b+c,<span class="number">2</span>*a,<span class="number">2</span>*a+d,<span class="number">2</span>*c</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">4</span>*a+<span class="number">2</span>*b+<span class="number">2</span>*c+d)%(<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<h3 id="计数型dp"><a href="#计数型dp" class="headerlink" title="计数型dp"></a>计数型dp</h3><p>可以以组合数学的方法写出组合数，然后dp求组合数</p>
<h5 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzLw==" title="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzLWlpLw==" title="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m,n = len(obstacleGrid),len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][j]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j]==<span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLWJpbmFyeS1zZWFyY2gtdHJlZXMvc29sdXRpb24vYnUtdG9uZy1kZS1lci1jaGEtc291LXN1by1zaHUtYnktbGVldGNvZGUv" title="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/<i class="fa fa-external-link"></i></span></p>
<h5 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLWJpbmFyeS1zZWFyY2gtdHJlZXMv" title="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树<i class="fa fa-external-link"></i></span></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">G(n) = \sum_&#123;i=1&#125;^nF(i,n)  F(i,n) = G(i-1)*G(n-i) ==&gt; G(n) = \sum_&#123;i=1&#125;^n(G(i-1)*G(n-i))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 动规</span></span><br><span class="line">        <span class="comment"># dp = [0 for _ in range(n+1)]</span></span><br><span class="line">        <span class="comment"># dp[0] = 1</span></span><br><span class="line">        <span class="comment"># dp[1] = 1</span></span><br><span class="line">        <span class="comment"># for j in range(2,n+1):</span></span><br><span class="line">        <span class="comment">#     for i in range(1,j+1):</span></span><br><span class="line">        <span class="comment">#         dp[j] += dp[i-1]*dp[j-i]</span></span><br><span class="line">        <span class="comment"># return dp[-1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,j+<span class="number">1</span>):</span><br><span class="line">                ans += helper(i<span class="number">-1</span>)*helper(j-i)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> helper(n)</span><br></pre></td></tr></table></figure>

<h5 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZ2VuZXJhdGUtcGFyZW50aGVzZXMv" title="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># # 可理解为n个1,-1,前i个数中1的个数&gt;=-1的个数</span></span><br><span class="line">        <span class="comment"># def helper(nump,numn,temp):</span></span><br><span class="line">        <span class="comment">#     if nump==0:</span></span><br><span class="line">        <span class="comment">#         res.append(temp+')'*numn)</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">#     if nump&gt;numn:</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">#     helper(nump-1,numn,temp+'(')</span></span><br><span class="line">        <span class="comment">#     helper(nump,numn-1,temp+')')</span></span><br><span class="line">        <span class="comment"># helper(n,n,"")</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># dp[i] = "(" + dp[j] + ")" + dp[i-1-j]  j=0,1,...i-1; i=1,2,...,n</span></span><br><span class="line">        <span class="comment"># 即由前一个排列,按照从左到右加入括号</span></span><br><span class="line">        dp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = [<span class="string">""</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="comment"># 由dp[j]中的各种排列和dp[i-1-j]的各种排列相互组合</span></span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> dp[j]:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> dp[i<span class="number">-1</span>-j]:</span><br><span class="line">                        temp.append(<span class="string">"("</span>+l+<span class="string">")"</span>+r)</span><br><span class="line">            dp[i] = temp</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h5 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC12YWxpZC1wYXJlbnRoZXNlcy8=" title="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># # 栈 O(nlogn)</span></span><br><span class="line">        <span class="comment"># stack = []</span></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># for i in range(len(s)):</span></span><br><span class="line">        <span class="comment">#     if s[i]=='(':</span></span><br><span class="line">        <span class="comment">#         stack.append(i)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         if stack:</span></span><br><span class="line">        <span class="comment">#             res.extend([stack.pop(),i])</span></span><br><span class="line">        <span class="comment"># res.sort()</span></span><br><span class="line">        <span class="comment"># ans = 0</span></span><br><span class="line">        <span class="comment"># i = 0</span></span><br><span class="line">        <span class="comment"># while i&lt;len(res):</span></span><br><span class="line">        <span class="comment">#     j = i+1</span></span><br><span class="line">        <span class="comment">#     while j&lt;len(res) and res[j-1]+1==res[j]:</span></span><br><span class="line">        <span class="comment">#         j += 1</span></span><br><span class="line">        <span class="comment">#     ans = max(ans,j-i)</span></span><br><span class="line">        <span class="comment">#     i = j</span></span><br><span class="line">        <span class="comment"># return ans</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="comment"># # 栈 O(n)</span></span><br><span class="line">        <span class="comment"># stack = [-1]</span></span><br><span class="line">        <span class="comment"># res = 0</span></span><br><span class="line">        <span class="comment"># for i in range(len(s)):</span></span><br><span class="line">        <span class="comment">#     if s[i]=='(':</span></span><br><span class="line">        <span class="comment">#         stack.append(i)</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         stack.pop()</span></span><br><span class="line">        <span class="comment">#         if not stack:</span></span><br><span class="line">        <span class="comment">#             stack.append(i)</span></span><br><span class="line">        <span class="comment">#         res = max(res,i-stack[-1])</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动规</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> s[i]==<span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>]==<span class="string">'('</span>:</span><br><span class="line">                    dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 即与i-1右括号匹配的左括号的前一位置为i-1-dp[i-1]</span></span><br><span class="line">                    <span class="keyword">if</span> i<span class="number">-1</span>-dp[i<span class="number">-1</span>]&gt;=<span class="number">0</span> <span class="keyword">and</span> s[i<span class="number">-1</span>-dp[i<span class="number">-1</span>]]==<span class="string">'('</span>:</span><br><span class="line">                        <span class="comment"># 即 ...((....)) 则把dp[i-1]的长度(即i-dp[i-1]到i-1) + dp[i-dp[i-1]-2]的长度(即i-1-dp[i-1]前面可能的长度) + 一对括号(即i-1-dp[i-1]与当前i)</span></span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>] + <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>



<h3 id="递推型dp"><a href="#递推型dp" class="headerlink" title="递推型dp"></a>递推型dp</h3><p>所有线性递推关系都可以用矩阵快速幂做，可以O(logN)，最典型是斐波那契数列</p>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>由$f(n)=f(n-1)+f(n-2),f(0)=1,f(1)=1,f(2)=2$推出$F_n=1/\sqrt{5}[(\frac{1+\sqrt{5}}{2})^n−(\frac{1-\sqrt{5}}{2})^n]$</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcHJpc29uLWNlbGxzLWFmdGVyLW4tZGF5cy8=" title="https://leetcode-cn.com/problems/prison-cells-after-n-days/">957. N 天后的牢房<i class="fa fa-external-link"></i></span></p>
<h3 id="概率型dp"><a href="#概率型dp" class="headerlink" title="概率型dp"></a>概率型dp</h3><h5 id="808-分汤"><a href="#808-分汤" class="headerlink" title="808. 分汤"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc291cC1zZXJ2aW5ncy8=" title="https://leetcode-cn.com/problems/soup-servings/">808. 分汤<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">soupServings</span><span class="params">(self, N: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="comment"># ##############</span></span><br><span class="line">        <span class="keyword">if</span> N&gt;=<span class="number">500</span>*<span class="number">25</span>: <span class="keyword">return</span> <span class="number">1.</span></span><br><span class="line">        hash_ = &#123;(<span class="number">100</span>,<span class="number">0</span>),(<span class="number">75</span>,<span class="number">25</span>),(<span class="number">50</span>,<span class="number">50</span>),(<span class="number">25</span>,<span class="number">75</span>)&#125;</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(na,nb)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> na&lt;=<span class="number">0</span> <span class="keyword">and</span> nb&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">            <span class="keyword">if</span> na&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.</span></span><br><span class="line">            <span class="keyword">if</span> nb&lt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i,j <span class="keyword">in</span> hash_:</span><br><span class="line">                ans += helper(na-i,nb-j)</span><br><span class="line">            <span class="keyword">return</span> ans*<span class="number">0.25</span></span><br><span class="line">        <span class="keyword">return</span> helper(N,N)</span><br></pre></td></tr></table></figure>

<h5 id="837-新21点"><a href="#837-新21点" class="headerlink" title="837. 新21点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmV3LTIxLWdhbWUv" title="https://leetcode-cn.com/problems/new-21-game/">837. 新21点<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(self, N: int, K: int, W: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> K==<span class="number">0</span>: <span class="keyword">return</span> <span class="number">1.</span></span><br><span class="line">        dp = [<span class="number">0.</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(K+W)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K,min(N,K+W<span class="number">-1</span>)+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="number">1.</span></span><br><span class="line">        dp[K<span class="number">-1</span>] = (min(N,K+W<span class="number">-1</span>)-K+<span class="number">1</span>)/W</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            dp[i] = dp[i+<span class="number">1</span>] + (dp[i+<span class="number">1</span>]-dp[i+W+<span class="number">1</span>])/W</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="博弈型dp"><a href="#博弈型dp" class="headerlink" title="博弈型dp"></a>博弈型dp</h3><p>dfs+记忆化有时更简单</p>
<h5 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbmltLWdhbWUv" title="https://leetcode-cn.com/problems/nim-game/">292. Nim 游戏<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># if n&lt;=3:</span></span><br><span class="line">        <span class="comment">#     return True</span></span><br><span class="line">        <span class="comment"># dp = [False for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># dp[0] = dp[1] = dp[2] = True</span></span><br><span class="line">        <span class="comment"># for i in range(3,n):</span></span><br><span class="line">        <span class="comment">#     dp[i] = True if not dp[i-1] or not dp[i-2] or not dp[i-3] else False</span></span><br><span class="line">        <span class="comment"># return dp[-1]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">4</span>!=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3RvbmUtZ2FtZS8=" title="https://leetcode-cn.com/problems/stone-game/">877. 石子游戏<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(self, piles: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># n = len(piles)</span></span><br><span class="line">        <span class="comment"># dp = [[[0,0] for _ in range(n)] for _ in range(n)]</span></span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     dp[i][i][0] = piles[i]</span></span><br><span class="line">        <span class="comment"># for i in range(n-1,-1,-1):</span></span><br><span class="line">        <span class="comment">#     for j in range(i+1,n):</span></span><br><span class="line">        <span class="comment">#         # 先手选择左边或右边，然后成为后手</span></span><br><span class="line">        <span class="comment">#         left,right = piles[i]+dp[i+1][j][1],piles[j]+dp[i][j-1][1]</span></span><br><span class="line">        <span class="comment">#         dp[i][j][0] = max(left,right)</span></span><br><span class="line">        <span class="comment">#         # 先手选择了左边，则后手成了左边之外的先手</span></span><br><span class="line">        <span class="comment">#         if dp[i][j][0]==left:</span></span><br><span class="line">        <span class="comment">#             dp[i][j][1] = dp[i+1][j][0]</span></span><br><span class="line">        <span class="comment">#         # 先手选择了右边，则后手成了右边之外的先手</span></span><br><span class="line">        <span class="comment">#         elif dp[i][j][0]==right:</span></span><br><span class="line">        <span class="comment">#             dp[i][j][1] = dp[i][j-1][0]</span></span><br><span class="line">        <span class="comment"># return dp[0][n-1][0]&gt;dp[0][n-1][1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        n = len(piles)</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;j: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i==j: <span class="keyword">return</span> piles[i]</span><br><span class="line">            <span class="comment"># 先手选左边，后手会使先手再次选的时候最小</span></span><br><span class="line">            left = piles[i] + min(dp(i+<span class="number">2</span>,j),dp(i+<span class="number">1</span>,j<span class="number">-1</span>))</span><br><span class="line">            <span class="comment"># 先手选右边，后手会使先手再次选的时候最小</span></span><br><span class="line">            right = piles[j] + min(dp(i,j<span class="number">-2</span>),dp(i+<span class="number">1</span>,j<span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span> max(left,right)</span><br><span class="line">        res = dp(<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res&gt;sum(piles)-res</span><br></pre></td></tr></table></figure>

<h5 id="1140-石子游戏-II"><a href="#1140-石子游戏-II" class="headerlink" title="1140. 石子游戏 II"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3RvbmUtZ2FtZS1paS8=" title="https://leetcode-cn.com/problems/stone-game-ii/">1140. 石子游戏 II<i class="fa fa-external-link"></i></span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stoneGameII</span><span class="params">(self, piles: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(piles)</span><br><span class="line">        sums = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        sums[<span class="number">1</span>] = piles[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            sums[i+<span class="number">1</span>] = sums[i] + piles[i]</span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">        @lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i,M)</span>:</span></span><br><span class="line">            <span class="comment"># 超过n时</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;n: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 剩下元素小于2*M时，直接取完</span></span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">2</span>*M&gt;n: <span class="keyword">return</span> sums[n]-sums[i]</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 否则取x使得元素能够最大(后续的总值-后手能取的最大值)</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">2</span>*M+<span class="number">1</span>):</span><br><span class="line">                cur = max(cur,sums[n]-sums[i]-dp(i+x,max(M,x)))</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2020/09/08/%E6%B1%82%E8%81%8C-%E7%BC%96%E7%A8%8B-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUy1ramVZaXg0UHV0NlhxQXhfZlNiQQ==" title="https://mp.weixin.qq.com/s/S-kjeYix4Put6XqAx_fSbA">https://mp.weixin.qq.com/s/S-kjeYix4Put6XqAx_fSbA<i class="fa fa-external-link"></i></span></p>
<p><img src="D:/projects/github/my_notes/please_job/leetcode/pics/1583201065811.png" alt="1583201065811"></p>
<a id="more"></a>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<p>即两两比较相邻元素，若反序则交换。</p>
<p>时间复杂度：O(n**2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j]&gt;arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j],arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>],arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><hr>
<p>即每次比较选出一个最值。</p>
<p>时间复杂度：O(n**2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SelectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 记录最小数的位置</span></span><br><span class="line">        min_loc = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j]&lt;arr[min_loc]:</span><br><span class="line">                min_loc = j</span><br><span class="line">        <span class="comment"># 当最小数不是初始位置时，交换</span></span><br><span class="line">        <span class="keyword">if</span> i != min_loc:</span><br><span class="line">            arr[i],arr[min_loc] = arr[min_loc],arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr>
<p>即每次插入一个新元素，查找比较其应该插入的位置</p>
<p>时间复杂度：O(n**2)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">InsertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="comment"># 标记出要插入的位置</span></span><br><span class="line">        pre_idx = i<span class="number">-1</span></span><br><span class="line">        current = arr[i]</span><br><span class="line">        <span class="keyword">while</span> pre_idx&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[pre_idx]&gt;current:</span><br><span class="line">            arr[pre_idx+<span class="number">1</span>] = arr[pre_idx]</span><br><span class="line">            pre_idx -= <span class="number">1</span></span><br><span class="line">        arr[pre_idx+<span class="number">1</span>] = current</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr>
<p>即缩小增量排序，是插入排序的改进。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 希尔排序（插入的改进）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ShellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    gap = len(arr)//<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,len(arr)):</span><br><span class="line">            pre_idx = i-gap</span><br><span class="line">            current = arr[i]</span><br><span class="line">            <span class="keyword">while</span> pre_idx&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[pre_idx]&gt;current:</span><br><span class="line">                arr[pre_idx+gap] = arr[pre_idx]</span><br><span class="line">                pre_idx -= gap</span><br><span class="line">            arr[pre_idx+gap] = current</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr>
<p>即先依次分割排序序列，再两两比较合并。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(n)</p>
<p>迭代版本会更好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归并排序递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 归并排序</span></span><br><span class="line">    <span class="keyword">if</span> len(arr)==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    mid = len(arr)//<span class="number">2</span></span><br><span class="line">    left = arr[:mid]</span><br><span class="line">    right = arr[mid:]</span><br><span class="line">    <span class="keyword">return</span> merge(MergeSort(left),MergeSort(right))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">    rst = []</span><br><span class="line">    <span class="comment"># 两个序列元素均存在时，判断取两个序列中的哪一个</span></span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>]:</span><br><span class="line">            rst.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rst.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="comment"># 只有一个序列元素存在时，直接接上</span></span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        rst += left</span><br><span class="line">    <span class="keyword">if</span> right:</span><br><span class="line">        rst += right</span><br><span class="line">    <span class="keyword">return</span> rst</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归并排序迭代</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    i = <span class="number">1</span> <span class="comment">#步长</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;len(arr):</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low&lt;len(arr):</span><br><span class="line">            mid = low + i</span><br><span class="line">            high = min(low+<span class="number">2</span>*i,len(arr))</span><br><span class="line">            <span class="keyword">if</span> mid&lt;high:</span><br><span class="line">                merge(arr,low,mid,high)</span><br><span class="line">            low += <span class="number">2</span>*i</span><br><span class="line">        i *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arr,low,mid,high)</span>:</span></span><br><span class="line">    left = arr[low:mid]</span><br><span class="line">    right = arr[mid:high]</span><br><span class="line">    rst = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>]&lt;=right[<span class="number">0</span>]:</span><br><span class="line">            rst.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rst.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        rst += left</span><br><span class="line">    <span class="keyword">if</span> right:</span><br><span class="line">        rst += right</span><br><span class="line">    arr[low:high] = rst</span><br></pre></td></tr></table></figure>





<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(l,r)</span>:</span></span><br><span class="line">        t = random.randint(l,r)</span><br><span class="line">        nums[t],nums[l] = nums[l],nums[t]</span><br><span class="line">        pivot = nums[l]</span><br><span class="line">        idx,i = l+<span class="number">1</span>,l+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=r:</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;pivot:</span><br><span class="line">                nums[i],nums[idx] = nums[idx],nums[i]</span><br><span class="line">                idx += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        nums[idx<span class="number">-1</span>],nums[l] = pivot,nums[idx<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> idx<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quicksort_</span><span class="params">(l,r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l&lt;r:</span><br><span class="line">            idx = partition(l,r)</span><br><span class="line">            quicksort_(l,idx<span class="number">-1</span>)</span><br><span class="line">            quicksort_(idx+<span class="number">1</span>,r)</span><br><span class="line">    </span><br><span class="line">    quicksort_(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(l,r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l==r:</span><br><span class="line">            <span class="keyword">return</span> [nums[l]]</span><br><span class="line">        mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">        nums1 = Merge(l,mid)</span><br><span class="line">        nums2 = Merge(mid+<span class="number">1</span>,r)</span><br><span class="line">        <span class="keyword">return</span> merge(nums1,nums2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums1,nums2)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(nums1) <span class="keyword">and</span> j&lt;len(nums2):</span><br><span class="line">            <span class="keyword">if</span> nums1[i]&lt;=nums2[j]:</span><br><span class="line">                res.append(nums1[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(nums2[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;len(nums1):</span><br><span class="line">            res += nums1[i:]</span><br><span class="line">        <span class="keyword">if</span> j&lt;len(nums2):</span><br><span class="line">            res += nums2[j:]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Merge(<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">print(quicksort(nums))</span><br><span class="line">print(mergesort(nums))</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr>
<p>即选择一个基准值，分成左右两部分，再递归，是冒泡排序的改进。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(logn)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="comment"># 新建存储</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort</span><span class="params">(arr,rst=[])</span>:</span></span><br><span class="line">    mid = len(arr)//<span class="number">2</span> <span class="comment">#选取中间值为基准</span></span><br><span class="line">    left = []</span><br><span class="line">    right = []</span><br><span class="line">    <span class="keyword">if</span> arr:</span><br><span class="line">        pivot = arr.pop(mid)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="keyword">if</span> i&lt;pivot:</span><br><span class="line">                left.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right.append(i)</span><br><span class="line">        QuickSort(left,rst)</span><br><span class="line">        rst.append(pivot)</span><br><span class="line">        QuickSort(right,rst)</span><br><span class="line"></span><br><span class="line">rst = []</span><br><span class="line">QuickSort(arr,rst)</span><br><span class="line">print(rst)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 原数组存储</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">QuickSort1</span><span class="params">(arr,left=<span class="number">0</span>,right=<span class="number">-1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left&lt;right:</span><br><span class="line">        idx = partition(arr,left,right)</span><br><span class="line">        QuickSort1(arr,left,idx<span class="number">-1</span>)</span><br><span class="line">        QuickSort1(arr,idx+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr,left,right)</span>:</span></span><br><span class="line">    pivot = arr[left] <span class="comment">#选取最左边值为基准</span></span><br><span class="line">    idx = left+<span class="number">1</span></span><br><span class="line">    i = idx</span><br><span class="line">    <span class="comment"># i每次加1,idx满足条件时+1,idx表示要插入的位置的后一个</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=right:</span><br><span class="line">        <span class="keyword">if</span> arr[i]&lt;pivot:</span><br><span class="line">            arr[i],arr[idx] = arr[idx],arr[i]</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    arr[idx<span class="number">-1</span>],arr[left] = pivot,arr[idx<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> idx<span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">print(QuickSort1(arr,<span class="number">0</span>,<span class="number">-1</span>))</span><br></pre></td></tr></table></figure>



<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr>
<p>即将序列构造成一个堆，根结点为最值，取根结点，并将根结点和尾结点交换再重新构造。</p>
<p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 堆排序 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</span></span><br><span class="line"><span class="comment"># 堆调整</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(arr,i)</span>:</span></span><br><span class="line">    <span class="comment"># 对结点i，则其左子结点为2i+1,右子结点为2i+2,父结点为(i-1)//2</span></span><br><span class="line">    left = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    right = <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">    largest = i</span><br><span class="line">    <span class="keyword">if</span> left&lt;len(arr) <span class="keyword">and</span> arr[left]&gt;arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line">    <span class="keyword">if</span> right&lt;len(arr) <span class="keyword">and</span> arr[right]&gt;arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i],arr[largest] =  arr[largest],arr[i]</span><br><span class="line">        heapify(arr,largest) <span class="comment">#当交换时，再次从交换的结点开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BuildHeap</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 自下而上的调整</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(arr))):</span><br><span class="line">        heapify(arr,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HeapSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    print(arr)</span><br><span class="line">    BuildHeap(arr)</span><br><span class="line">    print(arr)</span><br><span class="line">    <span class="comment"># 取堆顶再交换堆尾</span></span><br><span class="line">    rst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        arr[<span class="number">0</span>],arr[<span class="number">-1</span>] = arr[<span class="number">-1</span>],arr[<span class="number">0</span>]</span><br><span class="line">        rst.insert(<span class="number">0</span>,arr.pop())</span><br><span class="line">        heapify(arr,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line">            </span><br><span class="line">print(HeapSort(arr))</span><br></pre></td></tr></table></figure>



<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CountSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    min_e = min(arr)</span><br><span class="line">    max_e = max(arr)</span><br><span class="line">    count_list = [<span class="number">0</span>]*(max_e-min_e+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 遍历arr计数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        count_list[i-min_e] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 遍历count_list还原</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(count_list)):</span><br><span class="line">        <span class="keyword">while</span> count_list[i]&gt;<span class="number">0</span>:</span><br><span class="line">            arr[j] = min_e+i</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            count_list[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BucketSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    min_e = min(arr)</span><br><span class="line">    max_e = max(arr)</span><br><span class="line">    <span class="comment"># 桶的大小，可理解为每个桶的范围，共有len(arr)个桶</span></span><br><span class="line">    size = (max_e-min_e)/len(arr)</span><br><span class="line">    <span class="comment"># 桶的数组</span></span><br><span class="line">    count_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(arr)+<span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 遍历放入桶</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        count_list[int((i-min_e)//size)].append(i)</span><br><span class="line">    <span class="comment"># 桶内排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_list:</span><br><span class="line">        i.sort()</span><br><span class="line">    <span class="comment"># 从桶放回数组</span></span><br><span class="line">    arr.clear()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_list:</span><br><span class="line">        arr += i</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>



<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RadixSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="comment"># 判断是几位数，设置几个基</span></span><br><span class="line">    max_e = max(arr)</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> max_e!=<span class="number">0</span>:</span><br><span class="line">        max_e = max_e//<span class="number">10</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 循环每个基</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">        <span class="comment"># 放入桶内0-9</span></span><br><span class="line">        count_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">            loc = j//<span class="number">10</span>**i%<span class="number">10</span> <span class="comment">#取每个位数</span></span><br><span class="line">            count_list[loc].append(j)</span><br><span class="line">        <span class="comment"># 放回数组，桶中先进先出</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> count_list:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> j:</span><br><span class="line">                arr[n] = m</span><br><span class="line">                n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title>面试记录</title>
    <url>/2020/09/07/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h1><h3 id="4-14-一面-TEG-AI平台部-游戏AI算法-电话面-84min"><a href="#4-14-一面-TEG-AI平台部-游戏AI算法-电话面-84min" class="headerlink" title="4.14 一面 TEG-AI平台部-游戏AI算法 电话面 84min"></a>4.14 一面 TEG-AI平台部-游戏AI算法 电话面 84min</h3><a id="more"></a>

<p>自我介绍</p>
<p>项目介绍及相关细节</p>
<p>cyclegan的原理</p>
<p>交叉熵</p>
<p>GAN loss的推导</p>
<p>梯度消失/梯度爆炸的原因</p>
<p>sigmoid,relu,tanh的演进</p>
<p>怎样挑选卷积核大小，感受野作用</p>
<p>pooling的作用</p>
<p>防止过拟合的方法</p>
<p>l2范数改进了l1范数的地方，举例</p>
<p>dropout作用</p>
<p>lstm,强化学习</p>
<p><strong>编程题：两相交链表(两种空间复杂度o(1)的方法)</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlhbmctZ2UtbGlhbi1iaWFvLWRlLWRpLXlpLWdlLWdvbmctZ29uZy1qaWUtZGlhbi1sY29mLw==" title="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">面试题52. 两个链表的第一个公共节点<i class="fa fa-external-link"></i></span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ListNode* l1 = headA;</span></span><br><span class="line">        <span class="comment">// ListNode* l2 = headB;</span></span><br><span class="line">        <span class="comment">// while (l1 != l2) &#123;</span></span><br><span class="line">        <span class="comment">//     if (l1) l1 = l1-&gt;next;</span></span><br><span class="line">        <span class="comment">//     else l1 = headB;</span></span><br><span class="line">        <span class="comment">//     if (l2) l2 = l2-&gt;next;</span></span><br><span class="line">        <span class="comment">//     else l2 = headA;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return l1;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ListNode* l1 = headA;</span><br><span class="line">        ListNode* l2 = headB;</span><br><span class="line">        <span class="keyword">int</span> sizeA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            sizeA++;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sizeB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            sizeB++;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sizeA&gt;sizeB) &#123;</span><br><span class="line">            n = sizeA - sizeB;</span><br><span class="line">            <span class="keyword">while</span> (n) &#123;</span><br><span class="line">                headA = headA-&gt;next;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sizeB&gt;sizeA) &#123;</span><br><span class="line">            n = sizeB - sizeA;</span><br><span class="line">            <span class="keyword">while</span> (n) &#123;</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (headA!=headB) &#123;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">            headB = headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="8-17-PCG-QQ浏览器-QQ看点-一面-视频面-65min"><a href="#8-17-PCG-QQ浏览器-QQ看点-一面-视频面-65min" class="headerlink" title="8.17 PCG QQ浏览器/QQ看点 一面 视频面 65min"></a>8.17 PCG QQ浏览器/QQ看点 一面 视频面 65min</h3><p>自我介绍</p>
<p>相关项目</p>
<p>wordvec了解吗，词嵌入了解吗(不会，然后说了图嵌入的思想，但具体的也记不住了)</p>
<p>python中全局解释器锁，线性池</p>
<p>c++中红黑树及优缺点，map和unordered_map</p>
<p>hash冲突的两种解决方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">已知某推荐系统每日有M次曝光机会，有N篇候选文章。假设一篇文章需曝光 x_i 次才可转化为y_i次点击。不够x_i次则无点击。</span><br><span class="line">（<span class="number">1</span>）请求出该推荐系统每日最大点击量</span><br><span class="line">（<span class="number">2</span>）最大点击量情况下的文章曝光分布（任意一种合理即可）</span><br><span class="line">（<span class="number">3</span>）如果每篇文章限制最大曝光z_i次，此时的最大点击量是多少</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(x,y,M,N)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(M+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(x[i],M+<span class="number">1</span>):</span><br><span class="line">            dp[j] = max(dp[j],dp[j-x[i]]+y[i])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)</span><br><span class="line">即在第一问的基础上，求转移路径即转移矩阵(而我在这蠢了，疯狂试探：先说了类似高斯混合模型，再说了贝叶斯公式反推)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(x,y,z,M,N)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(M+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> range(M,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            k = min(M//x[i],z[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k+<span class="number">1</span>):</span><br><span class="line">                dp[v] = max(dp[v],dp[v-j*x[i]]+j*y[i])</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>









<h1 id="阿里巴巴-创新业务群-vmate事业部-机器学习算法"><a href="#阿里巴巴-创新业务群-vmate事业部-机器学习算法" class="headerlink" title="阿里巴巴 创新业务群 vmate事业部 机器学习算法"></a>阿里巴巴 创新业务群 vmate事业部 机器学习算法</h1><h3 id="4-27-一面-视频面75min-主做海外短视频推荐"><a href="#4-27-一面-视频面75min-主做海外短视频推荐" class="headerlink" title="4.27 一面 视频面75min 主做海外短视频推荐"></a>4.27 一面 视频面75min 主做海外短视频推荐</h3><p>自我介绍</p>
<p>项目介绍及相关细节</p>
<p>GAN的工作原理，从输入到输出的整个流程，卷积层的工作原理，什么时候补0，为什么补0，卷积层特征4个维度的含义，通道数的变化，和卷积特征变化的关系，如何变为全连接的二维(直接和gap)，sigmoid的工作原理</p>
<p>人脸老化的工作原理及改进</p>
<p>tensorflow和pytorch的区别</p>
<p>dropout的原理，变分dropout的区别及好处，计算损失函数的流程</p>
<p>熟悉的机器学习算法：说了个EM，解释了EM的原理</p>
<p>python 常见的数据结构，range和xrange的区别，lambda函数的用法，类中self的意义</p>
<p>编程题：</p>
<ul>
<li>给定一个数组和一个数，找出所有满足和为这个数的子序列</li>
<li>一个有序重复的数组，给一个数N，找出N在数组中的起点位置和重点位置</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1hbmQtbGFzdC1wb3NpdGlvbi1vZi1lbGVtZW50LWluLXNvcnRlZC1hcnJheS8=" title="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        res = [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        left,right = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;target:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">        res[<span class="number">0</span>] = left <span class="keyword">if</span> nums[left]==target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        right = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = (left+right+<span class="number">1</span>)&gt;&gt;<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">                right = mid<span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        res[<span class="number">1</span>] = left <span class="keyword">if</span> nums[left]==target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>()==<span class="number">0</span>) &#123;</span><br><span class="line">            res.emplace_back(<span class="number">-1</span>);</span><br><span class="line">            res.emplace_back(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;target) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left]==target) res.emplace_back(left);</span><br><span class="line">        <span class="keyword">else</span> res.emplace_back(<span class="number">-1</span>);</span><br><span class="line">        right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;target) right = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left]==target) res.emplace_back(left);</span><br><span class="line">        <span class="keyword">else</span> res.emplace_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="4-28-二面-电话面35min"><a href="#4-28-二面-电话面35min" class="headerlink" title="4.28 二面  电话面35min"></a>4.28 二面  电话面35min</h3><p>自我介绍</p>
<p>dropout的相关原理，变分dropout怎样做模型压缩，做权值压缩时保存和加载时的数据量，结构化压缩</p>
<p>图像生成项目中GAN的流程</p>
<p>GAN的现实应用背景</p>
<p>一副扑克牌54张，红黑各一半，从里面任意抽两张，为一红一黑的可能性是多少？ 27/53</p>
<p>用c++写一个不能被继承的类</p>
<p>编程题：输入一个整型数组，数组里有正数也有负数，数组中的一个或连续多个整数组成一个子数组，求所有子数组的和的最大值</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=" title="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># res = float('-inf')</span></span><br><span class="line">        <span class="comment"># cur = 0</span></span><br><span class="line">        <span class="comment"># for i in nums:</span></span><br><span class="line">        <span class="comment">#     cur = max(cur+i,i)</span></span><br><span class="line">        <span class="comment">#     res = max(res,cur)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 分治，在分的时候判断组内，在合的时候判断组间</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(nums,left,right)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left==right:</span><br><span class="line">                <span class="keyword">return</span> nums[left]</span><br><span class="line">            mid = (left+right)&gt;&gt;<span class="number">1</span></span><br><span class="line">            maxleft = Merge(nums,left,mid)</span><br><span class="line">            maxright = Merge(nums,mid+<span class="number">1</span>,right)</span><br><span class="line">            maxcross = merge(nums,left,mid,right)</span><br><span class="line">            <span class="keyword">return</span> max(maxleft,maxright,maxcross)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从mid向两边扩散</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums,left,mid,right)</span>:</span></span><br><span class="line">            leftres,cur = float(<span class="string">'-inf'</span>),<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(mid,left<span class="number">-1</span>,<span class="number">-1</span>): <span class="comment"># 包含mid时则不需要return时的判断</span></span><br><span class="line">            <span class="comment"># for i in range(mid-1,left-1,-1):</span></span><br><span class="line">                cur += nums[i]</span><br><span class="line">                leftres = max(cur,leftres)</span><br><span class="line">            rightres,cur = float(<span class="string">'-inf'</span>),<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(mid+<span class="number">1</span>,right+<span class="number">1</span>):</span><br><span class="line">                cur += nums[i]</span><br><span class="line">                rightres = max(cur,rightres)</span><br><span class="line">            <span class="keyword">return</span> leftres+rightres</span><br><span class="line">            <span class="comment"># return max(nums[mid],leftres+nums[mid],nums[mid]+rightres,leftres+nums[mid]+rightres)</span></span><br><span class="line">        <span class="keyword">return</span> Merge(nums,<span class="number">0</span>,len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>



<h1 id="拼多多-推荐算法"><a href="#拼多多-推荐算法" class="headerlink" title="拼多多  推荐算法"></a>拼多多  推荐算法</h1><h3 id="5-9-一面-视频面55min-主做app首页推荐"><a href="#5-9-一面-视频面55min-主做app首页推荐" class="headerlink" title="5.9 一面 视频面55min 主做app首页推荐"></a>5.9 一面 视频面55min 主做app首页推荐</h3><p>自我介绍</p>
<p>图像生成项目及人脸老化项目介绍</p>
<p>EM算法</p>
<p>编程题：对一个有序链表，如1-&gt;2-&gt;2-&gt;3-&gt;4-&gt;4-&gt;4-&gt;5-&gt;null，删除所有重复元素变为1-&gt;3-&gt;5-&gt;null</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmVtb3ZlLWR1cGxpY2F0ZXMtZnJvbS1zb3J0ZWQtbGlzdC1paS8=" title="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        first = ListNode(float(<span class="string">'-inf'</span>))</span><br><span class="line">        first.next = head</span><br><span class="line">        l,r = first,first.next</span><br><span class="line">        pre = first</span><br><span class="line">        <span class="keyword">while</span> r:</span><br><span class="line">            <span class="keyword">if</span> r.val==l.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> r.next <span class="keyword">or</span> (r.next <span class="keyword">and</span> r.next.val!=l.val):</span><br><span class="line">                    pre.next = r.next</span><br><span class="line">                    l = pre</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = l</span><br><span class="line">                l = l.next</span><br><span class="line">            r = r.next</span><br><span class="line">        <span class="keyword">return</span> first.next</span><br></pre></td></tr></table></figure>





<h3 id="5-12-二面-视频面-42min"><a href="#5-12-二面-视频面-42min" class="headerlink" title="5.12 二面 视频面 42min"></a>5.12 二面 视频面 42min</h3><p>自我介绍</p>
<p>线程/进程的区别</p>
<p>内存存储时堆区/栈区的区别</p>
<p>数组/链表的区别，比如存储图像数据时选用哪个</p>
<p>精确率、准确率、召回率、F1的公式</p>
<p>KL距离的公式</p>
<p>交叉熵的公式</p>
<p>GAN的结构与原理，池化的作用，全连接层的作用</p>
<p>编程题：给定一个没有重复数字的序列，返回其所有可能的全排列</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==" title="https://leetcode-cn.com/problems/permutations/">46. 全排列<i class="fa fa-external-link"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="comment"># 中间变量过多</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(nums,path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                res.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                dfs(nums[:i]+nums[i+<span class="number">1</span>:],path+[nums[i]])</span><br><span class="line">        dfs(nums,[])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="comment"># res = []</span></span><br><span class="line">        <span class="comment"># visited = set()</span></span><br><span class="line">        <span class="comment"># n = len(nums)</span></span><br><span class="line">        <span class="comment"># def dfs(nums,path,d):</span></span><br><span class="line">        <span class="comment">#     if n==d:</span></span><br><span class="line">        <span class="comment">#         res.append(path[:])</span></span><br><span class="line">        <span class="comment">#         return</span></span><br><span class="line">        <span class="comment">#     for i in range(len(nums)):</span></span><br><span class="line">        <span class="comment">#         if nums[i] not in visited:</span></span><br><span class="line">        <span class="comment">#             visited.add(nums[i])</span></span><br><span class="line">        <span class="comment">#             path.append(nums[i])</span></span><br><span class="line">        <span class="comment">#             dfs(nums,path,d+1)</span></span><br><span class="line">        <span class="comment">#             path.pop()</span></span><br><span class="line">        <span class="comment">#             visited.remove(nums[i])</span></span><br><span class="line">        <span class="comment"># dfs(nums,[],0)</span></span><br><span class="line">        <span class="comment"># return res</span></span><br></pre></td></tr></table></figure>





<h3 id="8-14-一面-视频面-50min"><a href="#8-14-一面-视频面-50min" class="headerlink" title="8.14 一面 视频面 50min"></a>8.14 一面 视频面 50min</h3><p>编程：判断一个数是否对称，不允许将数字转换成字符串比较</p>
<p>编程：输入一个递增的数组和一个数组X，在数组中查找两个数，使得他们的和正好是X，如果有多对数字的和等于X，输出两个数的乘积最小的(证明为什么第一次遇到就可以退出)</p>
<p>项目介绍(图像生成项目的介绍，dropout实验的原因，效果等等)</p>
<p>变分推断的原理</p>
<p>对于连续的年龄特征，如何进行特征处理(一般来说，两种区别，一个是等间隔，一个是等数量)</p>
<p>欠拟合过拟合如何判断，解决方法</p>
<p>线程和进程的区别，通信的方式</p>
<p>互斥锁和读写锁的区别</p>
<p>tcp和udp的区别</p>
<p>tcp/ip协议</p>
<p>什么是平衡二叉树，平衡二叉树是由什么实现的(红黑树)</p>
<p>vector是基于什么实现的</p>
<p>hash冲突的解决方法</p>
<p>map和unordered_map的区别及底层实现</p>
<p>数组和链表的优缺点</p>
<p>LR的介绍，sigmoid函数，损失函数，如何应用在线性不可分数据</p>
<p>决策树ID3和C4.5的区别</p>
<h3 id="8-22-二面-视频面-50min"><a href="#8-22-二面-视频面-50min" class="headerlink" title="8.22 二面 视频面 50min"></a>8.22 二面 视频面 50min</h3><p>自我介绍</p>
<p>dropout的动机，GAN的原理，loss等，KL的公式</p>
<p>SVM的流程(从决策平面，动机到损失函数等公式推导)，SMO算法</p>
<p>resnet的流程，用公式表示</p>
<p>算法题：输入一个数组和一个数字，求所有子序和为K的数组的个数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(nums,K)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,cursum)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> res</span><br><span class="line">        <span class="keyword">if</span> i==len(nums):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cursum==K:</span><br><span class="line">            print(visited)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># if cursum&lt;K:</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add(j)</span><br><span class="line">                helper(j,cursum+nums[j])</span><br><span class="line">                visited.remove(j)</span><br><span class="line">    helper(<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(solver([<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>],<span class="number">10</span>))</span><br></pre></td></tr></table></figure>



<h1 id="京东-技术中台-北京"><a href="#京东-技术中台-北京" class="headerlink" title="京东 技术中台 北京"></a>京东 技术中台 北京</h1><h3 id="7-14-一面-视频面-20min"><a href="#7-14-一面-视频面-20min" class="headerlink" title="7.14 一面 视频面 20min"></a>7.14 一面 视频面 20min</h3><p>自我介绍</p>
<p>项目中的难点</p>
<p>GAN的基本介绍</p>
<p>SVM基本介绍及核函数的选用</p>
<p>机器学习常用的评估指标，怎样平衡精确率和召回率</p>
<p>LR与线性回归的区别与选用</p>
<p>特征工程的方法</p>
<p>数据清洗的方法</p>
<h1 id="中兴-深圳"><a href="#中兴-深圳" class="headerlink" title="中兴  深圳"></a>中兴  深圳</h1><h3 id="7-17-一面-电话面-60min"><a href="#7-17-一面-电话面-60min" class="headerlink" title="7.17 一面 电话面 60min"></a>7.17 一面 电话面 60min</h3><p>自我介绍，相关课程学习，成绩</p>
<p>是否有比赛经历</p>
<p>论文相关</p>
<p>防止过拟合的方法</p>
<p>自注意力机制</p>
<p>dropout的具体原理</p>
<p>贝叶斯公式，朴素贝叶斯的理论及应用</p>
<p>GAN的理论</p>
<p>评测指标precision,recall等</p>
<p>如果有大量数据无标签该怎么做分类</p>
<p>决策树的生成与剪枝</p>
<p>奇异值分解，PCA，关联性分析</p>
<p>聚类分析</p>
<p>KNN和Kmeans的区别</p>
<p>栈/队列</p>
<h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><h3 id="7-17-一面-算法-垂直策略-视频面-50min"><a href="#7-17-一面-算法-垂直策略-视频面-50min" class="headerlink" title="7.17 一面 算法-垂直策略 视频面 50min"></a>7.17 一面 算法-垂直策略 视频面 50min</h3><p>自我介绍</p>
<p>项目相关</p>
<p>LR与SVM区别</p>
<p>SVM损失函数</p>
<p>dropout的原理，测试和训练时的不同之处</p>
<p>网络深度的影响，可能导致的结果和现象</p>
<p>防止过拟合的方法</p>
<p>relu跟sigmoid</p>
<p>梯度消失原因，防止方法</p>
<p>Faster RCNN跟Fast RCNN的区别</p>
<p>数据扩充的方法，为什么不会对网络产生坏的影响</p>
<p>A与B玩抛硬币游戏，AB轮流抛一枚正反面均匀的硬币，谁先抛出正面谁就获胜，A先抛，问A获胜概率  2/3</p>
<p>redis会不会</p>
<p>cpp引用与指针的区别</p>
<p>编程：</p>
<ul>
<li><p>最长不重复子串，输出长度及字符串</p>
</li>
<li><p>一个多维嵌套的列表解嵌套，要求非递归法实现，[1,[1,[2,3]]]-&gt;[1,1,2,3]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]]</span><br><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(x)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        <span class="keyword">if</span> isinstance(i,list):</span><br><span class="line">            res += flatten(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(flatten(a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归法</span></span><br><span class="line"><span class="comment"># 遍历原始列表，对于列表内的元素，如果非列表就存入输出列表中，如果是列表元素，则进入该列表元素并查看列表内元素类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten_not</span><span class="params">(x)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> idx,i <span class="keyword">in</span> enumerate(x):</span><br><span class="line">            <span class="keyword">if</span> isinstance(i,list):</span><br><span class="line">                <span class="comment"># 将列表与之后的组合</span></span><br><span class="line">                x = i + x[idx+<span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">                x.pop(idx)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(flatten_not(a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten_not</span><span class="params">(x)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> x:</span><br><span class="line">        <span class="keyword">if</span> isinstance(x[<span class="number">0</span>],list):</span><br><span class="line">            x = x[<span class="number">0</span>] + x[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(x.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(flatten_not(a))</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="7-17-二面-算法-垂直策略-视频面-55min"><a href="#7-17-二面-算法-垂直策略-视频面-55min" class="headerlink" title="7.17 二面 算法-垂直策略 视频面 55min"></a>7.17 二面 算法-垂直策略 视频面 55min</h3><p>自我介绍</p>
<p>Adam的底层实现，是否适用于稀疏数据，对于输入是Word embedding，是加在输入的参数上，还是加在神经元的参数上</p>
<p>python多进程多线程的实现及应用</p>
<p>进程/线程之间的通信方式</p>
<p>编程：</p>
<ul>
<li><p>链表大数相加(链尾为低位)</p>
</li>
<li><p>梯度下降法求sqrt(a)，二分法呢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 二分法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_</span><span class="params">(y)</span>:</span></span><br><span class="line">    l,r = <span class="number">0</span>,y</span><br><span class="line">    mid = (l+r)/<span class="number">2.</span></span><br><span class="line">    <span class="keyword">while</span> abs(mid*mid-y)&gt;<span class="number">0.01</span>:</span><br><span class="line">        <span class="keyword">if</span> mid*mid&gt;y:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">elif</span> mid*mid&lt;y:</span><br><span class="line">            l = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        mid = (l+r)/<span class="number">2.</span></span><br><span class="line">    <span class="keyword">return</span> mid</span><br><span class="line">print(binary_(<span class="number">0.04</span>))</span><br><span class="line">print(binary_(<span class="number">4</span>))</span><br><span class="line">print(binary_(<span class="number">10</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降法：使得导数的极值点为y=x**2,即设损失函数为(y-x**2)**2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_</span><span class="params">(y)</span>:</span></span><br><span class="line">    x = <span class="number">1.</span></span><br><span class="line">    alpha = <span class="number">0.001</span></span><br><span class="line">    <span class="keyword">while</span> abs(y-x**<span class="number">2</span>)&gt;<span class="number">0.0001</span>:</span><br><span class="line">        gt = <span class="number">4</span>*x*(x**<span class="number">2</span>-y)</span><br><span class="line">        x -= alpha*gt</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">print(gradient_(<span class="number">0.04</span>))</span><br><span class="line">print(gradient_(<span class="number">4</span>))</span><br><span class="line">print(gradient_(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 牛顿法：计算f(x)=y-x**2=0的跟,则由泰勒公式f(x)=f(x0)+f'(x0)(x-x0),令f(x)为0,则有x=x0-f(x0)/f'(x0)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newton_</span><span class="params">(y)</span>:</span></span><br><span class="line">    x = <span class="number">1.</span></span><br><span class="line">    <span class="keyword">while</span> abs(y-x**<span class="number">2</span>)&gt;<span class="number">0.0001</span>:</span><br><span class="line">        x -= (y-x**<span class="number">2</span>)/(<span class="number">-2</span>*x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">print(newton_(<span class="number">0.04</span>))</span><br><span class="line">print(newton_(<span class="number">4</span>))</span><br><span class="line">print(newton_(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="7-30-一面-研发工程师（质量保障方向）-视频面-35min"><a href="#7-30-一面-研发工程师（质量保障方向）-视频面-35min" class="headerlink" title="7.30 一面 研发工程师（质量保障方向） 视频面 35min"></a>7.30 一面 研发工程师（质量保障方向） 视频面 35min</h3><p>输入一个链接，用户端和服务器端之间的交互过程</p>
<p>cookies和sessions</p>
<p>对于一个分布式系统，当一个用户在系统A上注册了信息，当再次发送请求时，传到了系统B上，怎样去判断是已注册的用户</p>
<p>一个相关项目(GAN的图像生成)</p>
<p>对于一个场景，比如输入一个关键字，浏览器会得到一系列的内容，怎样去做测试(比如最简单的就是一个一个链接点进去，看是不是跟输入的关键字相关)</p>
<p>怎样查看分布式系统的服务端口</p>
<p>数据结构栈/队列</p>
<p>手里的扑克牌由上到下第一张放桌子上，第二张放手里最下面，依次循环操作把手里牌全部放到桌子上；已知桌上由上到下的顺序，求手里扑克牌原来顺序，总张数是n;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># from collections import deque</span></span><br><span class="line">    <span class="comment"># nums = nums[::-1]</span></span><br><span class="line">    <span class="comment"># res = []</span></span><br><span class="line">    <span class="comment"># queue = deque()</span></span><br><span class="line">    <span class="comment"># for i in range(len(nums)-1,-1,-1):</span></span><br><span class="line">    <span class="comment">#     queue.append(nums[i])</span></span><br><span class="line">    <span class="comment">#     if i&gt;0:</span></span><br><span class="line">    <span class="comment">#         queue.append(queue.popleft())</span></span><br><span class="line">    <span class="comment"># while queue:</span></span><br><span class="line">    <span class="comment">#     res.append(queue.pop())</span></span><br><span class="line">    <span class="comment"># return res</span></span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        res.append(nums[i])</span><br><span class="line">        <span class="keyword">if</span> i&lt;len(nums)<span class="number">-1</span>:</span><br><span class="line">            res = res[<span class="number">1</span>:] + [res[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resolver</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment"># 1,2,3,4,5,6,7,...54</span></span><br><span class="line">    <span class="comment"># 第一次放下 1,3,5,7,...,53 手里剩2,4,6,8,...,54</span></span><br><span class="line">    <span class="comment"># 第二次放下 2,6,10,14,...,54 手里剩8,12,16,...,52,4</span></span><br><span class="line">    <span class="comment"># 第三次放下 8,16,24,...,48 手里剩4,12,20,28,36,44,52</span></span><br><span class="line">    <span class="comment"># 第四次放下 4,20,36,52 手里剩28,44,12</span></span><br><span class="line">    <span class="comment"># 第五次放下 28,12 手里剩44</span></span><br><span class="line">    <span class="comment"># 第六次放下 44</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> nums:</span><br><span class="line">        res.append(nums.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">if</span> nums:</span><br><span class="line">            nums = nums[<span class="number">1</span>:] + [nums[<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># print(nums)</span></span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">res = list(range(<span class="number">1</span>,<span class="number">55</span>))</span><br><span class="line">res = resolver(res)</span><br><span class="line">print(res)</span><br><span class="line">print(solver(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = list(range(1,55))</span></span><br><span class="line"><span class="comment"># res = solver(res)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"><span class="comment"># res = resolver(res)</span></span><br><span class="line"><span class="comment"># print(res)</span></span><br></pre></td></tr></table></figure>



<h3 id="9-6-一面-算法-产品研发-视频面-40min"><a href="#9-6-一面-算法-产品研发-视频面-40min" class="headerlink" title="9.6 一面 算法-产品研发 视频面 40min"></a>9.6 一面 算法-产品研发 视频面 40min</h3><p>自我介绍</p>
<p>项目介绍及创新点，评测方法等等</p>
<p>编程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">标题：最长连续子序列</span><br><span class="line">描述信息</span><br><span class="line">题目：</span><br><span class="line">给定一个整形数组长度为n</span><br><span class="line">求构造出子序列连续并且长度最大，要求子序列有顺序。</span><br><span class="line">连续定义序列 [x, x+<span class="number">1</span>, ..., x+k<span class="number">-1</span>] ，长度是k</span><br><span class="line">例如数组 [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] 的子序列 正确的表述例子， [<span class="number">3</span>] [<span class="number">5</span>,<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>] 但是 [<span class="number">1</span>, <span class="number">3</span>] 不是，因为要按照从左往右顺序 [<span class="number">3</span>, <span class="number">1</span>] 是正确的子序列。</span><br><span class="line">输入：</span><br><span class="line">n个整数，<span class="number">1</span>&lt;= n &lt;= <span class="number">200000</span></span><br><span class="line">a1, a2, ..., an (<span class="number">1</span>&lt;= ai &lt;= <span class="number">10</span>^<span class="number">9</span> ）</span><br><span class="line">输出：</span><br><span class="line">k</span><br><span class="line">任意一个可以组成最大长度的连续子序列的数组元素下标 数组，下标按照递增排列</span><br><span class="line">Example：</span><br><span class="line">input</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line">output</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> </span><br><span class="line">-----------</span><br><span class="line">input</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">output</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">15</span> <span class="number">16</span> </span><br><span class="line">---------</span><br><span class="line">input</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span></span><br><span class="line">output</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> </span><br><span class="line">---------</span><br><span class="line">input</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line">output</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化方法想不到呀，感觉都是O(n^2)复杂度</span></span><br><span class="line">n = int(input())</span><br><span class="line">nums = list(map(int,input().split()))</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    tmp = [i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> nums[j]==nums[tmp[<span class="number">-1</span>]]+<span class="number">1</span>:</span><br><span class="line">            tmp.append(j)</span><br><span class="line">    <span class="keyword">if</span> len(tmp)&gt;len(res):</span><br><span class="line">        res = tmp[:]</span><br><span class="line">print(len(res))</span><br><span class="line">print(<span class="string">" "</span>.join(map(str,[i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> res])))</span><br></pre></td></tr></table></figure>







<h1 id="大华"><a href="#大华" class="headerlink" title="大华"></a>大华</h1><h3 id="7-22-一面-电话面-45min"><a href="#7-22-一面-电话面-45min" class="headerlink" title="7.22 一面 电话面 45min"></a>7.22 一面 电话面 45min</h3><p>项目相关</p>
<p>c++中堆和栈，内存中堆区和栈区</p>
<p>c++中malloc和new的区别</p>
<p>传统图像算法LBP，直方图均衡等</p>
<p>L1,L2</p>
<p>SVM介绍，核函数选用</p>
<p>Bagging和Boosting</p>
<p>cyclegan的原理</p>
<p>dropout，dropconnect</p>
<p>卷积核参数量的计算，计算量的计算，为什么参数量跟特征层大小无关</p>
<p>感受野的介绍及计算</p>
<p>bn在pytorch中的细节</p>
<p>yolo v2和v3的区别</p>
<p>yolo v4</p>
<p>yolo route在caffe中的表示？</p>
<p>faster rcnn的ROI pooling</p>
<p>lstm的门控装置</p>
<h3 id="7-30-二面-电话面-11min"><a href="#7-30-二面-电话面-11min" class="headerlink" title="7.30 二面 电话面 11min"></a>7.30 二面 电话面 11min</h3><p>毕设方向，dropout，variational dropout，在GAN中的作用</p>
<p>EM算法</p>
<p>数据结构栈</p>
<p>static关键字的作用，存储在哪个内存区</p>
<p>caffe了解么</p>
<p>faster rcnn</p>
<p>隐马尔可夫模型了解么</p>
<h1 id="作业帮-数据挖掘-机器学习算法-北京"><a href="#作业帮-数据挖掘-机器学习算法-北京" class="headerlink" title="作业帮-数据挖掘/机器学习算法 北京"></a>作业帮-数据挖掘/机器学习算法 北京</h1><h3 id="7-28-一面-视频面-51min"><a href="#7-28-一面-视频面-51min" class="headerlink" title="7.28 一面 视频面 51min"></a>7.28 一面 视频面 51min</h3><p>dropout的原理、输入与测试的区别、变分dropout的原理、损失的限制</p>
<p>BN的原理，BN放在激活函数前/后的好处和问题</p>
<p>对于一个DNN，输出sigmoid层对于所有输入均为0.5，可能的原因(我推导出来是w==0，猜测了欠拟合问题，参数初始化问题，relu的神经元坏死现象，梯度消失现象) 面试官说是他遇到的工程问题，最后是通过使用relu替换sigmoid，具体原因不得而知</p>
<p>LR中L1,L2正则化</p>
<p>编程：链表反转</p>
<p>编程：分割回文串 “aacab”  [[“a”,”a”,”c”,”a”,”b”],[“a”,”aca”,”b”],[“aa”,”c”,”a”,”b”]]</p>
<h3 id="7-31-二面-视频面-30min"><a href="#7-31-二面-视频面-30min" class="headerlink" title="7.31 二面 视频面 30min"></a>7.31 二面 视频面 30min</h3><p>详细介绍下dropout和varitional dropout</p>
<p>详细介绍GAN和WGAN，JS散度的不好的地方，WGAN的改进点</p>
<p>有什么其它改进GAN的地方</p>
<p>GAN跟VAE的区别</p>
<p>编程：顺时针打印矩阵：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字</p>
<h1 id="跟谁学"><a href="#跟谁学" class="headerlink" title="跟谁学"></a>跟谁学</h1><h3 id="7-30-一面-视频面-70min"><a href="#7-30-一面-视频面-70min" class="headerlink" title="7.30 一面 视频面 70min"></a>7.30 一面 视频面 70min</h3><p>dropout的相关原理，variational dropout的相关原理，评测指标，是否有做收敛的上限来限制防止欠拟合</p>
<p>人脸老化的任务，模型</p>
<p>目标检测的工作，怎样做数据处理等</p>
<ol>
<li>一个自然数序列a[n]，找到一个最大的a[k]，满足 a[k] = a[i] + a[j]，i、j、k属于n</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(a)</span>:</span></span><br><span class="line">    a.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        l,r = <span class="number">0</span>,i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l&lt;r:</span><br><span class="line">            <span class="keyword">if</span> a[l]+a[r]==a[i]:</span><br><span class="line">                <span class="keyword">return</span> a[i]</span><br><span class="line">            <span class="keyword">if</span> a[l]+a[r]&lt;a[i]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(grades)</span>:</span></span><br><span class="line">    stack = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(grades))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(grades)):</span><br><span class="line">        <span class="keyword">if</span> grades[i]&gt;grades[i<span class="number">-1</span>]:</span><br><span class="line">            stack[i] = stack[i<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> stack[i<span class="number">-1</span>]!=<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> grades[j]&lt;grades[j<span class="number">-1</span>]:</span><br><span class="line">                stack[j] += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure>





<h1 id="新浪"><a href="#新浪" class="headerlink" title="新浪"></a>新浪</h1><h3 id="7-31-一面-视频面-55min"><a href="#7-31-一面-视频面-55min" class="headerlink" title="7.31 一面 视频面 55min"></a>7.31 一面 视频面 55min</h3><p>自我介绍</p>
<p>dropout variational dropout</p>
<p>svm</p>
<p>l1 l2正则化，为什么是高斯分布和拉普拉斯分布</p>
<p>embedding，fm了解吗，为什么需要embedding</p>
<p>编程：合法的括号：给定n，构建所有合法的括号</p>
<p>编程：链表删除倒数第n个结点</p>
<h3 id="8-4-二面-视频面-60min"><a href="#8-4-二面-视频面-60min" class="headerlink" title="8.4 二面 视频面 60min"></a>8.4 二面 视频面 60min</h3><p>自我介绍</p>
<p>dropout variational dropout</p>
<p>模型稀疏的作用</p>
<p>模型非线性性</p>
<p>常见的激活函数</p>
<p>常见的损失函数</p>
<p>GAN网络的原理</p>
<p>反向传播的公式</p>
<p>防止过拟合的方法，梯度爆炸</p>
<p>l1,l2正则化的区别</p>
<p>决策树，随机森林，XGBoost</p>
<p>特征工程，特征选择</p>
<p>深度学习和机器学习的选用，区别</p>
<p>编程：全排列，给定一个无重复的字符串，输出所有排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(nums)</span>:</span></span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path)==len(nums):</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited.add(nums[i])</span><br><span class="line">                helper(path+nums[i])</span><br><span class="line">                visited.remove(nums[i])</span><br><span class="line">    res = []</span><br><span class="line">    helper(<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(solver(<span class="string">'abcd'</span>))</span><br></pre></td></tr></table></figure>

<p>逻辑题：</p>
<p>两人打乒乓球，A胜的概率为2/3，B胜的概率为1/3，则5局3胜好还是7局4胜好(7局4胜好)</p>
<p>一个村子的村民，如果生的孩子是女生，则会一直生到男孩为止，如果是男生则会立即停止，问100年后，男孩和女孩谁多谁少(一样多)</p>
<h1 id="竞技世界"><a href="#竞技世界" class="headerlink" title="竞技世界"></a>竞技世界</h1><h3 id="8-11-一面-视频面-40min"><a href="#8-11-一面-视频面-40min" class="headerlink" title="8.11 一面 视频面 40min"></a>8.11 一面 视频面 40min</h3><p>自我介绍</p>
<p>防止过拟合的方法</p>
<p>多模态的方法</p>
<p>BN的详细介绍</p>
<p>其它Normalization，为什么GN适用于小样本数据集</p>
<p>GAN的基本原理，经典GAN的缺点，年龄标签，身份特征，风格转换等相关的方法</p>
<p>GAN跟VAE的关系</p>
<p>FasterRCNN的详细流程 跟RCNN的区别</p>
<p>YOLO的相关理解</p>
<h1 id="网易互联网-网易云音乐"><a href="#网易互联网-网易云音乐" class="headerlink" title="网易互联网-网易云音乐"></a>网易互联网-网易云音乐</h1><h3 id="8-15-一面-视频面-40min"><a href="#8-15-一面-视频面-40min" class="headerlink" title="8.15 一面 视频面 40min"></a>8.15 一面 视频面 40min</h3><p>自我介绍</p>
<p>编程：快排，平均时间复杂度，最差时间复杂度，优化方法</p>
<p>GAN网络的基本理论，损失函数，优缺点</p>
<p>常见的激活函数及优缺点</p>
<p>出现什么现象是梯度消失和梯度爆炸，可能的原因及解决方法</p>
<p>工程上出现的问题及解决方法，团队的沟通</p>
<p>LR的基本介绍及优缺点，为什么选择最大似然最为损失函数(这里没答好！！)</p>
<p>SVM的基本介绍，核函数选用等</p>
<h3 id="8-18-二面-视频面-30min"><a href="#8-18-二面-视频面-30min" class="headerlink" title="8.18 二面 视频面 30min"></a>8.18 二面 视频面 30min</h3><p>自我介绍</p>
<p>项目dropout的动机，评测指标等(过拟合及模型压缩)</p>
<p>GAN的基本原理，论文的优化做法</p>
<p>GBDT的介绍</p>
<p>CNN的介绍</p>
<p>了解的推荐或者搜索算法(讲了下fm)</p>
<h1 id="昆仑万维"><a href="#昆仑万维" class="headerlink" title="昆仑万维"></a>昆仑万维</h1><h3 id="8-17-一面-视频面-45min"><a href="#8-17-一面-视频面-45min" class="headerlink" title="8.17 一面 视频面 45min"></a>8.17 一面 视频面 45min</h3><p>自我介绍</p>
<p>XGBoost的一些可以调整的参数，怎样去防止过拟合</p>
<p>XGBoost可以用来做并行化吗</p>
<p>SVM的核函数及选用</p>
<p>SVM怎么做多分类</p>
<p>决策树的信息增益和信息增益比的区别</p>
<p>决策树做分类和回归的损失函数</p>
<p>防止过拟合的方法</p>
<p>常用的优化器</p>
<p>常用的损失函数，了解三元组损失吗</p>
<p>BN的详细步骤</p>
<p>常用的激活函数</p>
<p>数据增强的方法</p>
<p>使用什么语言及编译环境，怎么运行</p>
<p>vim里面的查找</p>
<p>linux的复制，移动命令</p>
<p>一个sql语句：</p>
<p>叫做用户留存 说是第一天新注册的用户，第二天登录了就叫留存，然后查找具体某一天的留存量</p>
<h1 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h1><h3 id="8-24-一面-视频面-70min"><a href="#8-24-一面-视频面-70min" class="headerlink" title="8.24 一面 视频面 70min"></a>8.24 一面 视频面 70min</h3><p>自我介绍</p>
<p>相关项目(dropout,vdropout的动机，GAN的基本原理，论文的动机做法等等，GAN的一些改进，怎样在GAN训练的时候评测效果，是否过拟合等等)</p>
<p>防止过拟合的方法</p>
<p>L1与L2正则化的区别</p>
<p>sigmoid和softmax的区别及损失函数</p>
<p>cnn的动机与原理</p>
<p>常见的激活函数</p>
<p>常见的分类/回归损失函数</p>
<p>resnet的介绍，两种resnet的形式，后序的改进(densenet)</p>
<p>pytorch和tensorflow的使用</p>
<p>handoop的思想</p>
<p>2个矩阵乘法的原理，时间复杂度，优化方法</p>
<p>从一亿个数中选出top10</p>
<p>从一亿个数中查找数k是否存在</p>
<p>快排的思想，时间复杂度及优化(问双轴的快排，我说类似于bfs搜索的时候两点往中间靠?)</p>
<h3 id="8-27-二面-视频面-40min"><a href="#8-27-二面-视频面-40min" class="headerlink" title="8.27 二面 视频面 40min"></a>8.27 二面 视频面 40min</h3><p>自我介绍</p>
<p>人脸老化的项目</p>
<p>防止过拟合的方法</p>
<p>logisitic回归和线性回归的区别及应用场景</p>
<p>模式识别和机器学习的区别</p>
<p>图片怎样做特征处理</p>
<p>堆和队列的区别</p>
<p>冒泡排序和快排的时间复杂度</p>
<p>编程：一个字符串反转，一个找连续数组(0-n)的缺失值，一个是找和为0的最长子数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver</span><span class="params">(strs)</span>:</span></span><br><span class="line">	res = <span class="string">''</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;len(strs):</span><br><span class="line">    	tmp = <span class="string">''</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(strs) <span class="keyword">and</span> strs[i]!=<span class="string">' '</span>:</span><br><span class="line">        	tmp += strs[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(strs) <span class="keyword">and</span> strs[i]==<span class="string">' '</span>:</span><br><span class="line">        	i += <span class="number">1</span></span><br><span class="line">        res = tmp +<span class="string">' '</span>+ res <span class="keyword">if</span> res <span class="keyword">else</span> tmp</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(solver(<span class="string">'I love cat.'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver1</span><span class="params">(nums)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> nums[<span class="number">0</span>]!=<span class="number">0</span>:</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> nums[<span class="number">-1</span>]!=len(nums):</span><br><span class="line">    	retun len(nums)</span><br><span class="line">    l,r = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;r:</span><br><span class="line">    	mid = (l+r)&gt;&gt;<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid]==mid:</span><br><span class="line">        	l = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	r = mid</span><br><span class="line">    retun l</span><br><span class="line">print(solver1([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solver2</span><span class="params">(nums)</span>:</span></span><br><span class="line">	hashtable = &#123;nums[<span class="number">0</span>]:<span class="number">0</span>&#125;</span><br><span class="line">    cur = nums[<span class="number">0</span>]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">    	cur += nums[i]</span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">in</span> hashtable:</span><br><span class="line">        	res = max(res,i-hashtable[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            hashtable[cur] = i</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(solver2([<span class="number">15</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-8</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">23</span>]))</span><br></pre></td></tr></table></figure>





<h1 id="滴滴-国际化事业部"><a href="#滴滴-国际化事业部" class="headerlink" title="滴滴-国际化事业部"></a>滴滴-国际化事业部</h1><h3 id="8-29-一面-视频面-40min"><a href="#8-29-一面-视频面-40min" class="headerlink" title="8.29 一面 视频面 40min"></a>8.29 一面 视频面 40min</h3><p>自我介绍</p>
<p>常见的正则化，归一化方法</p>
<p>常见的损失函数，交叉熵损失函数怎么优化的</p>
<p>SVM</p>
<p>决策树算法</p>
<p>集成方法，怎么处理缺失值的等等</p>
<p>编程：编辑距离</p>
<h3 id="8-29-二面-视频面-45min"><a href="#8-29-二面-视频面-45min" class="headerlink" title="8.29 二面 视频面 45min"></a>8.29 二面 视频面 45min</h3><p>自我介绍，项目介绍</p>
<p>对于一个3x3x3的魔方，从表面任意一个地方出发，能到中心点吗，为什么到不了中心点</p>
<p>编程：最长上升子序列</p>
<h3 id="8-29-三面-视频面-40min"><a href="#8-29-三面-视频面-40min" class="headerlink" title="8.29 三面 视频面 40min"></a>8.29 三面 视频面 40min</h3><p>自我介绍</p>
<p>场景题：对于共享单车，比如已经知道一些历史的数据，我怎样去预测调度</p>
<p>概率题：抛硬币，正反面概率均为1/2，连续两次则停止，问期望次数</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>求职</tag>
      </tags>
  </entry>
</search>
